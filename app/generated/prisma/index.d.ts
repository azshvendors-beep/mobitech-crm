
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Admin
 * 
 */
export type Admin = $Result.DefaultSelection<Prisma.$AdminPayload>
/**
 * Model Manager
 * 
 */
export type Manager = $Result.DefaultSelection<Prisma.$ManagerPayload>
/**
 * Model Technician
 * 
 */
export type Technician = $Result.DefaultSelection<Prisma.$TechnicianPayload>
/**
 * Model FieldExecutive
 * 
 */
export type FieldExecutive = $Result.DefaultSelection<Prisma.$FieldExecutivePayload>
/**
 * Model SalesExecutive
 * 
 */
export type SalesExecutive = $Result.DefaultSelection<Prisma.$SalesExecutivePayload>
/**
 * Model Store
 * 
 */
export type Store = $Result.DefaultSelection<Prisma.$StorePayload>
/**
 * Model BankDetails
 * 
 */
export type BankDetails = $Result.DefaultSelection<Prisma.$BankDetailsPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model DeviceTest
 * 
 */
export type DeviceTest = $Result.DefaultSelection<Prisma.$DeviceTestPayload>
/**
 * Model ConnectivityTestResult
 * 
 */
export type ConnectivityTestResult = $Result.DefaultSelection<Prisma.$ConnectivityTestResultPayload>
/**
 * Model DeviceTestResult
 * 
 */
export type DeviceTestResult = $Result.DefaultSelection<Prisma.$DeviceTestResultPayload>
/**
 * Model SimTestResult
 * 
 */
export type SimTestResult = $Result.DefaultSelection<Prisma.$SimTestResultPayload>
/**
 * Model ScreenTest
 * 
 */
export type ScreenTest = $Result.DefaultSelection<Prisma.$ScreenTestPayload>
/**
 * Model AudioTest
 * 
 */
export type AudioTest = $Result.DefaultSelection<Prisma.$AudioTestPayload>
/**
 * Model ProximitySensorTest
 * 
 */
export type ProximitySensorTest = $Result.DefaultSelection<Prisma.$ProximitySensorTestPayload>
/**
 * Model CameraTest
 * 
 */
export type CameraTest = $Result.DefaultSelection<Prisma.$CameraTestPayload>
/**
 * Model FingerprintTest
 * 
 */
export type FingerprintTest = $Result.DefaultSelection<Prisma.$FingerprintTestPayload>
/**
 * Model UsbTest
 * 
 */
export type UsbTest = $Result.DefaultSelection<Prisma.$UsbTestPayload>
/**
 * Model AudioJackTest
 * 
 */
export type AudioJackTest = $Result.DefaultSelection<Prisma.$AudioJackTestPayload>
/**
 * Model ManualDiagnosticsResult
 * 
 */
export type ManualDiagnosticsResult = $Result.DefaultSelection<Prisma.$ManualDiagnosticsResultPayload>
/**
 * Model Declaration
 * 
 */
export type Declaration = $Result.DefaultSelection<Prisma.$DeclarationPayload>
/**
 * Model Address
 * 
 */
export type Address = $Result.DefaultSelection<Prisma.$AddressPayload>
/**
 * Model Otp
 * 
 */
export type Otp = $Result.DefaultSelection<Prisma.$OtpPayload>
/**
 * Model CustomModelBrand
 * 
 */
export type CustomModelBrand = $Result.DefaultSelection<Prisma.$CustomModelBrandPayload>
/**
 * Model CustomModel
 * 
 */
export type CustomModel = $Result.DefaultSelection<Prisma.$CustomModelPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserStatus: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE'
};

export type UserStatus = (typeof UserStatus)[keyof typeof UserStatus]


export const Role: {
  ADMIN: 'ADMIN',
  MANAGER: 'MANAGER',
  FIELD_EXECUTIVE: 'FIELD_EXECUTIVE',
  MARKETING_EXECUTIVE: 'MARKETING_EXECUTIVE',
  TECHNICIAN: 'TECHNICIAN',
  STORE_OWNER: 'STORE_OWNER'
};

export type Role = (typeof Role)[keyof typeof Role]

}

export type UserStatus = $Enums.UserStatus

export const UserStatus: typeof $Enums.UserStatus

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.admin`: Exposes CRUD operations for the **Admin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admins
    * const admins = await prisma.admin.findMany()
    * ```
    */
  get admin(): Prisma.AdminDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.manager`: Exposes CRUD operations for the **Manager** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Managers
    * const managers = await prisma.manager.findMany()
    * ```
    */
  get manager(): Prisma.ManagerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.technician`: Exposes CRUD operations for the **Technician** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Technicians
    * const technicians = await prisma.technician.findMany()
    * ```
    */
  get technician(): Prisma.TechnicianDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fieldExecutive`: Exposes CRUD operations for the **FieldExecutive** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FieldExecutives
    * const fieldExecutives = await prisma.fieldExecutive.findMany()
    * ```
    */
  get fieldExecutive(): Prisma.FieldExecutiveDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.salesExecutive`: Exposes CRUD operations for the **SalesExecutive** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SalesExecutives
    * const salesExecutives = await prisma.salesExecutive.findMany()
    * ```
    */
  get salesExecutive(): Prisma.SalesExecutiveDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.store`: Exposes CRUD operations for the **Store** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Stores
    * const stores = await prisma.store.findMany()
    * ```
    */
  get store(): Prisma.StoreDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bankDetails`: Exposes CRUD operations for the **BankDetails** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BankDetails
    * const bankDetails = await prisma.bankDetails.findMany()
    * ```
    */
  get bankDetails(): Prisma.BankDetailsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.deviceTest`: Exposes CRUD operations for the **DeviceTest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeviceTests
    * const deviceTests = await prisma.deviceTest.findMany()
    * ```
    */
  get deviceTest(): Prisma.DeviceTestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.connectivityTestResult`: Exposes CRUD operations for the **ConnectivityTestResult** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConnectivityTestResults
    * const connectivityTestResults = await prisma.connectivityTestResult.findMany()
    * ```
    */
  get connectivityTestResult(): Prisma.ConnectivityTestResultDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.deviceTestResult`: Exposes CRUD operations for the **DeviceTestResult** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeviceTestResults
    * const deviceTestResults = await prisma.deviceTestResult.findMany()
    * ```
    */
  get deviceTestResult(): Prisma.DeviceTestResultDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.simTestResult`: Exposes CRUD operations for the **SimTestResult** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SimTestResults
    * const simTestResults = await prisma.simTestResult.findMany()
    * ```
    */
  get simTestResult(): Prisma.SimTestResultDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.screenTest`: Exposes CRUD operations for the **ScreenTest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ScreenTests
    * const screenTests = await prisma.screenTest.findMany()
    * ```
    */
  get screenTest(): Prisma.ScreenTestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.audioTest`: Exposes CRUD operations for the **AudioTest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AudioTests
    * const audioTests = await prisma.audioTest.findMany()
    * ```
    */
  get audioTest(): Prisma.AudioTestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.proximitySensorTest`: Exposes CRUD operations for the **ProximitySensorTest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProximitySensorTests
    * const proximitySensorTests = await prisma.proximitySensorTest.findMany()
    * ```
    */
  get proximitySensorTest(): Prisma.ProximitySensorTestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cameraTest`: Exposes CRUD operations for the **CameraTest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CameraTests
    * const cameraTests = await prisma.cameraTest.findMany()
    * ```
    */
  get cameraTest(): Prisma.CameraTestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fingerprintTest`: Exposes CRUD operations for the **FingerprintTest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FingerprintTests
    * const fingerprintTests = await prisma.fingerprintTest.findMany()
    * ```
    */
  get fingerprintTest(): Prisma.FingerprintTestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.usbTest`: Exposes CRUD operations for the **UsbTest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UsbTests
    * const usbTests = await prisma.usbTest.findMany()
    * ```
    */
  get usbTest(): Prisma.UsbTestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.audioJackTest`: Exposes CRUD operations for the **AudioJackTest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AudioJackTests
    * const audioJackTests = await prisma.audioJackTest.findMany()
    * ```
    */
  get audioJackTest(): Prisma.AudioJackTestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.manualDiagnosticsResult`: Exposes CRUD operations for the **ManualDiagnosticsResult** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ManualDiagnosticsResults
    * const manualDiagnosticsResults = await prisma.manualDiagnosticsResult.findMany()
    * ```
    */
  get manualDiagnosticsResult(): Prisma.ManualDiagnosticsResultDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.declaration`: Exposes CRUD operations for the **Declaration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Declarations
    * const declarations = await prisma.declaration.findMany()
    * ```
    */
  get declaration(): Prisma.DeclarationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.address`: Exposes CRUD operations for the **Address** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Addresses
    * const addresses = await prisma.address.findMany()
    * ```
    */
  get address(): Prisma.AddressDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.otp`: Exposes CRUD operations for the **Otp** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Otps
    * const otps = await prisma.otp.findMany()
    * ```
    */
  get otp(): Prisma.OtpDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customModelBrand`: Exposes CRUD operations for the **CustomModelBrand** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomModelBrands
    * const customModelBrands = await prisma.customModelBrand.findMany()
    * ```
    */
  get customModelBrand(): Prisma.CustomModelBrandDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customModel`: Exposes CRUD operations for the **CustomModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomModels
    * const customModels = await prisma.customModel.findMany()
    * ```
    */
  get customModel(): Prisma.CustomModelDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.15.0
   * Query Engine version: 85179d7826409ee107a6ba334b5e305ae3fba9fb
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Admin: 'Admin',
    Manager: 'Manager',
    Technician: 'Technician',
    FieldExecutive: 'FieldExecutive',
    SalesExecutive: 'SalesExecutive',
    Store: 'Store',
    BankDetails: 'BankDetails',
    Session: 'Session',
    Notification: 'Notification',
    DeviceTest: 'DeviceTest',
    ConnectivityTestResult: 'ConnectivityTestResult',
    DeviceTestResult: 'DeviceTestResult',
    SimTestResult: 'SimTestResult',
    ScreenTest: 'ScreenTest',
    AudioTest: 'AudioTest',
    ProximitySensorTest: 'ProximitySensorTest',
    CameraTest: 'CameraTest',
    FingerprintTest: 'FingerprintTest',
    UsbTest: 'UsbTest',
    AudioJackTest: 'AudioJackTest',
    ManualDiagnosticsResult: 'ManualDiagnosticsResult',
    Declaration: 'Declaration',
    Address: 'Address',
    Otp: 'Otp',
    CustomModelBrand: 'CustomModelBrand',
    CustomModel: 'CustomModel'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "admin" | "manager" | "technician" | "fieldExecutive" | "salesExecutive" | "store" | "bankDetails" | "session" | "notification" | "deviceTest" | "connectivityTestResult" | "deviceTestResult" | "simTestResult" | "screenTest" | "audioTest" | "proximitySensorTest" | "cameraTest" | "fingerprintTest" | "usbTest" | "audioJackTest" | "manualDiagnosticsResult" | "declaration" | "address" | "otp" | "customModelBrand" | "customModel"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Admin: {
        payload: Prisma.$AdminPayload<ExtArgs>
        fields: Prisma.AdminFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findFirst: {
            args: Prisma.AdminFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findMany: {
            args: Prisma.AdminFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          create: {
            args: Prisma.AdminCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          createMany: {
            args: Prisma.AdminCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          delete: {
            args: Prisma.AdminDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          update: {
            args: Prisma.AdminUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          deleteMany: {
            args: Prisma.AdminDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdminUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          upsert: {
            args: Prisma.AdminUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          aggregate: {
            args: Prisma.AdminAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdmin>
          }
          groupBy: {
            args: Prisma.AdminGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminCountArgs<ExtArgs>
            result: $Utils.Optional<AdminCountAggregateOutputType> | number
          }
        }
      }
      Manager: {
        payload: Prisma.$ManagerPayload<ExtArgs>
        fields: Prisma.ManagerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ManagerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ManagerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload>
          }
          findFirst: {
            args: Prisma.ManagerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ManagerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload>
          }
          findMany: {
            args: Prisma.ManagerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload>[]
          }
          create: {
            args: Prisma.ManagerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload>
          }
          createMany: {
            args: Prisma.ManagerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ManagerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload>[]
          }
          delete: {
            args: Prisma.ManagerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload>
          }
          update: {
            args: Prisma.ManagerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload>
          }
          deleteMany: {
            args: Prisma.ManagerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ManagerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ManagerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload>[]
          }
          upsert: {
            args: Prisma.ManagerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload>
          }
          aggregate: {
            args: Prisma.ManagerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateManager>
          }
          groupBy: {
            args: Prisma.ManagerGroupByArgs<ExtArgs>
            result: $Utils.Optional<ManagerGroupByOutputType>[]
          }
          count: {
            args: Prisma.ManagerCountArgs<ExtArgs>
            result: $Utils.Optional<ManagerCountAggregateOutputType> | number
          }
        }
      }
      Technician: {
        payload: Prisma.$TechnicianPayload<ExtArgs>
        fields: Prisma.TechnicianFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TechnicianFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicianPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TechnicianFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicianPayload>
          }
          findFirst: {
            args: Prisma.TechnicianFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicianPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TechnicianFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicianPayload>
          }
          findMany: {
            args: Prisma.TechnicianFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicianPayload>[]
          }
          create: {
            args: Prisma.TechnicianCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicianPayload>
          }
          createMany: {
            args: Prisma.TechnicianCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TechnicianCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicianPayload>[]
          }
          delete: {
            args: Prisma.TechnicianDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicianPayload>
          }
          update: {
            args: Prisma.TechnicianUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicianPayload>
          }
          deleteMany: {
            args: Prisma.TechnicianDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TechnicianUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TechnicianUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicianPayload>[]
          }
          upsert: {
            args: Prisma.TechnicianUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicianPayload>
          }
          aggregate: {
            args: Prisma.TechnicianAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTechnician>
          }
          groupBy: {
            args: Prisma.TechnicianGroupByArgs<ExtArgs>
            result: $Utils.Optional<TechnicianGroupByOutputType>[]
          }
          count: {
            args: Prisma.TechnicianCountArgs<ExtArgs>
            result: $Utils.Optional<TechnicianCountAggregateOutputType> | number
          }
        }
      }
      FieldExecutive: {
        payload: Prisma.$FieldExecutivePayload<ExtArgs>
        fields: Prisma.FieldExecutiveFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FieldExecutiveFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldExecutivePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FieldExecutiveFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldExecutivePayload>
          }
          findFirst: {
            args: Prisma.FieldExecutiveFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldExecutivePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FieldExecutiveFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldExecutivePayload>
          }
          findMany: {
            args: Prisma.FieldExecutiveFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldExecutivePayload>[]
          }
          create: {
            args: Prisma.FieldExecutiveCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldExecutivePayload>
          }
          createMany: {
            args: Prisma.FieldExecutiveCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FieldExecutiveCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldExecutivePayload>[]
          }
          delete: {
            args: Prisma.FieldExecutiveDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldExecutivePayload>
          }
          update: {
            args: Prisma.FieldExecutiveUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldExecutivePayload>
          }
          deleteMany: {
            args: Prisma.FieldExecutiveDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FieldExecutiveUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FieldExecutiveUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldExecutivePayload>[]
          }
          upsert: {
            args: Prisma.FieldExecutiveUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldExecutivePayload>
          }
          aggregate: {
            args: Prisma.FieldExecutiveAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFieldExecutive>
          }
          groupBy: {
            args: Prisma.FieldExecutiveGroupByArgs<ExtArgs>
            result: $Utils.Optional<FieldExecutiveGroupByOutputType>[]
          }
          count: {
            args: Prisma.FieldExecutiveCountArgs<ExtArgs>
            result: $Utils.Optional<FieldExecutiveCountAggregateOutputType> | number
          }
        }
      }
      SalesExecutive: {
        payload: Prisma.$SalesExecutivePayload<ExtArgs>
        fields: Prisma.SalesExecutiveFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SalesExecutiveFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesExecutivePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SalesExecutiveFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesExecutivePayload>
          }
          findFirst: {
            args: Prisma.SalesExecutiveFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesExecutivePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SalesExecutiveFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesExecutivePayload>
          }
          findMany: {
            args: Prisma.SalesExecutiveFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesExecutivePayload>[]
          }
          create: {
            args: Prisma.SalesExecutiveCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesExecutivePayload>
          }
          createMany: {
            args: Prisma.SalesExecutiveCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SalesExecutiveCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesExecutivePayload>[]
          }
          delete: {
            args: Prisma.SalesExecutiveDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesExecutivePayload>
          }
          update: {
            args: Prisma.SalesExecutiveUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesExecutivePayload>
          }
          deleteMany: {
            args: Prisma.SalesExecutiveDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SalesExecutiveUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SalesExecutiveUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesExecutivePayload>[]
          }
          upsert: {
            args: Prisma.SalesExecutiveUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesExecutivePayload>
          }
          aggregate: {
            args: Prisma.SalesExecutiveAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSalesExecutive>
          }
          groupBy: {
            args: Prisma.SalesExecutiveGroupByArgs<ExtArgs>
            result: $Utils.Optional<SalesExecutiveGroupByOutputType>[]
          }
          count: {
            args: Prisma.SalesExecutiveCountArgs<ExtArgs>
            result: $Utils.Optional<SalesExecutiveCountAggregateOutputType> | number
          }
        }
      }
      Store: {
        payload: Prisma.$StorePayload<ExtArgs>
        fields: Prisma.StoreFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StoreFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StoreFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>
          }
          findFirst: {
            args: Prisma.StoreFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StoreFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>
          }
          findMany: {
            args: Prisma.StoreFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>[]
          }
          create: {
            args: Prisma.StoreCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>
          }
          createMany: {
            args: Prisma.StoreCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StoreCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>[]
          }
          delete: {
            args: Prisma.StoreDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>
          }
          update: {
            args: Prisma.StoreUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>
          }
          deleteMany: {
            args: Prisma.StoreDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StoreUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StoreUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>[]
          }
          upsert: {
            args: Prisma.StoreUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>
          }
          aggregate: {
            args: Prisma.StoreAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStore>
          }
          groupBy: {
            args: Prisma.StoreGroupByArgs<ExtArgs>
            result: $Utils.Optional<StoreGroupByOutputType>[]
          }
          count: {
            args: Prisma.StoreCountArgs<ExtArgs>
            result: $Utils.Optional<StoreCountAggregateOutputType> | number
          }
        }
      }
      BankDetails: {
        payload: Prisma.$BankDetailsPayload<ExtArgs>
        fields: Prisma.BankDetailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BankDetailsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankDetailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BankDetailsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankDetailsPayload>
          }
          findFirst: {
            args: Prisma.BankDetailsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankDetailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BankDetailsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankDetailsPayload>
          }
          findMany: {
            args: Prisma.BankDetailsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankDetailsPayload>[]
          }
          create: {
            args: Prisma.BankDetailsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankDetailsPayload>
          }
          createMany: {
            args: Prisma.BankDetailsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BankDetailsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankDetailsPayload>[]
          }
          delete: {
            args: Prisma.BankDetailsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankDetailsPayload>
          }
          update: {
            args: Prisma.BankDetailsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankDetailsPayload>
          }
          deleteMany: {
            args: Prisma.BankDetailsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BankDetailsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BankDetailsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankDetailsPayload>[]
          }
          upsert: {
            args: Prisma.BankDetailsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankDetailsPayload>
          }
          aggregate: {
            args: Prisma.BankDetailsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBankDetails>
          }
          groupBy: {
            args: Prisma.BankDetailsGroupByArgs<ExtArgs>
            result: $Utils.Optional<BankDetailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.BankDetailsCountArgs<ExtArgs>
            result: $Utils.Optional<BankDetailsCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      DeviceTest: {
        payload: Prisma.$DeviceTestPayload<ExtArgs>
        fields: Prisma.DeviceTestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeviceTestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeviceTestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTestPayload>
          }
          findFirst: {
            args: Prisma.DeviceTestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeviceTestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTestPayload>
          }
          findMany: {
            args: Prisma.DeviceTestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTestPayload>[]
          }
          create: {
            args: Prisma.DeviceTestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTestPayload>
          }
          createMany: {
            args: Prisma.DeviceTestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeviceTestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTestPayload>[]
          }
          delete: {
            args: Prisma.DeviceTestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTestPayload>
          }
          update: {
            args: Prisma.DeviceTestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTestPayload>
          }
          deleteMany: {
            args: Prisma.DeviceTestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeviceTestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DeviceTestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTestPayload>[]
          }
          upsert: {
            args: Prisma.DeviceTestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTestPayload>
          }
          aggregate: {
            args: Prisma.DeviceTestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeviceTest>
          }
          groupBy: {
            args: Prisma.DeviceTestGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeviceTestGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeviceTestCountArgs<ExtArgs>
            result: $Utils.Optional<DeviceTestCountAggregateOutputType> | number
          }
        }
      }
      ConnectivityTestResult: {
        payload: Prisma.$ConnectivityTestResultPayload<ExtArgs>
        fields: Prisma.ConnectivityTestResultFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConnectivityTestResultFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectivityTestResultPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConnectivityTestResultFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectivityTestResultPayload>
          }
          findFirst: {
            args: Prisma.ConnectivityTestResultFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectivityTestResultPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConnectivityTestResultFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectivityTestResultPayload>
          }
          findMany: {
            args: Prisma.ConnectivityTestResultFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectivityTestResultPayload>[]
          }
          create: {
            args: Prisma.ConnectivityTestResultCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectivityTestResultPayload>
          }
          createMany: {
            args: Prisma.ConnectivityTestResultCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConnectivityTestResultCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectivityTestResultPayload>[]
          }
          delete: {
            args: Prisma.ConnectivityTestResultDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectivityTestResultPayload>
          }
          update: {
            args: Prisma.ConnectivityTestResultUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectivityTestResultPayload>
          }
          deleteMany: {
            args: Prisma.ConnectivityTestResultDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConnectivityTestResultUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConnectivityTestResultUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectivityTestResultPayload>[]
          }
          upsert: {
            args: Prisma.ConnectivityTestResultUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectivityTestResultPayload>
          }
          aggregate: {
            args: Prisma.ConnectivityTestResultAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConnectivityTestResult>
          }
          groupBy: {
            args: Prisma.ConnectivityTestResultGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConnectivityTestResultGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConnectivityTestResultCountArgs<ExtArgs>
            result: $Utils.Optional<ConnectivityTestResultCountAggregateOutputType> | number
          }
        }
      }
      DeviceTestResult: {
        payload: Prisma.$DeviceTestResultPayload<ExtArgs>
        fields: Prisma.DeviceTestResultFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeviceTestResultFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTestResultPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeviceTestResultFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTestResultPayload>
          }
          findFirst: {
            args: Prisma.DeviceTestResultFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTestResultPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeviceTestResultFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTestResultPayload>
          }
          findMany: {
            args: Prisma.DeviceTestResultFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTestResultPayload>[]
          }
          create: {
            args: Prisma.DeviceTestResultCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTestResultPayload>
          }
          createMany: {
            args: Prisma.DeviceTestResultCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeviceTestResultCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTestResultPayload>[]
          }
          delete: {
            args: Prisma.DeviceTestResultDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTestResultPayload>
          }
          update: {
            args: Prisma.DeviceTestResultUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTestResultPayload>
          }
          deleteMany: {
            args: Prisma.DeviceTestResultDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeviceTestResultUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DeviceTestResultUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTestResultPayload>[]
          }
          upsert: {
            args: Prisma.DeviceTestResultUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTestResultPayload>
          }
          aggregate: {
            args: Prisma.DeviceTestResultAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeviceTestResult>
          }
          groupBy: {
            args: Prisma.DeviceTestResultGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeviceTestResultGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeviceTestResultCountArgs<ExtArgs>
            result: $Utils.Optional<DeviceTestResultCountAggregateOutputType> | number
          }
        }
      }
      SimTestResult: {
        payload: Prisma.$SimTestResultPayload<ExtArgs>
        fields: Prisma.SimTestResultFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SimTestResultFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimTestResultPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SimTestResultFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimTestResultPayload>
          }
          findFirst: {
            args: Prisma.SimTestResultFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimTestResultPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SimTestResultFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimTestResultPayload>
          }
          findMany: {
            args: Prisma.SimTestResultFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimTestResultPayload>[]
          }
          create: {
            args: Prisma.SimTestResultCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimTestResultPayload>
          }
          createMany: {
            args: Prisma.SimTestResultCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SimTestResultCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimTestResultPayload>[]
          }
          delete: {
            args: Prisma.SimTestResultDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimTestResultPayload>
          }
          update: {
            args: Prisma.SimTestResultUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimTestResultPayload>
          }
          deleteMany: {
            args: Prisma.SimTestResultDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SimTestResultUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SimTestResultUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimTestResultPayload>[]
          }
          upsert: {
            args: Prisma.SimTestResultUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimTestResultPayload>
          }
          aggregate: {
            args: Prisma.SimTestResultAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSimTestResult>
          }
          groupBy: {
            args: Prisma.SimTestResultGroupByArgs<ExtArgs>
            result: $Utils.Optional<SimTestResultGroupByOutputType>[]
          }
          count: {
            args: Prisma.SimTestResultCountArgs<ExtArgs>
            result: $Utils.Optional<SimTestResultCountAggregateOutputType> | number
          }
        }
      }
      ScreenTest: {
        payload: Prisma.$ScreenTestPayload<ExtArgs>
        fields: Prisma.ScreenTestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ScreenTestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenTestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ScreenTestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenTestPayload>
          }
          findFirst: {
            args: Prisma.ScreenTestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenTestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ScreenTestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenTestPayload>
          }
          findMany: {
            args: Prisma.ScreenTestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenTestPayload>[]
          }
          create: {
            args: Prisma.ScreenTestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenTestPayload>
          }
          createMany: {
            args: Prisma.ScreenTestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ScreenTestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenTestPayload>[]
          }
          delete: {
            args: Prisma.ScreenTestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenTestPayload>
          }
          update: {
            args: Prisma.ScreenTestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenTestPayload>
          }
          deleteMany: {
            args: Prisma.ScreenTestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ScreenTestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ScreenTestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenTestPayload>[]
          }
          upsert: {
            args: Prisma.ScreenTestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenTestPayload>
          }
          aggregate: {
            args: Prisma.ScreenTestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateScreenTest>
          }
          groupBy: {
            args: Prisma.ScreenTestGroupByArgs<ExtArgs>
            result: $Utils.Optional<ScreenTestGroupByOutputType>[]
          }
          count: {
            args: Prisma.ScreenTestCountArgs<ExtArgs>
            result: $Utils.Optional<ScreenTestCountAggregateOutputType> | number
          }
        }
      }
      AudioTest: {
        payload: Prisma.$AudioTestPayload<ExtArgs>
        fields: Prisma.AudioTestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AudioTestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioTestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AudioTestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioTestPayload>
          }
          findFirst: {
            args: Prisma.AudioTestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioTestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AudioTestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioTestPayload>
          }
          findMany: {
            args: Prisma.AudioTestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioTestPayload>[]
          }
          create: {
            args: Prisma.AudioTestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioTestPayload>
          }
          createMany: {
            args: Prisma.AudioTestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AudioTestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioTestPayload>[]
          }
          delete: {
            args: Prisma.AudioTestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioTestPayload>
          }
          update: {
            args: Prisma.AudioTestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioTestPayload>
          }
          deleteMany: {
            args: Prisma.AudioTestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AudioTestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AudioTestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioTestPayload>[]
          }
          upsert: {
            args: Prisma.AudioTestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioTestPayload>
          }
          aggregate: {
            args: Prisma.AudioTestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAudioTest>
          }
          groupBy: {
            args: Prisma.AudioTestGroupByArgs<ExtArgs>
            result: $Utils.Optional<AudioTestGroupByOutputType>[]
          }
          count: {
            args: Prisma.AudioTestCountArgs<ExtArgs>
            result: $Utils.Optional<AudioTestCountAggregateOutputType> | number
          }
        }
      }
      ProximitySensorTest: {
        payload: Prisma.$ProximitySensorTestPayload<ExtArgs>
        fields: Prisma.ProximitySensorTestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProximitySensorTestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProximitySensorTestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProximitySensorTestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProximitySensorTestPayload>
          }
          findFirst: {
            args: Prisma.ProximitySensorTestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProximitySensorTestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProximitySensorTestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProximitySensorTestPayload>
          }
          findMany: {
            args: Prisma.ProximitySensorTestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProximitySensorTestPayload>[]
          }
          create: {
            args: Prisma.ProximitySensorTestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProximitySensorTestPayload>
          }
          createMany: {
            args: Prisma.ProximitySensorTestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProximitySensorTestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProximitySensorTestPayload>[]
          }
          delete: {
            args: Prisma.ProximitySensorTestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProximitySensorTestPayload>
          }
          update: {
            args: Prisma.ProximitySensorTestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProximitySensorTestPayload>
          }
          deleteMany: {
            args: Prisma.ProximitySensorTestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProximitySensorTestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProximitySensorTestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProximitySensorTestPayload>[]
          }
          upsert: {
            args: Prisma.ProximitySensorTestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProximitySensorTestPayload>
          }
          aggregate: {
            args: Prisma.ProximitySensorTestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProximitySensorTest>
          }
          groupBy: {
            args: Prisma.ProximitySensorTestGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProximitySensorTestGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProximitySensorTestCountArgs<ExtArgs>
            result: $Utils.Optional<ProximitySensorTestCountAggregateOutputType> | number
          }
        }
      }
      CameraTest: {
        payload: Prisma.$CameraTestPayload<ExtArgs>
        fields: Prisma.CameraTestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CameraTestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CameraTestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CameraTestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CameraTestPayload>
          }
          findFirst: {
            args: Prisma.CameraTestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CameraTestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CameraTestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CameraTestPayload>
          }
          findMany: {
            args: Prisma.CameraTestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CameraTestPayload>[]
          }
          create: {
            args: Prisma.CameraTestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CameraTestPayload>
          }
          createMany: {
            args: Prisma.CameraTestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CameraTestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CameraTestPayload>[]
          }
          delete: {
            args: Prisma.CameraTestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CameraTestPayload>
          }
          update: {
            args: Prisma.CameraTestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CameraTestPayload>
          }
          deleteMany: {
            args: Prisma.CameraTestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CameraTestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CameraTestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CameraTestPayload>[]
          }
          upsert: {
            args: Prisma.CameraTestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CameraTestPayload>
          }
          aggregate: {
            args: Prisma.CameraTestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCameraTest>
          }
          groupBy: {
            args: Prisma.CameraTestGroupByArgs<ExtArgs>
            result: $Utils.Optional<CameraTestGroupByOutputType>[]
          }
          count: {
            args: Prisma.CameraTestCountArgs<ExtArgs>
            result: $Utils.Optional<CameraTestCountAggregateOutputType> | number
          }
        }
      }
      FingerprintTest: {
        payload: Prisma.$FingerprintTestPayload<ExtArgs>
        fields: Prisma.FingerprintTestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FingerprintTestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FingerprintTestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FingerprintTestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FingerprintTestPayload>
          }
          findFirst: {
            args: Prisma.FingerprintTestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FingerprintTestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FingerprintTestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FingerprintTestPayload>
          }
          findMany: {
            args: Prisma.FingerprintTestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FingerprintTestPayload>[]
          }
          create: {
            args: Prisma.FingerprintTestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FingerprintTestPayload>
          }
          createMany: {
            args: Prisma.FingerprintTestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FingerprintTestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FingerprintTestPayload>[]
          }
          delete: {
            args: Prisma.FingerprintTestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FingerprintTestPayload>
          }
          update: {
            args: Prisma.FingerprintTestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FingerprintTestPayload>
          }
          deleteMany: {
            args: Prisma.FingerprintTestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FingerprintTestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FingerprintTestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FingerprintTestPayload>[]
          }
          upsert: {
            args: Prisma.FingerprintTestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FingerprintTestPayload>
          }
          aggregate: {
            args: Prisma.FingerprintTestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFingerprintTest>
          }
          groupBy: {
            args: Prisma.FingerprintTestGroupByArgs<ExtArgs>
            result: $Utils.Optional<FingerprintTestGroupByOutputType>[]
          }
          count: {
            args: Prisma.FingerprintTestCountArgs<ExtArgs>
            result: $Utils.Optional<FingerprintTestCountAggregateOutputType> | number
          }
        }
      }
      UsbTest: {
        payload: Prisma.$UsbTestPayload<ExtArgs>
        fields: Prisma.UsbTestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsbTestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsbTestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsbTestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsbTestPayload>
          }
          findFirst: {
            args: Prisma.UsbTestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsbTestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsbTestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsbTestPayload>
          }
          findMany: {
            args: Prisma.UsbTestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsbTestPayload>[]
          }
          create: {
            args: Prisma.UsbTestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsbTestPayload>
          }
          createMany: {
            args: Prisma.UsbTestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UsbTestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsbTestPayload>[]
          }
          delete: {
            args: Prisma.UsbTestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsbTestPayload>
          }
          update: {
            args: Prisma.UsbTestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsbTestPayload>
          }
          deleteMany: {
            args: Prisma.UsbTestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsbTestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UsbTestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsbTestPayload>[]
          }
          upsert: {
            args: Prisma.UsbTestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsbTestPayload>
          }
          aggregate: {
            args: Prisma.UsbTestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsbTest>
          }
          groupBy: {
            args: Prisma.UsbTestGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsbTestGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsbTestCountArgs<ExtArgs>
            result: $Utils.Optional<UsbTestCountAggregateOutputType> | number
          }
        }
      }
      AudioJackTest: {
        payload: Prisma.$AudioJackTestPayload<ExtArgs>
        fields: Prisma.AudioJackTestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AudioJackTestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioJackTestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AudioJackTestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioJackTestPayload>
          }
          findFirst: {
            args: Prisma.AudioJackTestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioJackTestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AudioJackTestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioJackTestPayload>
          }
          findMany: {
            args: Prisma.AudioJackTestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioJackTestPayload>[]
          }
          create: {
            args: Prisma.AudioJackTestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioJackTestPayload>
          }
          createMany: {
            args: Prisma.AudioJackTestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AudioJackTestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioJackTestPayload>[]
          }
          delete: {
            args: Prisma.AudioJackTestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioJackTestPayload>
          }
          update: {
            args: Prisma.AudioJackTestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioJackTestPayload>
          }
          deleteMany: {
            args: Prisma.AudioJackTestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AudioJackTestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AudioJackTestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioJackTestPayload>[]
          }
          upsert: {
            args: Prisma.AudioJackTestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioJackTestPayload>
          }
          aggregate: {
            args: Prisma.AudioJackTestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAudioJackTest>
          }
          groupBy: {
            args: Prisma.AudioJackTestGroupByArgs<ExtArgs>
            result: $Utils.Optional<AudioJackTestGroupByOutputType>[]
          }
          count: {
            args: Prisma.AudioJackTestCountArgs<ExtArgs>
            result: $Utils.Optional<AudioJackTestCountAggregateOutputType> | number
          }
        }
      }
      ManualDiagnosticsResult: {
        payload: Prisma.$ManualDiagnosticsResultPayload<ExtArgs>
        fields: Prisma.ManualDiagnosticsResultFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ManualDiagnosticsResultFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManualDiagnosticsResultPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ManualDiagnosticsResultFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManualDiagnosticsResultPayload>
          }
          findFirst: {
            args: Prisma.ManualDiagnosticsResultFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManualDiagnosticsResultPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ManualDiagnosticsResultFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManualDiagnosticsResultPayload>
          }
          findMany: {
            args: Prisma.ManualDiagnosticsResultFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManualDiagnosticsResultPayload>[]
          }
          create: {
            args: Prisma.ManualDiagnosticsResultCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManualDiagnosticsResultPayload>
          }
          createMany: {
            args: Prisma.ManualDiagnosticsResultCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ManualDiagnosticsResultCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManualDiagnosticsResultPayload>[]
          }
          delete: {
            args: Prisma.ManualDiagnosticsResultDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManualDiagnosticsResultPayload>
          }
          update: {
            args: Prisma.ManualDiagnosticsResultUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManualDiagnosticsResultPayload>
          }
          deleteMany: {
            args: Prisma.ManualDiagnosticsResultDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ManualDiagnosticsResultUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ManualDiagnosticsResultUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManualDiagnosticsResultPayload>[]
          }
          upsert: {
            args: Prisma.ManualDiagnosticsResultUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManualDiagnosticsResultPayload>
          }
          aggregate: {
            args: Prisma.ManualDiagnosticsResultAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateManualDiagnosticsResult>
          }
          groupBy: {
            args: Prisma.ManualDiagnosticsResultGroupByArgs<ExtArgs>
            result: $Utils.Optional<ManualDiagnosticsResultGroupByOutputType>[]
          }
          count: {
            args: Prisma.ManualDiagnosticsResultCountArgs<ExtArgs>
            result: $Utils.Optional<ManualDiagnosticsResultCountAggregateOutputType> | number
          }
        }
      }
      Declaration: {
        payload: Prisma.$DeclarationPayload<ExtArgs>
        fields: Prisma.DeclarationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeclarationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeclarationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeclarationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeclarationPayload>
          }
          findFirst: {
            args: Prisma.DeclarationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeclarationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeclarationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeclarationPayload>
          }
          findMany: {
            args: Prisma.DeclarationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeclarationPayload>[]
          }
          create: {
            args: Prisma.DeclarationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeclarationPayload>
          }
          createMany: {
            args: Prisma.DeclarationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeclarationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeclarationPayload>[]
          }
          delete: {
            args: Prisma.DeclarationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeclarationPayload>
          }
          update: {
            args: Prisma.DeclarationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeclarationPayload>
          }
          deleteMany: {
            args: Prisma.DeclarationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeclarationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DeclarationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeclarationPayload>[]
          }
          upsert: {
            args: Prisma.DeclarationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeclarationPayload>
          }
          aggregate: {
            args: Prisma.DeclarationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeclaration>
          }
          groupBy: {
            args: Prisma.DeclarationGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeclarationGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeclarationCountArgs<ExtArgs>
            result: $Utils.Optional<DeclarationCountAggregateOutputType> | number
          }
        }
      }
      Address: {
        payload: Prisma.$AddressPayload<ExtArgs>
        fields: Prisma.AddressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AddressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AddressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          findFirst: {
            args: Prisma.AddressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AddressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          findMany: {
            args: Prisma.AddressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>[]
          }
          create: {
            args: Prisma.AddressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          createMany: {
            args: Prisma.AddressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AddressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>[]
          }
          delete: {
            args: Prisma.AddressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          update: {
            args: Prisma.AddressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          deleteMany: {
            args: Prisma.AddressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AddressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AddressUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>[]
          }
          upsert: {
            args: Prisma.AddressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          aggregate: {
            args: Prisma.AddressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAddress>
          }
          groupBy: {
            args: Prisma.AddressGroupByArgs<ExtArgs>
            result: $Utils.Optional<AddressGroupByOutputType>[]
          }
          count: {
            args: Prisma.AddressCountArgs<ExtArgs>
            result: $Utils.Optional<AddressCountAggregateOutputType> | number
          }
        }
      }
      Otp: {
        payload: Prisma.$OtpPayload<ExtArgs>
        fields: Prisma.OtpFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OtpFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OtpFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>
          }
          findFirst: {
            args: Prisma.OtpFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OtpFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>
          }
          findMany: {
            args: Prisma.OtpFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>[]
          }
          create: {
            args: Prisma.OtpCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>
          }
          createMany: {
            args: Prisma.OtpCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OtpCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>[]
          }
          delete: {
            args: Prisma.OtpDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>
          }
          update: {
            args: Prisma.OtpUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>
          }
          deleteMany: {
            args: Prisma.OtpDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OtpUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OtpUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>[]
          }
          upsert: {
            args: Prisma.OtpUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>
          }
          aggregate: {
            args: Prisma.OtpAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOtp>
          }
          groupBy: {
            args: Prisma.OtpGroupByArgs<ExtArgs>
            result: $Utils.Optional<OtpGroupByOutputType>[]
          }
          count: {
            args: Prisma.OtpCountArgs<ExtArgs>
            result: $Utils.Optional<OtpCountAggregateOutputType> | number
          }
        }
      }
      CustomModelBrand: {
        payload: Prisma.$CustomModelBrandPayload<ExtArgs>
        fields: Prisma.CustomModelBrandFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomModelBrandFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomModelBrandPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomModelBrandFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomModelBrandPayload>
          }
          findFirst: {
            args: Prisma.CustomModelBrandFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomModelBrandPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomModelBrandFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomModelBrandPayload>
          }
          findMany: {
            args: Prisma.CustomModelBrandFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomModelBrandPayload>[]
          }
          create: {
            args: Prisma.CustomModelBrandCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomModelBrandPayload>
          }
          createMany: {
            args: Prisma.CustomModelBrandCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomModelBrandCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomModelBrandPayload>[]
          }
          delete: {
            args: Prisma.CustomModelBrandDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomModelBrandPayload>
          }
          update: {
            args: Prisma.CustomModelBrandUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomModelBrandPayload>
          }
          deleteMany: {
            args: Prisma.CustomModelBrandDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomModelBrandUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomModelBrandUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomModelBrandPayload>[]
          }
          upsert: {
            args: Prisma.CustomModelBrandUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomModelBrandPayload>
          }
          aggregate: {
            args: Prisma.CustomModelBrandAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomModelBrand>
          }
          groupBy: {
            args: Prisma.CustomModelBrandGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomModelBrandGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomModelBrandCountArgs<ExtArgs>
            result: $Utils.Optional<CustomModelBrandCountAggregateOutputType> | number
          }
        }
      }
      CustomModel: {
        payload: Prisma.$CustomModelPayload<ExtArgs>
        fields: Prisma.CustomModelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomModelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomModelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomModelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomModelPayload>
          }
          findFirst: {
            args: Prisma.CustomModelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomModelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomModelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomModelPayload>
          }
          findMany: {
            args: Prisma.CustomModelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomModelPayload>[]
          }
          create: {
            args: Prisma.CustomModelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomModelPayload>
          }
          createMany: {
            args: Prisma.CustomModelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomModelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomModelPayload>[]
          }
          delete: {
            args: Prisma.CustomModelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomModelPayload>
          }
          update: {
            args: Prisma.CustomModelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomModelPayload>
          }
          deleteMany: {
            args: Prisma.CustomModelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomModelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomModelUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomModelPayload>[]
          }
          upsert: {
            args: Prisma.CustomModelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomModelPayload>
          }
          aggregate: {
            args: Prisma.CustomModelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomModel>
          }
          groupBy: {
            args: Prisma.CustomModelGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomModelGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomModelCountArgs<ExtArgs>
            result: $Utils.Optional<CustomModelCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    admin?: AdminOmit
    manager?: ManagerOmit
    technician?: TechnicianOmit
    fieldExecutive?: FieldExecutiveOmit
    salesExecutive?: SalesExecutiveOmit
    store?: StoreOmit
    bankDetails?: BankDetailsOmit
    session?: SessionOmit
    notification?: NotificationOmit
    deviceTest?: DeviceTestOmit
    connectivityTestResult?: ConnectivityTestResultOmit
    deviceTestResult?: DeviceTestResultOmit
    simTestResult?: SimTestResultOmit
    screenTest?: ScreenTestOmit
    audioTest?: AudioTestOmit
    proximitySensorTest?: ProximitySensorTestOmit
    cameraTest?: CameraTestOmit
    fingerprintTest?: FingerprintTestOmit
    usbTest?: UsbTestOmit
    audioJackTest?: AudioJackTestOmit
    manualDiagnosticsResult?: ManualDiagnosticsResultOmit
    declaration?: DeclarationOmit
    address?: AddressOmit
    otp?: OtpOmit
    customModelBrand?: CustomModelBrandOmit
    customModel?: CustomModelOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    sessions: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }


  /**
   * Count Type DeviceTestCountOutputType
   */

  export type DeviceTestCountOutputType = {
    connectivityTestResults: number
    simTestResults: number
    deviceTestResults: number
  }

  export type DeviceTestCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    connectivityTestResults?: boolean | DeviceTestCountOutputTypeCountConnectivityTestResultsArgs
    simTestResults?: boolean | DeviceTestCountOutputTypeCountSimTestResultsArgs
    deviceTestResults?: boolean | DeviceTestCountOutputTypeCountDeviceTestResultsArgs
  }

  // Custom InputTypes
  /**
   * DeviceTestCountOutputType without action
   */
  export type DeviceTestCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceTestCountOutputType
     */
    select?: DeviceTestCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DeviceTestCountOutputType without action
   */
  export type DeviceTestCountOutputTypeCountConnectivityTestResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConnectivityTestResultWhereInput
  }

  /**
   * DeviceTestCountOutputType without action
   */
  export type DeviceTestCountOutputTypeCountSimTestResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SimTestResultWhereInput
  }

  /**
   * DeviceTestCountOutputType without action
   */
  export type DeviceTestCountOutputTypeCountDeviceTestResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceTestResultWhereInput
  }


  /**
   * Count Type CustomModelBrandCountOutputType
   */

  export type CustomModelBrandCountOutputType = {
    models: number
  }

  export type CustomModelBrandCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    models?: boolean | CustomModelBrandCountOutputTypeCountModelsArgs
  }

  // Custom InputTypes
  /**
   * CustomModelBrandCountOutputType without action
   */
  export type CustomModelBrandCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomModelBrandCountOutputType
     */
    select?: CustomModelBrandCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomModelBrandCountOutputType without action
   */
  export type CustomModelBrandCountOutputTypeCountModelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomModelWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    salary: Decimal | null
    payoutDate: number | null
  }

  export type UserSumAggregateOutputType = {
    salary: Decimal | null
    payoutDate: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    phone: string | null
    phoneVerified: boolean | null
    salary: Decimal | null
    payoutDate: number | null
    password: string | null
    email: string | null
    dateOfJoining: Date | null
    dateOfTermination: Date | null
    profileImage: string | null
    aadharFrontImage: string | null
    aadharBackImage: string | null
    qualificationImage: string | null
    VehicleFrontImage: string | null
    VehicleBackImage: string | null
    role: $Enums.Role | null
    storeId: string | null
    mfaEnabled: boolean | null
    mfaSecret: string | null
    mfaVerified: boolean | null
    createdBy: string | null
    isAdmin: boolean | null
    status: $Enums.UserStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    phone: string | null
    phoneVerified: boolean | null
    salary: Decimal | null
    payoutDate: number | null
    password: string | null
    email: string | null
    dateOfJoining: Date | null
    dateOfTermination: Date | null
    profileImage: string | null
    aadharFrontImage: string | null
    aadharBackImage: string | null
    qualificationImage: string | null
    VehicleFrontImage: string | null
    VehicleBackImage: string | null
    role: $Enums.Role | null
    storeId: string | null
    mfaEnabled: boolean | null
    mfaSecret: string | null
    mfaVerified: boolean | null
    createdBy: string | null
    isAdmin: boolean | null
    status: $Enums.UserStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    phone: number
    phoneVerified: number
    salary: number
    payoutDate: number
    password: number
    email: number
    dateOfJoining: number
    dateOfTermination: number
    profileImage: number
    aadharFrontImage: number
    aadharBackImage: number
    qualificationImage: number
    VehicleFrontImage: number
    VehicleBackImage: number
    role: number
    storeId: number
    mfaEnabled: number
    mfaSecret: number
    mfaVerified: number
    createdBy: number
    isAdmin: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    salary?: true
    payoutDate?: true
  }

  export type UserSumAggregateInputType = {
    salary?: true
    payoutDate?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    phone?: true
    phoneVerified?: true
    salary?: true
    payoutDate?: true
    password?: true
    email?: true
    dateOfJoining?: true
    dateOfTermination?: true
    profileImage?: true
    aadharFrontImage?: true
    aadharBackImage?: true
    qualificationImage?: true
    VehicleFrontImage?: true
    VehicleBackImage?: true
    role?: true
    storeId?: true
    mfaEnabled?: true
    mfaSecret?: true
    mfaVerified?: true
    createdBy?: true
    isAdmin?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    phone?: true
    phoneVerified?: true
    salary?: true
    payoutDate?: true
    password?: true
    email?: true
    dateOfJoining?: true
    dateOfTermination?: true
    profileImage?: true
    aadharFrontImage?: true
    aadharBackImage?: true
    qualificationImage?: true
    VehicleFrontImage?: true
    VehicleBackImage?: true
    role?: true
    storeId?: true
    mfaEnabled?: true
    mfaSecret?: true
    mfaVerified?: true
    createdBy?: true
    isAdmin?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    phone?: true
    phoneVerified?: true
    salary?: true
    payoutDate?: true
    password?: true
    email?: true
    dateOfJoining?: true
    dateOfTermination?: true
    profileImage?: true
    aadharFrontImage?: true
    aadharBackImage?: true
    qualificationImage?: true
    VehicleFrontImage?: true
    VehicleBackImage?: true
    role?: true
    storeId?: true
    mfaEnabled?: true
    mfaSecret?: true
    mfaVerified?: true
    createdBy?: true
    isAdmin?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    phone: string
    phoneVerified: boolean | null
    salary: Decimal | null
    payoutDate: number | null
    password: string
    email: string | null
    dateOfJoining: Date | null
    dateOfTermination: Date | null
    profileImage: string | null
    aadharFrontImage: string | null
    aadharBackImage: string | null
    qualificationImage: string | null
    VehicleFrontImage: string | null
    VehicleBackImage: string | null
    role: $Enums.Role | null
    storeId: string | null
    mfaEnabled: boolean
    mfaSecret: string | null
    mfaVerified: boolean
    createdBy: string | null
    isAdmin: boolean
    status: $Enums.UserStatus
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    phone?: boolean
    phoneVerified?: boolean
    salary?: boolean
    payoutDate?: boolean
    password?: boolean
    email?: boolean
    dateOfJoining?: boolean
    dateOfTermination?: boolean
    profileImage?: boolean
    aadharFrontImage?: boolean
    aadharBackImage?: boolean
    qualificationImage?: boolean
    VehicleFrontImage?: boolean
    VehicleBackImage?: boolean
    role?: boolean
    storeId?: boolean
    mfaEnabled?: boolean
    mfaSecret?: boolean
    mfaVerified?: boolean
    createdBy?: boolean
    isAdmin?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    manager?: boolean | User$managerArgs<ExtArgs>
    technician?: boolean | User$technicianArgs<ExtArgs>
    fieldExecutive?: boolean | User$fieldExecutiveArgs<ExtArgs>
    salesExecutive?: boolean | User$salesExecutiveArgs<ExtArgs>
    store?: boolean | User$storeArgs<ExtArgs>
    admin?: boolean | User$adminArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    phone?: boolean
    phoneVerified?: boolean
    salary?: boolean
    payoutDate?: boolean
    password?: boolean
    email?: boolean
    dateOfJoining?: boolean
    dateOfTermination?: boolean
    profileImage?: boolean
    aadharFrontImage?: boolean
    aadharBackImage?: boolean
    qualificationImage?: boolean
    VehicleFrontImage?: boolean
    VehicleBackImage?: boolean
    role?: boolean
    storeId?: boolean
    mfaEnabled?: boolean
    mfaSecret?: boolean
    mfaVerified?: boolean
    createdBy?: boolean
    isAdmin?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    phone?: boolean
    phoneVerified?: boolean
    salary?: boolean
    payoutDate?: boolean
    password?: boolean
    email?: boolean
    dateOfJoining?: boolean
    dateOfTermination?: boolean
    profileImage?: boolean
    aadharFrontImage?: boolean
    aadharBackImage?: boolean
    qualificationImage?: boolean
    VehicleFrontImage?: boolean
    VehicleBackImage?: boolean
    role?: boolean
    storeId?: boolean
    mfaEnabled?: boolean
    mfaSecret?: boolean
    mfaVerified?: boolean
    createdBy?: boolean
    isAdmin?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    phone?: boolean
    phoneVerified?: boolean
    salary?: boolean
    payoutDate?: boolean
    password?: boolean
    email?: boolean
    dateOfJoining?: boolean
    dateOfTermination?: boolean
    profileImage?: boolean
    aadharFrontImage?: boolean
    aadharBackImage?: boolean
    qualificationImage?: boolean
    VehicleFrontImage?: boolean
    VehicleBackImage?: boolean
    role?: boolean
    storeId?: boolean
    mfaEnabled?: boolean
    mfaSecret?: boolean
    mfaVerified?: boolean
    createdBy?: boolean
    isAdmin?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "phone" | "phoneVerified" | "salary" | "payoutDate" | "password" | "email" | "dateOfJoining" | "dateOfTermination" | "profileImage" | "aadharFrontImage" | "aadharBackImage" | "qualificationImage" | "VehicleFrontImage" | "VehicleBackImage" | "role" | "storeId" | "mfaEnabled" | "mfaSecret" | "mfaVerified" | "createdBy" | "isAdmin" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    manager?: boolean | User$managerArgs<ExtArgs>
    technician?: boolean | User$technicianArgs<ExtArgs>
    fieldExecutive?: boolean | User$fieldExecutiveArgs<ExtArgs>
    salesExecutive?: boolean | User$salesExecutiveArgs<ExtArgs>
    store?: boolean | User$storeArgs<ExtArgs>
    admin?: boolean | User$adminArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      manager: Prisma.$ManagerPayload<ExtArgs> | null
      technician: Prisma.$TechnicianPayload<ExtArgs> | null
      fieldExecutive: Prisma.$FieldExecutivePayload<ExtArgs> | null
      salesExecutive: Prisma.$SalesExecutivePayload<ExtArgs> | null
      store: Prisma.$StorePayload<ExtArgs> | null
      admin: Prisma.$AdminPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      phone: string
      phoneVerified: boolean | null
      salary: Prisma.Decimal | null
      payoutDate: number | null
      password: string
      email: string | null
      dateOfJoining: Date | null
      dateOfTermination: Date | null
      profileImage: string | null
      aadharFrontImage: string | null
      aadharBackImage: string | null
      qualificationImage: string | null
      VehicleFrontImage: string | null
      VehicleBackImage: string | null
      role: $Enums.Role | null
      storeId: string | null
      mfaEnabled: boolean
      mfaSecret: string | null
      mfaVerified: boolean
      createdBy: string | null
      isAdmin: boolean
      status: $Enums.UserStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    manager<T extends User$managerArgs<ExtArgs> = {}>(args?: Subset<T, User$managerArgs<ExtArgs>>): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    technician<T extends User$technicianArgs<ExtArgs> = {}>(args?: Subset<T, User$technicianArgs<ExtArgs>>): Prisma__TechnicianClient<$Result.GetResult<Prisma.$TechnicianPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    fieldExecutive<T extends User$fieldExecutiveArgs<ExtArgs> = {}>(args?: Subset<T, User$fieldExecutiveArgs<ExtArgs>>): Prisma__FieldExecutiveClient<$Result.GetResult<Prisma.$FieldExecutivePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    salesExecutive<T extends User$salesExecutiveArgs<ExtArgs> = {}>(args?: Subset<T, User$salesExecutiveArgs<ExtArgs>>): Prisma__SalesExecutiveClient<$Result.GetResult<Prisma.$SalesExecutivePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    store<T extends User$storeArgs<ExtArgs> = {}>(args?: Subset<T, User$storeArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    admin<T extends User$adminArgs<ExtArgs> = {}>(args?: Subset<T, User$adminArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly phoneVerified: FieldRef<"User", 'Boolean'>
    readonly salary: FieldRef<"User", 'Decimal'>
    readonly payoutDate: FieldRef<"User", 'Int'>
    readonly password: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly dateOfJoining: FieldRef<"User", 'DateTime'>
    readonly dateOfTermination: FieldRef<"User", 'DateTime'>
    readonly profileImage: FieldRef<"User", 'String'>
    readonly aadharFrontImage: FieldRef<"User", 'String'>
    readonly aadharBackImage: FieldRef<"User", 'String'>
    readonly qualificationImage: FieldRef<"User", 'String'>
    readonly VehicleFrontImage: FieldRef<"User", 'String'>
    readonly VehicleBackImage: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly storeId: FieldRef<"User", 'String'>
    readonly mfaEnabled: FieldRef<"User", 'Boolean'>
    readonly mfaSecret: FieldRef<"User", 'String'>
    readonly mfaVerified: FieldRef<"User", 'Boolean'>
    readonly createdBy: FieldRef<"User", 'String'>
    readonly isAdmin: FieldRef<"User", 'Boolean'>
    readonly status: FieldRef<"User", 'UserStatus'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.manager
   */
  export type User$managerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manager
     */
    omit?: ManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
    where?: ManagerWhereInput
  }

  /**
   * User.technician
   */
  export type User$technicianArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Technician
     */
    select?: TechnicianSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Technician
     */
    omit?: TechnicianOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicianInclude<ExtArgs> | null
    where?: TechnicianWhereInput
  }

  /**
   * User.fieldExecutive
   */
  export type User$fieldExecutiveArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldExecutive
     */
    select?: FieldExecutiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldExecutive
     */
    omit?: FieldExecutiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldExecutiveInclude<ExtArgs> | null
    where?: FieldExecutiveWhereInput
  }

  /**
   * User.salesExecutive
   */
  export type User$salesExecutiveArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesExecutive
     */
    select?: SalesExecutiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesExecutive
     */
    omit?: SalesExecutiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesExecutiveInclude<ExtArgs> | null
    where?: SalesExecutiveWhereInput
  }

  /**
   * User.store
   */
  export type User$storeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    where?: StoreWhereInput
  }

  /**
   * User.admin
   */
  export type User$adminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    where?: AdminWhereInput
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Admin
   */

  export type AggregateAdmin = {
    _count: AdminCountAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  export type AdminMinAggregateOutputType = {
    userId: string | null
    employeeId: string | null
    firstName: string | null
    lastName: string | null
  }

  export type AdminMaxAggregateOutputType = {
    userId: string | null
    employeeId: string | null
    firstName: string | null
    lastName: string | null
  }

  export type AdminCountAggregateOutputType = {
    userId: number
    employeeId: number
    firstName: number
    lastName: number
    _all: number
  }


  export type AdminMinAggregateInputType = {
    userId?: true
    employeeId?: true
    firstName?: true
    lastName?: true
  }

  export type AdminMaxAggregateInputType = {
    userId?: true
    employeeId?: true
    firstName?: true
    lastName?: true
  }

  export type AdminCountAggregateInputType = {
    userId?: true
    employeeId?: true
    firstName?: true
    lastName?: true
    _all?: true
  }

  export type AdminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admin to aggregate.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Admins
    **/
    _count?: true | AdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminMaxAggregateInputType
  }

  export type GetAdminAggregateType<T extends AdminAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmin[P]>
      : GetScalarType<T[P], AggregateAdmin[P]>
  }




  export type AdminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminWhereInput
    orderBy?: AdminOrderByWithAggregationInput | AdminOrderByWithAggregationInput[]
    by: AdminScalarFieldEnum[] | AdminScalarFieldEnum
    having?: AdminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminCountAggregateInputType | true
    _min?: AdminMinAggregateInputType
    _max?: AdminMaxAggregateInputType
  }

  export type AdminGroupByOutputType = {
    userId: string
    employeeId: string
    firstName: string | null
    lastName: string | null
    _count: AdminCountAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  type GetAdminGroupByPayload<T extends AdminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminGroupByOutputType[P]>
            : GetScalarType<T[P], AdminGroupByOutputType[P]>
        }
      >
    >


  export type AdminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    employeeId?: boolean
    firstName?: boolean
    lastName?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    employeeId?: boolean
    firstName?: boolean
    lastName?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    employeeId?: boolean
    firstName?: boolean
    lastName?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectScalar = {
    userId?: boolean
    employeeId?: boolean
    firstName?: boolean
    lastName?: boolean
  }

  export type AdminOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "employeeId" | "firstName" | "lastName", ExtArgs["result"]["admin"]>
  export type AdminInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AdminIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AdminIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AdminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Admin"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      employeeId: string
      firstName: string | null
      lastName: string | null
    }, ExtArgs["result"]["admin"]>
    composites: {}
  }

  type AdminGetPayload<S extends boolean | null | undefined | AdminDefaultArgs> = $Result.GetResult<Prisma.$AdminPayload, S>

  type AdminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdminFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminCountAggregateInputType | true
    }

  export interface AdminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Admin'], meta: { name: 'Admin' } }
    /**
     * Find zero or one Admin that matches the filter.
     * @param {AdminFindUniqueArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminFindUniqueArgs>(args: SelectSubset<T, AdminFindUniqueArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Admin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminFindUniqueOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminFindFirstArgs>(args?: SelectSubset<T, AdminFindFirstArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admins
     * const admins = await prisma.admin.findMany()
     * 
     * // Get first 10 Admins
     * const admins = await prisma.admin.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const adminWithUserIdOnly = await prisma.admin.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends AdminFindManyArgs>(args?: SelectSubset<T, AdminFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Admin.
     * @param {AdminCreateArgs} args - Arguments to create a Admin.
     * @example
     * // Create one Admin
     * const Admin = await prisma.admin.create({
     *   data: {
     *     // ... data to create a Admin
     *   }
     * })
     * 
     */
    create<T extends AdminCreateArgs>(args: SelectSubset<T, AdminCreateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Admins.
     * @param {AdminCreateManyArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminCreateManyArgs>(args?: SelectSubset<T, AdminCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Admins and returns the data saved in the database.
     * @param {AdminCreateManyAndReturnArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Admins and only return the `userId`
     * const adminWithUserIdOnly = await prisma.admin.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Admin.
     * @param {AdminDeleteArgs} args - Arguments to delete one Admin.
     * @example
     * // Delete one Admin
     * const Admin = await prisma.admin.delete({
     *   where: {
     *     // ... filter to delete one Admin
     *   }
     * })
     * 
     */
    delete<T extends AdminDeleteArgs>(args: SelectSubset<T, AdminDeleteArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Admin.
     * @param {AdminUpdateArgs} args - Arguments to update one Admin.
     * @example
     * // Update one Admin
     * const admin = await prisma.admin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminUpdateArgs>(args: SelectSubset<T, AdminUpdateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Admins.
     * @param {AdminDeleteManyArgs} args - Arguments to filter Admins to delete.
     * @example
     * // Delete a few Admins
     * const { count } = await prisma.admin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminDeleteManyArgs>(args?: SelectSubset<T, AdminDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminUpdateManyArgs>(args: SelectSubset<T, AdminUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins and returns the data updated in the database.
     * @param {AdminUpdateManyAndReturnArgs} args - Arguments to update many Admins.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Admins and only return the `userId`
     * const adminWithUserIdOnly = await prisma.admin.updateManyAndReturn({
     *   select: { userId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdminUpdateManyAndReturnArgs>(args: SelectSubset<T, AdminUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Admin.
     * @param {AdminUpsertArgs} args - Arguments to update or create a Admin.
     * @example
     * // Update or create a Admin
     * const admin = await prisma.admin.upsert({
     *   create: {
     *     // ... data to create a Admin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admin we want to update
     *   }
     * })
     */
    upsert<T extends AdminUpsertArgs>(args: SelectSubset<T, AdminUpsertArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminCountArgs} args - Arguments to filter Admins to count.
     * @example
     * // Count the number of Admins
     * const count = await prisma.admin.count({
     *   where: {
     *     // ... the filter for the Admins we want to count
     *   }
     * })
    **/
    count<T extends AdminCountArgs>(
      args?: Subset<T, AdminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminAggregateArgs>(args: Subset<T, AdminAggregateArgs>): Prisma.PrismaPromise<GetAdminAggregateType<T>>

    /**
     * Group by Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminGroupByArgs['orderBy'] }
        : { orderBy?: AdminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Admin model
   */
  readonly fields: AdminFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Admin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Admin model
   */
  interface AdminFieldRefs {
    readonly userId: FieldRef<"Admin", 'String'>
    readonly employeeId: FieldRef<"Admin", 'String'>
    readonly firstName: FieldRef<"Admin", 'String'>
    readonly lastName: FieldRef<"Admin", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Admin findUnique
   */
  export type AdminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findUniqueOrThrow
   */
  export type AdminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findFirst
   */
  export type AdminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findFirstOrThrow
   */
  export type AdminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findMany
   */
  export type AdminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admins to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin create
   */
  export type AdminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The data needed to create a Admin.
     */
    data: XOR<AdminCreateInput, AdminUncheckedCreateInput>
  }

  /**
   * Admin createMany
   */
  export type AdminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Admin createManyAndReturn
   */
  export type AdminCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Admin update
   */
  export type AdminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The data needed to update a Admin.
     */
    data: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
    /**
     * Choose, which Admin to update.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin updateMany
   */
  export type AdminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to update.
     */
    limit?: number
  }

  /**
   * Admin updateManyAndReturn
   */
  export type AdminUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Admin upsert
   */
  export type AdminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The filter to search for the Admin to update in case it exists.
     */
    where: AdminWhereUniqueInput
    /**
     * In case the Admin found by the `where` argument doesn't exist, create a new Admin with this data.
     */
    create: XOR<AdminCreateInput, AdminUncheckedCreateInput>
    /**
     * In case the Admin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
  }

  /**
   * Admin delete
   */
  export type AdminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter which Admin to delete.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin deleteMany
   */
  export type AdminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admins to delete
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to delete.
     */
    limit?: number
  }

  /**
   * Admin without action
   */
  export type AdminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
  }


  /**
   * Model Manager
   */

  export type AggregateManager = {
    _count: ManagerCountAggregateOutputType | null
    _min: ManagerMinAggregateOutputType | null
    _max: ManagerMaxAggregateOutputType | null
  }

  export type ManagerMinAggregateOutputType = {
    userId: string | null
    firstName: string | null
    lastName: string | null
    employeeId: string | null
    aadharId: string | null
  }

  export type ManagerMaxAggregateOutputType = {
    userId: string | null
    firstName: string | null
    lastName: string | null
    employeeId: string | null
    aadharId: string | null
  }

  export type ManagerCountAggregateOutputType = {
    userId: number
    firstName: number
    lastName: number
    employeeId: number
    aadharId: number
    _all: number
  }


  export type ManagerMinAggregateInputType = {
    userId?: true
    firstName?: true
    lastName?: true
    employeeId?: true
    aadharId?: true
  }

  export type ManagerMaxAggregateInputType = {
    userId?: true
    firstName?: true
    lastName?: true
    employeeId?: true
    aadharId?: true
  }

  export type ManagerCountAggregateInputType = {
    userId?: true
    firstName?: true
    lastName?: true
    employeeId?: true
    aadharId?: true
    _all?: true
  }

  export type ManagerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Manager to aggregate.
     */
    where?: ManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Managers to fetch.
     */
    orderBy?: ManagerOrderByWithRelationInput | ManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Managers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Managers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Managers
    **/
    _count?: true | ManagerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ManagerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ManagerMaxAggregateInputType
  }

  export type GetManagerAggregateType<T extends ManagerAggregateArgs> = {
        [P in keyof T & keyof AggregateManager]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateManager[P]>
      : GetScalarType<T[P], AggregateManager[P]>
  }




  export type ManagerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ManagerWhereInput
    orderBy?: ManagerOrderByWithAggregationInput | ManagerOrderByWithAggregationInput[]
    by: ManagerScalarFieldEnum[] | ManagerScalarFieldEnum
    having?: ManagerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ManagerCountAggregateInputType | true
    _min?: ManagerMinAggregateInputType
    _max?: ManagerMaxAggregateInputType
  }

  export type ManagerGroupByOutputType = {
    userId: string
    firstName: string
    lastName: string
    employeeId: string
    aadharId: string
    _count: ManagerCountAggregateOutputType | null
    _min: ManagerMinAggregateOutputType | null
    _max: ManagerMaxAggregateOutputType | null
  }

  type GetManagerGroupByPayload<T extends ManagerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ManagerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ManagerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ManagerGroupByOutputType[P]>
            : GetScalarType<T[P], ManagerGroupByOutputType[P]>
        }
      >
    >


  export type ManagerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    employeeId?: boolean
    aadharId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    bankDetails?: boolean | Manager$bankDetailsArgs<ExtArgs>
  }, ExtArgs["result"]["manager"]>

  export type ManagerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    employeeId?: boolean
    aadharId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["manager"]>

  export type ManagerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    employeeId?: boolean
    aadharId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["manager"]>

  export type ManagerSelectScalar = {
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    employeeId?: boolean
    aadharId?: boolean
  }

  export type ManagerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "firstName" | "lastName" | "employeeId" | "aadharId", ExtArgs["result"]["manager"]>
  export type ManagerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    bankDetails?: boolean | Manager$bankDetailsArgs<ExtArgs>
  }
  export type ManagerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ManagerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ManagerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Manager"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      bankDetails: Prisma.$BankDetailsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      firstName: string
      lastName: string
      employeeId: string
      aadharId: string
    }, ExtArgs["result"]["manager"]>
    composites: {}
  }

  type ManagerGetPayload<S extends boolean | null | undefined | ManagerDefaultArgs> = $Result.GetResult<Prisma.$ManagerPayload, S>

  type ManagerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ManagerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ManagerCountAggregateInputType | true
    }

  export interface ManagerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Manager'], meta: { name: 'Manager' } }
    /**
     * Find zero or one Manager that matches the filter.
     * @param {ManagerFindUniqueArgs} args - Arguments to find a Manager
     * @example
     * // Get one Manager
     * const manager = await prisma.manager.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ManagerFindUniqueArgs>(args: SelectSubset<T, ManagerFindUniqueArgs<ExtArgs>>): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Manager that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ManagerFindUniqueOrThrowArgs} args - Arguments to find a Manager
     * @example
     * // Get one Manager
     * const manager = await prisma.manager.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ManagerFindUniqueOrThrowArgs>(args: SelectSubset<T, ManagerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Manager that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagerFindFirstArgs} args - Arguments to find a Manager
     * @example
     * // Get one Manager
     * const manager = await prisma.manager.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ManagerFindFirstArgs>(args?: SelectSubset<T, ManagerFindFirstArgs<ExtArgs>>): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Manager that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagerFindFirstOrThrowArgs} args - Arguments to find a Manager
     * @example
     * // Get one Manager
     * const manager = await prisma.manager.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ManagerFindFirstOrThrowArgs>(args?: SelectSubset<T, ManagerFindFirstOrThrowArgs<ExtArgs>>): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Managers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Managers
     * const managers = await prisma.manager.findMany()
     * 
     * // Get first 10 Managers
     * const managers = await prisma.manager.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const managerWithUserIdOnly = await prisma.manager.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends ManagerFindManyArgs>(args?: SelectSubset<T, ManagerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Manager.
     * @param {ManagerCreateArgs} args - Arguments to create a Manager.
     * @example
     * // Create one Manager
     * const Manager = await prisma.manager.create({
     *   data: {
     *     // ... data to create a Manager
     *   }
     * })
     * 
     */
    create<T extends ManagerCreateArgs>(args: SelectSubset<T, ManagerCreateArgs<ExtArgs>>): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Managers.
     * @param {ManagerCreateManyArgs} args - Arguments to create many Managers.
     * @example
     * // Create many Managers
     * const manager = await prisma.manager.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ManagerCreateManyArgs>(args?: SelectSubset<T, ManagerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Managers and returns the data saved in the database.
     * @param {ManagerCreateManyAndReturnArgs} args - Arguments to create many Managers.
     * @example
     * // Create many Managers
     * const manager = await prisma.manager.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Managers and only return the `userId`
     * const managerWithUserIdOnly = await prisma.manager.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ManagerCreateManyAndReturnArgs>(args?: SelectSubset<T, ManagerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Manager.
     * @param {ManagerDeleteArgs} args - Arguments to delete one Manager.
     * @example
     * // Delete one Manager
     * const Manager = await prisma.manager.delete({
     *   where: {
     *     // ... filter to delete one Manager
     *   }
     * })
     * 
     */
    delete<T extends ManagerDeleteArgs>(args: SelectSubset<T, ManagerDeleteArgs<ExtArgs>>): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Manager.
     * @param {ManagerUpdateArgs} args - Arguments to update one Manager.
     * @example
     * // Update one Manager
     * const manager = await prisma.manager.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ManagerUpdateArgs>(args: SelectSubset<T, ManagerUpdateArgs<ExtArgs>>): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Managers.
     * @param {ManagerDeleteManyArgs} args - Arguments to filter Managers to delete.
     * @example
     * // Delete a few Managers
     * const { count } = await prisma.manager.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ManagerDeleteManyArgs>(args?: SelectSubset<T, ManagerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Managers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Managers
     * const manager = await prisma.manager.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ManagerUpdateManyArgs>(args: SelectSubset<T, ManagerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Managers and returns the data updated in the database.
     * @param {ManagerUpdateManyAndReturnArgs} args - Arguments to update many Managers.
     * @example
     * // Update many Managers
     * const manager = await prisma.manager.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Managers and only return the `userId`
     * const managerWithUserIdOnly = await prisma.manager.updateManyAndReturn({
     *   select: { userId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ManagerUpdateManyAndReturnArgs>(args: SelectSubset<T, ManagerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Manager.
     * @param {ManagerUpsertArgs} args - Arguments to update or create a Manager.
     * @example
     * // Update or create a Manager
     * const manager = await prisma.manager.upsert({
     *   create: {
     *     // ... data to create a Manager
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Manager we want to update
     *   }
     * })
     */
    upsert<T extends ManagerUpsertArgs>(args: SelectSubset<T, ManagerUpsertArgs<ExtArgs>>): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Managers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagerCountArgs} args - Arguments to filter Managers to count.
     * @example
     * // Count the number of Managers
     * const count = await prisma.manager.count({
     *   where: {
     *     // ... the filter for the Managers we want to count
     *   }
     * })
    **/
    count<T extends ManagerCountArgs>(
      args?: Subset<T, ManagerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ManagerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Manager.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ManagerAggregateArgs>(args: Subset<T, ManagerAggregateArgs>): Prisma.PrismaPromise<GetManagerAggregateType<T>>

    /**
     * Group by Manager.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ManagerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ManagerGroupByArgs['orderBy'] }
        : { orderBy?: ManagerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ManagerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetManagerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Manager model
   */
  readonly fields: ManagerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Manager.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ManagerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    bankDetails<T extends Manager$bankDetailsArgs<ExtArgs> = {}>(args?: Subset<T, Manager$bankDetailsArgs<ExtArgs>>): Prisma__BankDetailsClient<$Result.GetResult<Prisma.$BankDetailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Manager model
   */
  interface ManagerFieldRefs {
    readonly userId: FieldRef<"Manager", 'String'>
    readonly firstName: FieldRef<"Manager", 'String'>
    readonly lastName: FieldRef<"Manager", 'String'>
    readonly employeeId: FieldRef<"Manager", 'String'>
    readonly aadharId: FieldRef<"Manager", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Manager findUnique
   */
  export type ManagerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manager
     */
    omit?: ManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
    /**
     * Filter, which Manager to fetch.
     */
    where: ManagerWhereUniqueInput
  }

  /**
   * Manager findUniqueOrThrow
   */
  export type ManagerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manager
     */
    omit?: ManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
    /**
     * Filter, which Manager to fetch.
     */
    where: ManagerWhereUniqueInput
  }

  /**
   * Manager findFirst
   */
  export type ManagerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manager
     */
    omit?: ManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
    /**
     * Filter, which Manager to fetch.
     */
    where?: ManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Managers to fetch.
     */
    orderBy?: ManagerOrderByWithRelationInput | ManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Managers.
     */
    cursor?: ManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Managers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Managers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Managers.
     */
    distinct?: ManagerScalarFieldEnum | ManagerScalarFieldEnum[]
  }

  /**
   * Manager findFirstOrThrow
   */
  export type ManagerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manager
     */
    omit?: ManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
    /**
     * Filter, which Manager to fetch.
     */
    where?: ManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Managers to fetch.
     */
    orderBy?: ManagerOrderByWithRelationInput | ManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Managers.
     */
    cursor?: ManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Managers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Managers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Managers.
     */
    distinct?: ManagerScalarFieldEnum | ManagerScalarFieldEnum[]
  }

  /**
   * Manager findMany
   */
  export type ManagerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manager
     */
    omit?: ManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
    /**
     * Filter, which Managers to fetch.
     */
    where?: ManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Managers to fetch.
     */
    orderBy?: ManagerOrderByWithRelationInput | ManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Managers.
     */
    cursor?: ManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Managers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Managers.
     */
    skip?: number
    distinct?: ManagerScalarFieldEnum | ManagerScalarFieldEnum[]
  }

  /**
   * Manager create
   */
  export type ManagerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manager
     */
    omit?: ManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
    /**
     * The data needed to create a Manager.
     */
    data: XOR<ManagerCreateInput, ManagerUncheckedCreateInput>
  }

  /**
   * Manager createMany
   */
  export type ManagerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Managers.
     */
    data: ManagerCreateManyInput | ManagerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Manager createManyAndReturn
   */
  export type ManagerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Manager
     */
    omit?: ManagerOmit<ExtArgs> | null
    /**
     * The data used to create many Managers.
     */
    data: ManagerCreateManyInput | ManagerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Manager update
   */
  export type ManagerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manager
     */
    omit?: ManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
    /**
     * The data needed to update a Manager.
     */
    data: XOR<ManagerUpdateInput, ManagerUncheckedUpdateInput>
    /**
     * Choose, which Manager to update.
     */
    where: ManagerWhereUniqueInput
  }

  /**
   * Manager updateMany
   */
  export type ManagerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Managers.
     */
    data: XOR<ManagerUpdateManyMutationInput, ManagerUncheckedUpdateManyInput>
    /**
     * Filter which Managers to update
     */
    where?: ManagerWhereInput
    /**
     * Limit how many Managers to update.
     */
    limit?: number
  }

  /**
   * Manager updateManyAndReturn
   */
  export type ManagerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Manager
     */
    omit?: ManagerOmit<ExtArgs> | null
    /**
     * The data used to update Managers.
     */
    data: XOR<ManagerUpdateManyMutationInput, ManagerUncheckedUpdateManyInput>
    /**
     * Filter which Managers to update
     */
    where?: ManagerWhereInput
    /**
     * Limit how many Managers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Manager upsert
   */
  export type ManagerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manager
     */
    omit?: ManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
    /**
     * The filter to search for the Manager to update in case it exists.
     */
    where: ManagerWhereUniqueInput
    /**
     * In case the Manager found by the `where` argument doesn't exist, create a new Manager with this data.
     */
    create: XOR<ManagerCreateInput, ManagerUncheckedCreateInput>
    /**
     * In case the Manager was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ManagerUpdateInput, ManagerUncheckedUpdateInput>
  }

  /**
   * Manager delete
   */
  export type ManagerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manager
     */
    omit?: ManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
    /**
     * Filter which Manager to delete.
     */
    where: ManagerWhereUniqueInput
  }

  /**
   * Manager deleteMany
   */
  export type ManagerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Managers to delete
     */
    where?: ManagerWhereInput
    /**
     * Limit how many Managers to delete.
     */
    limit?: number
  }

  /**
   * Manager.bankDetails
   */
  export type Manager$bankDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetails
     */
    select?: BankDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankDetails
     */
    omit?: BankDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankDetailsInclude<ExtArgs> | null
    where?: BankDetailsWhereInput
  }

  /**
   * Manager without action
   */
  export type ManagerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manager
     */
    omit?: ManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
  }


  /**
   * Model Technician
   */

  export type AggregateTechnician = {
    _count: TechnicianCountAggregateOutputType | null
    _min: TechnicianMinAggregateOutputType | null
    _max: TechnicianMaxAggregateOutputType | null
  }

  export type TechnicianMinAggregateOutputType = {
    userId: string | null
    firstName: string | null
    lastName: string | null
    employeeId: string | null
    aadharId: string | null
  }

  export type TechnicianMaxAggregateOutputType = {
    userId: string | null
    firstName: string | null
    lastName: string | null
    employeeId: string | null
    aadharId: string | null
  }

  export type TechnicianCountAggregateOutputType = {
    userId: number
    firstName: number
    lastName: number
    employeeId: number
    aadharId: number
    _all: number
  }


  export type TechnicianMinAggregateInputType = {
    userId?: true
    firstName?: true
    lastName?: true
    employeeId?: true
    aadharId?: true
  }

  export type TechnicianMaxAggregateInputType = {
    userId?: true
    firstName?: true
    lastName?: true
    employeeId?: true
    aadharId?: true
  }

  export type TechnicianCountAggregateInputType = {
    userId?: true
    firstName?: true
    lastName?: true
    employeeId?: true
    aadharId?: true
    _all?: true
  }

  export type TechnicianAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Technician to aggregate.
     */
    where?: TechnicianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Technicians to fetch.
     */
    orderBy?: TechnicianOrderByWithRelationInput | TechnicianOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TechnicianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Technicians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Technicians.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Technicians
    **/
    _count?: true | TechnicianCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TechnicianMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TechnicianMaxAggregateInputType
  }

  export type GetTechnicianAggregateType<T extends TechnicianAggregateArgs> = {
        [P in keyof T & keyof AggregateTechnician]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTechnician[P]>
      : GetScalarType<T[P], AggregateTechnician[P]>
  }




  export type TechnicianGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TechnicianWhereInput
    orderBy?: TechnicianOrderByWithAggregationInput | TechnicianOrderByWithAggregationInput[]
    by: TechnicianScalarFieldEnum[] | TechnicianScalarFieldEnum
    having?: TechnicianScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TechnicianCountAggregateInputType | true
    _min?: TechnicianMinAggregateInputType
    _max?: TechnicianMaxAggregateInputType
  }

  export type TechnicianGroupByOutputType = {
    userId: string
    firstName: string
    lastName: string
    employeeId: string
    aadharId: string
    _count: TechnicianCountAggregateOutputType | null
    _min: TechnicianMinAggregateOutputType | null
    _max: TechnicianMaxAggregateOutputType | null
  }

  type GetTechnicianGroupByPayload<T extends TechnicianGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TechnicianGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TechnicianGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TechnicianGroupByOutputType[P]>
            : GetScalarType<T[P], TechnicianGroupByOutputType[P]>
        }
      >
    >


  export type TechnicianSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    employeeId?: boolean
    aadharId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    bankDetails?: boolean | Technician$bankDetailsArgs<ExtArgs>
  }, ExtArgs["result"]["technician"]>

  export type TechnicianSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    employeeId?: boolean
    aadharId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["technician"]>

  export type TechnicianSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    employeeId?: boolean
    aadharId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["technician"]>

  export type TechnicianSelectScalar = {
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    employeeId?: boolean
    aadharId?: boolean
  }

  export type TechnicianOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "firstName" | "lastName" | "employeeId" | "aadharId", ExtArgs["result"]["technician"]>
  export type TechnicianInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    bankDetails?: boolean | Technician$bankDetailsArgs<ExtArgs>
  }
  export type TechnicianIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TechnicianIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TechnicianPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Technician"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      bankDetails: Prisma.$BankDetailsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      firstName: string
      lastName: string
      employeeId: string
      aadharId: string
    }, ExtArgs["result"]["technician"]>
    composites: {}
  }

  type TechnicianGetPayload<S extends boolean | null | undefined | TechnicianDefaultArgs> = $Result.GetResult<Prisma.$TechnicianPayload, S>

  type TechnicianCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TechnicianFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TechnicianCountAggregateInputType | true
    }

  export interface TechnicianDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Technician'], meta: { name: 'Technician' } }
    /**
     * Find zero or one Technician that matches the filter.
     * @param {TechnicianFindUniqueArgs} args - Arguments to find a Technician
     * @example
     * // Get one Technician
     * const technician = await prisma.technician.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TechnicianFindUniqueArgs>(args: SelectSubset<T, TechnicianFindUniqueArgs<ExtArgs>>): Prisma__TechnicianClient<$Result.GetResult<Prisma.$TechnicianPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Technician that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TechnicianFindUniqueOrThrowArgs} args - Arguments to find a Technician
     * @example
     * // Get one Technician
     * const technician = await prisma.technician.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TechnicianFindUniqueOrThrowArgs>(args: SelectSubset<T, TechnicianFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TechnicianClient<$Result.GetResult<Prisma.$TechnicianPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Technician that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechnicianFindFirstArgs} args - Arguments to find a Technician
     * @example
     * // Get one Technician
     * const technician = await prisma.technician.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TechnicianFindFirstArgs>(args?: SelectSubset<T, TechnicianFindFirstArgs<ExtArgs>>): Prisma__TechnicianClient<$Result.GetResult<Prisma.$TechnicianPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Technician that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechnicianFindFirstOrThrowArgs} args - Arguments to find a Technician
     * @example
     * // Get one Technician
     * const technician = await prisma.technician.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TechnicianFindFirstOrThrowArgs>(args?: SelectSubset<T, TechnicianFindFirstOrThrowArgs<ExtArgs>>): Prisma__TechnicianClient<$Result.GetResult<Prisma.$TechnicianPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Technicians that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechnicianFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Technicians
     * const technicians = await prisma.technician.findMany()
     * 
     * // Get first 10 Technicians
     * const technicians = await prisma.technician.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const technicianWithUserIdOnly = await prisma.technician.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends TechnicianFindManyArgs>(args?: SelectSubset<T, TechnicianFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TechnicianPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Technician.
     * @param {TechnicianCreateArgs} args - Arguments to create a Technician.
     * @example
     * // Create one Technician
     * const Technician = await prisma.technician.create({
     *   data: {
     *     // ... data to create a Technician
     *   }
     * })
     * 
     */
    create<T extends TechnicianCreateArgs>(args: SelectSubset<T, TechnicianCreateArgs<ExtArgs>>): Prisma__TechnicianClient<$Result.GetResult<Prisma.$TechnicianPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Technicians.
     * @param {TechnicianCreateManyArgs} args - Arguments to create many Technicians.
     * @example
     * // Create many Technicians
     * const technician = await prisma.technician.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TechnicianCreateManyArgs>(args?: SelectSubset<T, TechnicianCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Technicians and returns the data saved in the database.
     * @param {TechnicianCreateManyAndReturnArgs} args - Arguments to create many Technicians.
     * @example
     * // Create many Technicians
     * const technician = await prisma.technician.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Technicians and only return the `userId`
     * const technicianWithUserIdOnly = await prisma.technician.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TechnicianCreateManyAndReturnArgs>(args?: SelectSubset<T, TechnicianCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TechnicianPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Technician.
     * @param {TechnicianDeleteArgs} args - Arguments to delete one Technician.
     * @example
     * // Delete one Technician
     * const Technician = await prisma.technician.delete({
     *   where: {
     *     // ... filter to delete one Technician
     *   }
     * })
     * 
     */
    delete<T extends TechnicianDeleteArgs>(args: SelectSubset<T, TechnicianDeleteArgs<ExtArgs>>): Prisma__TechnicianClient<$Result.GetResult<Prisma.$TechnicianPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Technician.
     * @param {TechnicianUpdateArgs} args - Arguments to update one Technician.
     * @example
     * // Update one Technician
     * const technician = await prisma.technician.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TechnicianUpdateArgs>(args: SelectSubset<T, TechnicianUpdateArgs<ExtArgs>>): Prisma__TechnicianClient<$Result.GetResult<Prisma.$TechnicianPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Technicians.
     * @param {TechnicianDeleteManyArgs} args - Arguments to filter Technicians to delete.
     * @example
     * // Delete a few Technicians
     * const { count } = await prisma.technician.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TechnicianDeleteManyArgs>(args?: SelectSubset<T, TechnicianDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Technicians.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechnicianUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Technicians
     * const technician = await prisma.technician.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TechnicianUpdateManyArgs>(args: SelectSubset<T, TechnicianUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Technicians and returns the data updated in the database.
     * @param {TechnicianUpdateManyAndReturnArgs} args - Arguments to update many Technicians.
     * @example
     * // Update many Technicians
     * const technician = await prisma.technician.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Technicians and only return the `userId`
     * const technicianWithUserIdOnly = await prisma.technician.updateManyAndReturn({
     *   select: { userId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TechnicianUpdateManyAndReturnArgs>(args: SelectSubset<T, TechnicianUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TechnicianPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Technician.
     * @param {TechnicianUpsertArgs} args - Arguments to update or create a Technician.
     * @example
     * // Update or create a Technician
     * const technician = await prisma.technician.upsert({
     *   create: {
     *     // ... data to create a Technician
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Technician we want to update
     *   }
     * })
     */
    upsert<T extends TechnicianUpsertArgs>(args: SelectSubset<T, TechnicianUpsertArgs<ExtArgs>>): Prisma__TechnicianClient<$Result.GetResult<Prisma.$TechnicianPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Technicians.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechnicianCountArgs} args - Arguments to filter Technicians to count.
     * @example
     * // Count the number of Technicians
     * const count = await prisma.technician.count({
     *   where: {
     *     // ... the filter for the Technicians we want to count
     *   }
     * })
    **/
    count<T extends TechnicianCountArgs>(
      args?: Subset<T, TechnicianCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TechnicianCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Technician.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechnicianAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TechnicianAggregateArgs>(args: Subset<T, TechnicianAggregateArgs>): Prisma.PrismaPromise<GetTechnicianAggregateType<T>>

    /**
     * Group by Technician.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechnicianGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TechnicianGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TechnicianGroupByArgs['orderBy'] }
        : { orderBy?: TechnicianGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TechnicianGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTechnicianGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Technician model
   */
  readonly fields: TechnicianFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Technician.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TechnicianClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    bankDetails<T extends Technician$bankDetailsArgs<ExtArgs> = {}>(args?: Subset<T, Technician$bankDetailsArgs<ExtArgs>>): Prisma__BankDetailsClient<$Result.GetResult<Prisma.$BankDetailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Technician model
   */
  interface TechnicianFieldRefs {
    readonly userId: FieldRef<"Technician", 'String'>
    readonly firstName: FieldRef<"Technician", 'String'>
    readonly lastName: FieldRef<"Technician", 'String'>
    readonly employeeId: FieldRef<"Technician", 'String'>
    readonly aadharId: FieldRef<"Technician", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Technician findUnique
   */
  export type TechnicianFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Technician
     */
    select?: TechnicianSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Technician
     */
    omit?: TechnicianOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicianInclude<ExtArgs> | null
    /**
     * Filter, which Technician to fetch.
     */
    where: TechnicianWhereUniqueInput
  }

  /**
   * Technician findUniqueOrThrow
   */
  export type TechnicianFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Technician
     */
    select?: TechnicianSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Technician
     */
    omit?: TechnicianOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicianInclude<ExtArgs> | null
    /**
     * Filter, which Technician to fetch.
     */
    where: TechnicianWhereUniqueInput
  }

  /**
   * Technician findFirst
   */
  export type TechnicianFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Technician
     */
    select?: TechnicianSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Technician
     */
    omit?: TechnicianOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicianInclude<ExtArgs> | null
    /**
     * Filter, which Technician to fetch.
     */
    where?: TechnicianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Technicians to fetch.
     */
    orderBy?: TechnicianOrderByWithRelationInput | TechnicianOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Technicians.
     */
    cursor?: TechnicianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Technicians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Technicians.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Technicians.
     */
    distinct?: TechnicianScalarFieldEnum | TechnicianScalarFieldEnum[]
  }

  /**
   * Technician findFirstOrThrow
   */
  export type TechnicianFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Technician
     */
    select?: TechnicianSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Technician
     */
    omit?: TechnicianOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicianInclude<ExtArgs> | null
    /**
     * Filter, which Technician to fetch.
     */
    where?: TechnicianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Technicians to fetch.
     */
    orderBy?: TechnicianOrderByWithRelationInput | TechnicianOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Technicians.
     */
    cursor?: TechnicianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Technicians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Technicians.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Technicians.
     */
    distinct?: TechnicianScalarFieldEnum | TechnicianScalarFieldEnum[]
  }

  /**
   * Technician findMany
   */
  export type TechnicianFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Technician
     */
    select?: TechnicianSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Technician
     */
    omit?: TechnicianOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicianInclude<ExtArgs> | null
    /**
     * Filter, which Technicians to fetch.
     */
    where?: TechnicianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Technicians to fetch.
     */
    orderBy?: TechnicianOrderByWithRelationInput | TechnicianOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Technicians.
     */
    cursor?: TechnicianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Technicians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Technicians.
     */
    skip?: number
    distinct?: TechnicianScalarFieldEnum | TechnicianScalarFieldEnum[]
  }

  /**
   * Technician create
   */
  export type TechnicianCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Technician
     */
    select?: TechnicianSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Technician
     */
    omit?: TechnicianOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicianInclude<ExtArgs> | null
    /**
     * The data needed to create a Technician.
     */
    data: XOR<TechnicianCreateInput, TechnicianUncheckedCreateInput>
  }

  /**
   * Technician createMany
   */
  export type TechnicianCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Technicians.
     */
    data: TechnicianCreateManyInput | TechnicianCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Technician createManyAndReturn
   */
  export type TechnicianCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Technician
     */
    select?: TechnicianSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Technician
     */
    omit?: TechnicianOmit<ExtArgs> | null
    /**
     * The data used to create many Technicians.
     */
    data: TechnicianCreateManyInput | TechnicianCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicianIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Technician update
   */
  export type TechnicianUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Technician
     */
    select?: TechnicianSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Technician
     */
    omit?: TechnicianOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicianInclude<ExtArgs> | null
    /**
     * The data needed to update a Technician.
     */
    data: XOR<TechnicianUpdateInput, TechnicianUncheckedUpdateInput>
    /**
     * Choose, which Technician to update.
     */
    where: TechnicianWhereUniqueInput
  }

  /**
   * Technician updateMany
   */
  export type TechnicianUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Technicians.
     */
    data: XOR<TechnicianUpdateManyMutationInput, TechnicianUncheckedUpdateManyInput>
    /**
     * Filter which Technicians to update
     */
    where?: TechnicianWhereInput
    /**
     * Limit how many Technicians to update.
     */
    limit?: number
  }

  /**
   * Technician updateManyAndReturn
   */
  export type TechnicianUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Technician
     */
    select?: TechnicianSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Technician
     */
    omit?: TechnicianOmit<ExtArgs> | null
    /**
     * The data used to update Technicians.
     */
    data: XOR<TechnicianUpdateManyMutationInput, TechnicianUncheckedUpdateManyInput>
    /**
     * Filter which Technicians to update
     */
    where?: TechnicianWhereInput
    /**
     * Limit how many Technicians to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicianIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Technician upsert
   */
  export type TechnicianUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Technician
     */
    select?: TechnicianSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Technician
     */
    omit?: TechnicianOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicianInclude<ExtArgs> | null
    /**
     * The filter to search for the Technician to update in case it exists.
     */
    where: TechnicianWhereUniqueInput
    /**
     * In case the Technician found by the `where` argument doesn't exist, create a new Technician with this data.
     */
    create: XOR<TechnicianCreateInput, TechnicianUncheckedCreateInput>
    /**
     * In case the Technician was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TechnicianUpdateInput, TechnicianUncheckedUpdateInput>
  }

  /**
   * Technician delete
   */
  export type TechnicianDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Technician
     */
    select?: TechnicianSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Technician
     */
    omit?: TechnicianOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicianInclude<ExtArgs> | null
    /**
     * Filter which Technician to delete.
     */
    where: TechnicianWhereUniqueInput
  }

  /**
   * Technician deleteMany
   */
  export type TechnicianDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Technicians to delete
     */
    where?: TechnicianWhereInput
    /**
     * Limit how many Technicians to delete.
     */
    limit?: number
  }

  /**
   * Technician.bankDetails
   */
  export type Technician$bankDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetails
     */
    select?: BankDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankDetails
     */
    omit?: BankDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankDetailsInclude<ExtArgs> | null
    where?: BankDetailsWhereInput
  }

  /**
   * Technician without action
   */
  export type TechnicianDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Technician
     */
    select?: TechnicianSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Technician
     */
    omit?: TechnicianOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicianInclude<ExtArgs> | null
  }


  /**
   * Model FieldExecutive
   */

  export type AggregateFieldExecutive = {
    _count: FieldExecutiveCountAggregateOutputType | null
    _min: FieldExecutiveMinAggregateOutputType | null
    _max: FieldExecutiveMaxAggregateOutputType | null
  }

  export type FieldExecutiveMinAggregateOutputType = {
    userId: string | null
    firstName: string | null
    lastName: string | null
    employeeId: string | null
    aadharId: string | null
  }

  export type FieldExecutiveMaxAggregateOutputType = {
    userId: string | null
    firstName: string | null
    lastName: string | null
    employeeId: string | null
    aadharId: string | null
  }

  export type FieldExecutiveCountAggregateOutputType = {
    userId: number
    firstName: number
    lastName: number
    employeeId: number
    aadharId: number
    _all: number
  }


  export type FieldExecutiveMinAggregateInputType = {
    userId?: true
    firstName?: true
    lastName?: true
    employeeId?: true
    aadharId?: true
  }

  export type FieldExecutiveMaxAggregateInputType = {
    userId?: true
    firstName?: true
    lastName?: true
    employeeId?: true
    aadharId?: true
  }

  export type FieldExecutiveCountAggregateInputType = {
    userId?: true
    firstName?: true
    lastName?: true
    employeeId?: true
    aadharId?: true
    _all?: true
  }

  export type FieldExecutiveAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FieldExecutive to aggregate.
     */
    where?: FieldExecutiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FieldExecutives to fetch.
     */
    orderBy?: FieldExecutiveOrderByWithRelationInput | FieldExecutiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FieldExecutiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FieldExecutives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FieldExecutives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FieldExecutives
    **/
    _count?: true | FieldExecutiveCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FieldExecutiveMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FieldExecutiveMaxAggregateInputType
  }

  export type GetFieldExecutiveAggregateType<T extends FieldExecutiveAggregateArgs> = {
        [P in keyof T & keyof AggregateFieldExecutive]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFieldExecutive[P]>
      : GetScalarType<T[P], AggregateFieldExecutive[P]>
  }




  export type FieldExecutiveGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FieldExecutiveWhereInput
    orderBy?: FieldExecutiveOrderByWithAggregationInput | FieldExecutiveOrderByWithAggregationInput[]
    by: FieldExecutiveScalarFieldEnum[] | FieldExecutiveScalarFieldEnum
    having?: FieldExecutiveScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FieldExecutiveCountAggregateInputType | true
    _min?: FieldExecutiveMinAggregateInputType
    _max?: FieldExecutiveMaxAggregateInputType
  }

  export type FieldExecutiveGroupByOutputType = {
    userId: string
    firstName: string
    lastName: string
    employeeId: string
    aadharId: string
    _count: FieldExecutiveCountAggregateOutputType | null
    _min: FieldExecutiveMinAggregateOutputType | null
    _max: FieldExecutiveMaxAggregateOutputType | null
  }

  type GetFieldExecutiveGroupByPayload<T extends FieldExecutiveGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FieldExecutiveGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FieldExecutiveGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FieldExecutiveGroupByOutputType[P]>
            : GetScalarType<T[P], FieldExecutiveGroupByOutputType[P]>
        }
      >
    >


  export type FieldExecutiveSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    employeeId?: boolean
    aadharId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    bankDetails?: boolean | FieldExecutive$bankDetailsArgs<ExtArgs>
  }, ExtArgs["result"]["fieldExecutive"]>

  export type FieldExecutiveSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    employeeId?: boolean
    aadharId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fieldExecutive"]>

  export type FieldExecutiveSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    employeeId?: boolean
    aadharId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fieldExecutive"]>

  export type FieldExecutiveSelectScalar = {
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    employeeId?: boolean
    aadharId?: boolean
  }

  export type FieldExecutiveOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "firstName" | "lastName" | "employeeId" | "aadharId", ExtArgs["result"]["fieldExecutive"]>
  export type FieldExecutiveInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    bankDetails?: boolean | FieldExecutive$bankDetailsArgs<ExtArgs>
  }
  export type FieldExecutiveIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FieldExecutiveIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $FieldExecutivePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FieldExecutive"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      bankDetails: Prisma.$BankDetailsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      firstName: string
      lastName: string
      employeeId: string
      aadharId: string
    }, ExtArgs["result"]["fieldExecutive"]>
    composites: {}
  }

  type FieldExecutiveGetPayload<S extends boolean | null | undefined | FieldExecutiveDefaultArgs> = $Result.GetResult<Prisma.$FieldExecutivePayload, S>

  type FieldExecutiveCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FieldExecutiveFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FieldExecutiveCountAggregateInputType | true
    }

  export interface FieldExecutiveDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FieldExecutive'], meta: { name: 'FieldExecutive' } }
    /**
     * Find zero or one FieldExecutive that matches the filter.
     * @param {FieldExecutiveFindUniqueArgs} args - Arguments to find a FieldExecutive
     * @example
     * // Get one FieldExecutive
     * const fieldExecutive = await prisma.fieldExecutive.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FieldExecutiveFindUniqueArgs>(args: SelectSubset<T, FieldExecutiveFindUniqueArgs<ExtArgs>>): Prisma__FieldExecutiveClient<$Result.GetResult<Prisma.$FieldExecutivePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FieldExecutive that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FieldExecutiveFindUniqueOrThrowArgs} args - Arguments to find a FieldExecutive
     * @example
     * // Get one FieldExecutive
     * const fieldExecutive = await prisma.fieldExecutive.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FieldExecutiveFindUniqueOrThrowArgs>(args: SelectSubset<T, FieldExecutiveFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FieldExecutiveClient<$Result.GetResult<Prisma.$FieldExecutivePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FieldExecutive that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldExecutiveFindFirstArgs} args - Arguments to find a FieldExecutive
     * @example
     * // Get one FieldExecutive
     * const fieldExecutive = await prisma.fieldExecutive.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FieldExecutiveFindFirstArgs>(args?: SelectSubset<T, FieldExecutiveFindFirstArgs<ExtArgs>>): Prisma__FieldExecutiveClient<$Result.GetResult<Prisma.$FieldExecutivePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FieldExecutive that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldExecutiveFindFirstOrThrowArgs} args - Arguments to find a FieldExecutive
     * @example
     * // Get one FieldExecutive
     * const fieldExecutive = await prisma.fieldExecutive.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FieldExecutiveFindFirstOrThrowArgs>(args?: SelectSubset<T, FieldExecutiveFindFirstOrThrowArgs<ExtArgs>>): Prisma__FieldExecutiveClient<$Result.GetResult<Prisma.$FieldExecutivePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FieldExecutives that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldExecutiveFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FieldExecutives
     * const fieldExecutives = await prisma.fieldExecutive.findMany()
     * 
     * // Get first 10 FieldExecutives
     * const fieldExecutives = await prisma.fieldExecutive.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const fieldExecutiveWithUserIdOnly = await prisma.fieldExecutive.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends FieldExecutiveFindManyArgs>(args?: SelectSubset<T, FieldExecutiveFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FieldExecutivePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FieldExecutive.
     * @param {FieldExecutiveCreateArgs} args - Arguments to create a FieldExecutive.
     * @example
     * // Create one FieldExecutive
     * const FieldExecutive = await prisma.fieldExecutive.create({
     *   data: {
     *     // ... data to create a FieldExecutive
     *   }
     * })
     * 
     */
    create<T extends FieldExecutiveCreateArgs>(args: SelectSubset<T, FieldExecutiveCreateArgs<ExtArgs>>): Prisma__FieldExecutiveClient<$Result.GetResult<Prisma.$FieldExecutivePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FieldExecutives.
     * @param {FieldExecutiveCreateManyArgs} args - Arguments to create many FieldExecutives.
     * @example
     * // Create many FieldExecutives
     * const fieldExecutive = await prisma.fieldExecutive.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FieldExecutiveCreateManyArgs>(args?: SelectSubset<T, FieldExecutiveCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FieldExecutives and returns the data saved in the database.
     * @param {FieldExecutiveCreateManyAndReturnArgs} args - Arguments to create many FieldExecutives.
     * @example
     * // Create many FieldExecutives
     * const fieldExecutive = await prisma.fieldExecutive.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FieldExecutives and only return the `userId`
     * const fieldExecutiveWithUserIdOnly = await prisma.fieldExecutive.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FieldExecutiveCreateManyAndReturnArgs>(args?: SelectSubset<T, FieldExecutiveCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FieldExecutivePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FieldExecutive.
     * @param {FieldExecutiveDeleteArgs} args - Arguments to delete one FieldExecutive.
     * @example
     * // Delete one FieldExecutive
     * const FieldExecutive = await prisma.fieldExecutive.delete({
     *   where: {
     *     // ... filter to delete one FieldExecutive
     *   }
     * })
     * 
     */
    delete<T extends FieldExecutiveDeleteArgs>(args: SelectSubset<T, FieldExecutiveDeleteArgs<ExtArgs>>): Prisma__FieldExecutiveClient<$Result.GetResult<Prisma.$FieldExecutivePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FieldExecutive.
     * @param {FieldExecutiveUpdateArgs} args - Arguments to update one FieldExecutive.
     * @example
     * // Update one FieldExecutive
     * const fieldExecutive = await prisma.fieldExecutive.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FieldExecutiveUpdateArgs>(args: SelectSubset<T, FieldExecutiveUpdateArgs<ExtArgs>>): Prisma__FieldExecutiveClient<$Result.GetResult<Prisma.$FieldExecutivePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FieldExecutives.
     * @param {FieldExecutiveDeleteManyArgs} args - Arguments to filter FieldExecutives to delete.
     * @example
     * // Delete a few FieldExecutives
     * const { count } = await prisma.fieldExecutive.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FieldExecutiveDeleteManyArgs>(args?: SelectSubset<T, FieldExecutiveDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FieldExecutives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldExecutiveUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FieldExecutives
     * const fieldExecutive = await prisma.fieldExecutive.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FieldExecutiveUpdateManyArgs>(args: SelectSubset<T, FieldExecutiveUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FieldExecutives and returns the data updated in the database.
     * @param {FieldExecutiveUpdateManyAndReturnArgs} args - Arguments to update many FieldExecutives.
     * @example
     * // Update many FieldExecutives
     * const fieldExecutive = await prisma.fieldExecutive.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FieldExecutives and only return the `userId`
     * const fieldExecutiveWithUserIdOnly = await prisma.fieldExecutive.updateManyAndReturn({
     *   select: { userId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FieldExecutiveUpdateManyAndReturnArgs>(args: SelectSubset<T, FieldExecutiveUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FieldExecutivePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FieldExecutive.
     * @param {FieldExecutiveUpsertArgs} args - Arguments to update or create a FieldExecutive.
     * @example
     * // Update or create a FieldExecutive
     * const fieldExecutive = await prisma.fieldExecutive.upsert({
     *   create: {
     *     // ... data to create a FieldExecutive
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FieldExecutive we want to update
     *   }
     * })
     */
    upsert<T extends FieldExecutiveUpsertArgs>(args: SelectSubset<T, FieldExecutiveUpsertArgs<ExtArgs>>): Prisma__FieldExecutiveClient<$Result.GetResult<Prisma.$FieldExecutivePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FieldExecutives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldExecutiveCountArgs} args - Arguments to filter FieldExecutives to count.
     * @example
     * // Count the number of FieldExecutives
     * const count = await prisma.fieldExecutive.count({
     *   where: {
     *     // ... the filter for the FieldExecutives we want to count
     *   }
     * })
    **/
    count<T extends FieldExecutiveCountArgs>(
      args?: Subset<T, FieldExecutiveCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FieldExecutiveCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FieldExecutive.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldExecutiveAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FieldExecutiveAggregateArgs>(args: Subset<T, FieldExecutiveAggregateArgs>): Prisma.PrismaPromise<GetFieldExecutiveAggregateType<T>>

    /**
     * Group by FieldExecutive.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldExecutiveGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FieldExecutiveGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FieldExecutiveGroupByArgs['orderBy'] }
        : { orderBy?: FieldExecutiveGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FieldExecutiveGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFieldExecutiveGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FieldExecutive model
   */
  readonly fields: FieldExecutiveFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FieldExecutive.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FieldExecutiveClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    bankDetails<T extends FieldExecutive$bankDetailsArgs<ExtArgs> = {}>(args?: Subset<T, FieldExecutive$bankDetailsArgs<ExtArgs>>): Prisma__BankDetailsClient<$Result.GetResult<Prisma.$BankDetailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FieldExecutive model
   */
  interface FieldExecutiveFieldRefs {
    readonly userId: FieldRef<"FieldExecutive", 'String'>
    readonly firstName: FieldRef<"FieldExecutive", 'String'>
    readonly lastName: FieldRef<"FieldExecutive", 'String'>
    readonly employeeId: FieldRef<"FieldExecutive", 'String'>
    readonly aadharId: FieldRef<"FieldExecutive", 'String'>
  }
    

  // Custom InputTypes
  /**
   * FieldExecutive findUnique
   */
  export type FieldExecutiveFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldExecutive
     */
    select?: FieldExecutiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldExecutive
     */
    omit?: FieldExecutiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldExecutiveInclude<ExtArgs> | null
    /**
     * Filter, which FieldExecutive to fetch.
     */
    where: FieldExecutiveWhereUniqueInput
  }

  /**
   * FieldExecutive findUniqueOrThrow
   */
  export type FieldExecutiveFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldExecutive
     */
    select?: FieldExecutiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldExecutive
     */
    omit?: FieldExecutiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldExecutiveInclude<ExtArgs> | null
    /**
     * Filter, which FieldExecutive to fetch.
     */
    where: FieldExecutiveWhereUniqueInput
  }

  /**
   * FieldExecutive findFirst
   */
  export type FieldExecutiveFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldExecutive
     */
    select?: FieldExecutiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldExecutive
     */
    omit?: FieldExecutiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldExecutiveInclude<ExtArgs> | null
    /**
     * Filter, which FieldExecutive to fetch.
     */
    where?: FieldExecutiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FieldExecutives to fetch.
     */
    orderBy?: FieldExecutiveOrderByWithRelationInput | FieldExecutiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FieldExecutives.
     */
    cursor?: FieldExecutiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FieldExecutives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FieldExecutives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FieldExecutives.
     */
    distinct?: FieldExecutiveScalarFieldEnum | FieldExecutiveScalarFieldEnum[]
  }

  /**
   * FieldExecutive findFirstOrThrow
   */
  export type FieldExecutiveFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldExecutive
     */
    select?: FieldExecutiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldExecutive
     */
    omit?: FieldExecutiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldExecutiveInclude<ExtArgs> | null
    /**
     * Filter, which FieldExecutive to fetch.
     */
    where?: FieldExecutiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FieldExecutives to fetch.
     */
    orderBy?: FieldExecutiveOrderByWithRelationInput | FieldExecutiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FieldExecutives.
     */
    cursor?: FieldExecutiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FieldExecutives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FieldExecutives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FieldExecutives.
     */
    distinct?: FieldExecutiveScalarFieldEnum | FieldExecutiveScalarFieldEnum[]
  }

  /**
   * FieldExecutive findMany
   */
  export type FieldExecutiveFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldExecutive
     */
    select?: FieldExecutiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldExecutive
     */
    omit?: FieldExecutiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldExecutiveInclude<ExtArgs> | null
    /**
     * Filter, which FieldExecutives to fetch.
     */
    where?: FieldExecutiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FieldExecutives to fetch.
     */
    orderBy?: FieldExecutiveOrderByWithRelationInput | FieldExecutiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FieldExecutives.
     */
    cursor?: FieldExecutiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FieldExecutives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FieldExecutives.
     */
    skip?: number
    distinct?: FieldExecutiveScalarFieldEnum | FieldExecutiveScalarFieldEnum[]
  }

  /**
   * FieldExecutive create
   */
  export type FieldExecutiveCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldExecutive
     */
    select?: FieldExecutiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldExecutive
     */
    omit?: FieldExecutiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldExecutiveInclude<ExtArgs> | null
    /**
     * The data needed to create a FieldExecutive.
     */
    data: XOR<FieldExecutiveCreateInput, FieldExecutiveUncheckedCreateInput>
  }

  /**
   * FieldExecutive createMany
   */
  export type FieldExecutiveCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FieldExecutives.
     */
    data: FieldExecutiveCreateManyInput | FieldExecutiveCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FieldExecutive createManyAndReturn
   */
  export type FieldExecutiveCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldExecutive
     */
    select?: FieldExecutiveSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FieldExecutive
     */
    omit?: FieldExecutiveOmit<ExtArgs> | null
    /**
     * The data used to create many FieldExecutives.
     */
    data: FieldExecutiveCreateManyInput | FieldExecutiveCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldExecutiveIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FieldExecutive update
   */
  export type FieldExecutiveUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldExecutive
     */
    select?: FieldExecutiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldExecutive
     */
    omit?: FieldExecutiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldExecutiveInclude<ExtArgs> | null
    /**
     * The data needed to update a FieldExecutive.
     */
    data: XOR<FieldExecutiveUpdateInput, FieldExecutiveUncheckedUpdateInput>
    /**
     * Choose, which FieldExecutive to update.
     */
    where: FieldExecutiveWhereUniqueInput
  }

  /**
   * FieldExecutive updateMany
   */
  export type FieldExecutiveUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FieldExecutives.
     */
    data: XOR<FieldExecutiveUpdateManyMutationInput, FieldExecutiveUncheckedUpdateManyInput>
    /**
     * Filter which FieldExecutives to update
     */
    where?: FieldExecutiveWhereInput
    /**
     * Limit how many FieldExecutives to update.
     */
    limit?: number
  }

  /**
   * FieldExecutive updateManyAndReturn
   */
  export type FieldExecutiveUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldExecutive
     */
    select?: FieldExecutiveSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FieldExecutive
     */
    omit?: FieldExecutiveOmit<ExtArgs> | null
    /**
     * The data used to update FieldExecutives.
     */
    data: XOR<FieldExecutiveUpdateManyMutationInput, FieldExecutiveUncheckedUpdateManyInput>
    /**
     * Filter which FieldExecutives to update
     */
    where?: FieldExecutiveWhereInput
    /**
     * Limit how many FieldExecutives to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldExecutiveIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FieldExecutive upsert
   */
  export type FieldExecutiveUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldExecutive
     */
    select?: FieldExecutiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldExecutive
     */
    omit?: FieldExecutiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldExecutiveInclude<ExtArgs> | null
    /**
     * The filter to search for the FieldExecutive to update in case it exists.
     */
    where: FieldExecutiveWhereUniqueInput
    /**
     * In case the FieldExecutive found by the `where` argument doesn't exist, create a new FieldExecutive with this data.
     */
    create: XOR<FieldExecutiveCreateInput, FieldExecutiveUncheckedCreateInput>
    /**
     * In case the FieldExecutive was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FieldExecutiveUpdateInput, FieldExecutiveUncheckedUpdateInput>
  }

  /**
   * FieldExecutive delete
   */
  export type FieldExecutiveDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldExecutive
     */
    select?: FieldExecutiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldExecutive
     */
    omit?: FieldExecutiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldExecutiveInclude<ExtArgs> | null
    /**
     * Filter which FieldExecutive to delete.
     */
    where: FieldExecutiveWhereUniqueInput
  }

  /**
   * FieldExecutive deleteMany
   */
  export type FieldExecutiveDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FieldExecutives to delete
     */
    where?: FieldExecutiveWhereInput
    /**
     * Limit how many FieldExecutives to delete.
     */
    limit?: number
  }

  /**
   * FieldExecutive.bankDetails
   */
  export type FieldExecutive$bankDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetails
     */
    select?: BankDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankDetails
     */
    omit?: BankDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankDetailsInclude<ExtArgs> | null
    where?: BankDetailsWhereInput
  }

  /**
   * FieldExecutive without action
   */
  export type FieldExecutiveDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldExecutive
     */
    select?: FieldExecutiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldExecutive
     */
    omit?: FieldExecutiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldExecutiveInclude<ExtArgs> | null
  }


  /**
   * Model SalesExecutive
   */

  export type AggregateSalesExecutive = {
    _count: SalesExecutiveCountAggregateOutputType | null
    _min: SalesExecutiveMinAggregateOutputType | null
    _max: SalesExecutiveMaxAggregateOutputType | null
  }

  export type SalesExecutiveMinAggregateOutputType = {
    userId: string | null
    firstName: string | null
    lastName: string | null
    employeeId: string | null
    aadharId: string | null
  }

  export type SalesExecutiveMaxAggregateOutputType = {
    userId: string | null
    firstName: string | null
    lastName: string | null
    employeeId: string | null
    aadharId: string | null
  }

  export type SalesExecutiveCountAggregateOutputType = {
    userId: number
    firstName: number
    lastName: number
    employeeId: number
    aadharId: number
    _all: number
  }


  export type SalesExecutiveMinAggregateInputType = {
    userId?: true
    firstName?: true
    lastName?: true
    employeeId?: true
    aadharId?: true
  }

  export type SalesExecutiveMaxAggregateInputType = {
    userId?: true
    firstName?: true
    lastName?: true
    employeeId?: true
    aadharId?: true
  }

  export type SalesExecutiveCountAggregateInputType = {
    userId?: true
    firstName?: true
    lastName?: true
    employeeId?: true
    aadharId?: true
    _all?: true
  }

  export type SalesExecutiveAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalesExecutive to aggregate.
     */
    where?: SalesExecutiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesExecutives to fetch.
     */
    orderBy?: SalesExecutiveOrderByWithRelationInput | SalesExecutiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SalesExecutiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesExecutives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesExecutives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SalesExecutives
    **/
    _count?: true | SalesExecutiveCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SalesExecutiveMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SalesExecutiveMaxAggregateInputType
  }

  export type GetSalesExecutiveAggregateType<T extends SalesExecutiveAggregateArgs> = {
        [P in keyof T & keyof AggregateSalesExecutive]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSalesExecutive[P]>
      : GetScalarType<T[P], AggregateSalesExecutive[P]>
  }




  export type SalesExecutiveGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesExecutiveWhereInput
    orderBy?: SalesExecutiveOrderByWithAggregationInput | SalesExecutiveOrderByWithAggregationInput[]
    by: SalesExecutiveScalarFieldEnum[] | SalesExecutiveScalarFieldEnum
    having?: SalesExecutiveScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SalesExecutiveCountAggregateInputType | true
    _min?: SalesExecutiveMinAggregateInputType
    _max?: SalesExecutiveMaxAggregateInputType
  }

  export type SalesExecutiveGroupByOutputType = {
    userId: string
    firstName: string
    lastName: string
    employeeId: string
    aadharId: string
    _count: SalesExecutiveCountAggregateOutputType | null
    _min: SalesExecutiveMinAggregateOutputType | null
    _max: SalesExecutiveMaxAggregateOutputType | null
  }

  type GetSalesExecutiveGroupByPayload<T extends SalesExecutiveGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SalesExecutiveGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SalesExecutiveGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SalesExecutiveGroupByOutputType[P]>
            : GetScalarType<T[P], SalesExecutiveGroupByOutputType[P]>
        }
      >
    >


  export type SalesExecutiveSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    employeeId?: boolean
    aadharId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    bankDetails?: boolean | SalesExecutive$bankDetailsArgs<ExtArgs>
  }, ExtArgs["result"]["salesExecutive"]>

  export type SalesExecutiveSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    employeeId?: boolean
    aadharId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salesExecutive"]>

  export type SalesExecutiveSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    employeeId?: boolean
    aadharId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salesExecutive"]>

  export type SalesExecutiveSelectScalar = {
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    employeeId?: boolean
    aadharId?: boolean
  }

  export type SalesExecutiveOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "firstName" | "lastName" | "employeeId" | "aadharId", ExtArgs["result"]["salesExecutive"]>
  export type SalesExecutiveInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    bankDetails?: boolean | SalesExecutive$bankDetailsArgs<ExtArgs>
  }
  export type SalesExecutiveIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SalesExecutiveIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SalesExecutivePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SalesExecutive"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      bankDetails: Prisma.$BankDetailsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      firstName: string
      lastName: string
      employeeId: string
      aadharId: string
    }, ExtArgs["result"]["salesExecutive"]>
    composites: {}
  }

  type SalesExecutiveGetPayload<S extends boolean | null | undefined | SalesExecutiveDefaultArgs> = $Result.GetResult<Prisma.$SalesExecutivePayload, S>

  type SalesExecutiveCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SalesExecutiveFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SalesExecutiveCountAggregateInputType | true
    }

  export interface SalesExecutiveDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SalesExecutive'], meta: { name: 'SalesExecutive' } }
    /**
     * Find zero or one SalesExecutive that matches the filter.
     * @param {SalesExecutiveFindUniqueArgs} args - Arguments to find a SalesExecutive
     * @example
     * // Get one SalesExecutive
     * const salesExecutive = await prisma.salesExecutive.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SalesExecutiveFindUniqueArgs>(args: SelectSubset<T, SalesExecutiveFindUniqueArgs<ExtArgs>>): Prisma__SalesExecutiveClient<$Result.GetResult<Prisma.$SalesExecutivePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SalesExecutive that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SalesExecutiveFindUniqueOrThrowArgs} args - Arguments to find a SalesExecutive
     * @example
     * // Get one SalesExecutive
     * const salesExecutive = await prisma.salesExecutive.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SalesExecutiveFindUniqueOrThrowArgs>(args: SelectSubset<T, SalesExecutiveFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SalesExecutiveClient<$Result.GetResult<Prisma.$SalesExecutivePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SalesExecutive that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesExecutiveFindFirstArgs} args - Arguments to find a SalesExecutive
     * @example
     * // Get one SalesExecutive
     * const salesExecutive = await prisma.salesExecutive.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SalesExecutiveFindFirstArgs>(args?: SelectSubset<T, SalesExecutiveFindFirstArgs<ExtArgs>>): Prisma__SalesExecutiveClient<$Result.GetResult<Prisma.$SalesExecutivePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SalesExecutive that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesExecutiveFindFirstOrThrowArgs} args - Arguments to find a SalesExecutive
     * @example
     * // Get one SalesExecutive
     * const salesExecutive = await prisma.salesExecutive.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SalesExecutiveFindFirstOrThrowArgs>(args?: SelectSubset<T, SalesExecutiveFindFirstOrThrowArgs<ExtArgs>>): Prisma__SalesExecutiveClient<$Result.GetResult<Prisma.$SalesExecutivePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SalesExecutives that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesExecutiveFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SalesExecutives
     * const salesExecutives = await prisma.salesExecutive.findMany()
     * 
     * // Get first 10 SalesExecutives
     * const salesExecutives = await prisma.salesExecutive.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const salesExecutiveWithUserIdOnly = await prisma.salesExecutive.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends SalesExecutiveFindManyArgs>(args?: SelectSubset<T, SalesExecutiveFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesExecutivePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SalesExecutive.
     * @param {SalesExecutiveCreateArgs} args - Arguments to create a SalesExecutive.
     * @example
     * // Create one SalesExecutive
     * const SalesExecutive = await prisma.salesExecutive.create({
     *   data: {
     *     // ... data to create a SalesExecutive
     *   }
     * })
     * 
     */
    create<T extends SalesExecutiveCreateArgs>(args: SelectSubset<T, SalesExecutiveCreateArgs<ExtArgs>>): Prisma__SalesExecutiveClient<$Result.GetResult<Prisma.$SalesExecutivePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SalesExecutives.
     * @param {SalesExecutiveCreateManyArgs} args - Arguments to create many SalesExecutives.
     * @example
     * // Create many SalesExecutives
     * const salesExecutive = await prisma.salesExecutive.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SalesExecutiveCreateManyArgs>(args?: SelectSubset<T, SalesExecutiveCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SalesExecutives and returns the data saved in the database.
     * @param {SalesExecutiveCreateManyAndReturnArgs} args - Arguments to create many SalesExecutives.
     * @example
     * // Create many SalesExecutives
     * const salesExecutive = await prisma.salesExecutive.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SalesExecutives and only return the `userId`
     * const salesExecutiveWithUserIdOnly = await prisma.salesExecutive.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SalesExecutiveCreateManyAndReturnArgs>(args?: SelectSubset<T, SalesExecutiveCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesExecutivePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SalesExecutive.
     * @param {SalesExecutiveDeleteArgs} args - Arguments to delete one SalesExecutive.
     * @example
     * // Delete one SalesExecutive
     * const SalesExecutive = await prisma.salesExecutive.delete({
     *   where: {
     *     // ... filter to delete one SalesExecutive
     *   }
     * })
     * 
     */
    delete<T extends SalesExecutiveDeleteArgs>(args: SelectSubset<T, SalesExecutiveDeleteArgs<ExtArgs>>): Prisma__SalesExecutiveClient<$Result.GetResult<Prisma.$SalesExecutivePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SalesExecutive.
     * @param {SalesExecutiveUpdateArgs} args - Arguments to update one SalesExecutive.
     * @example
     * // Update one SalesExecutive
     * const salesExecutive = await prisma.salesExecutive.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SalesExecutiveUpdateArgs>(args: SelectSubset<T, SalesExecutiveUpdateArgs<ExtArgs>>): Prisma__SalesExecutiveClient<$Result.GetResult<Prisma.$SalesExecutivePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SalesExecutives.
     * @param {SalesExecutiveDeleteManyArgs} args - Arguments to filter SalesExecutives to delete.
     * @example
     * // Delete a few SalesExecutives
     * const { count } = await prisma.salesExecutive.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SalesExecutiveDeleteManyArgs>(args?: SelectSubset<T, SalesExecutiveDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalesExecutives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesExecutiveUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SalesExecutives
     * const salesExecutive = await prisma.salesExecutive.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SalesExecutiveUpdateManyArgs>(args: SelectSubset<T, SalesExecutiveUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalesExecutives and returns the data updated in the database.
     * @param {SalesExecutiveUpdateManyAndReturnArgs} args - Arguments to update many SalesExecutives.
     * @example
     * // Update many SalesExecutives
     * const salesExecutive = await prisma.salesExecutive.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SalesExecutives and only return the `userId`
     * const salesExecutiveWithUserIdOnly = await prisma.salesExecutive.updateManyAndReturn({
     *   select: { userId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SalesExecutiveUpdateManyAndReturnArgs>(args: SelectSubset<T, SalesExecutiveUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesExecutivePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SalesExecutive.
     * @param {SalesExecutiveUpsertArgs} args - Arguments to update or create a SalesExecutive.
     * @example
     * // Update or create a SalesExecutive
     * const salesExecutive = await prisma.salesExecutive.upsert({
     *   create: {
     *     // ... data to create a SalesExecutive
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SalesExecutive we want to update
     *   }
     * })
     */
    upsert<T extends SalesExecutiveUpsertArgs>(args: SelectSubset<T, SalesExecutiveUpsertArgs<ExtArgs>>): Prisma__SalesExecutiveClient<$Result.GetResult<Prisma.$SalesExecutivePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SalesExecutives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesExecutiveCountArgs} args - Arguments to filter SalesExecutives to count.
     * @example
     * // Count the number of SalesExecutives
     * const count = await prisma.salesExecutive.count({
     *   where: {
     *     // ... the filter for the SalesExecutives we want to count
     *   }
     * })
    **/
    count<T extends SalesExecutiveCountArgs>(
      args?: Subset<T, SalesExecutiveCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SalesExecutiveCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SalesExecutive.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesExecutiveAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SalesExecutiveAggregateArgs>(args: Subset<T, SalesExecutiveAggregateArgs>): Prisma.PrismaPromise<GetSalesExecutiveAggregateType<T>>

    /**
     * Group by SalesExecutive.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesExecutiveGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SalesExecutiveGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SalesExecutiveGroupByArgs['orderBy'] }
        : { orderBy?: SalesExecutiveGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SalesExecutiveGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSalesExecutiveGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SalesExecutive model
   */
  readonly fields: SalesExecutiveFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SalesExecutive.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SalesExecutiveClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    bankDetails<T extends SalesExecutive$bankDetailsArgs<ExtArgs> = {}>(args?: Subset<T, SalesExecutive$bankDetailsArgs<ExtArgs>>): Prisma__BankDetailsClient<$Result.GetResult<Prisma.$BankDetailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SalesExecutive model
   */
  interface SalesExecutiveFieldRefs {
    readonly userId: FieldRef<"SalesExecutive", 'String'>
    readonly firstName: FieldRef<"SalesExecutive", 'String'>
    readonly lastName: FieldRef<"SalesExecutive", 'String'>
    readonly employeeId: FieldRef<"SalesExecutive", 'String'>
    readonly aadharId: FieldRef<"SalesExecutive", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SalesExecutive findUnique
   */
  export type SalesExecutiveFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesExecutive
     */
    select?: SalesExecutiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesExecutive
     */
    omit?: SalesExecutiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesExecutiveInclude<ExtArgs> | null
    /**
     * Filter, which SalesExecutive to fetch.
     */
    where: SalesExecutiveWhereUniqueInput
  }

  /**
   * SalesExecutive findUniqueOrThrow
   */
  export type SalesExecutiveFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesExecutive
     */
    select?: SalesExecutiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesExecutive
     */
    omit?: SalesExecutiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesExecutiveInclude<ExtArgs> | null
    /**
     * Filter, which SalesExecutive to fetch.
     */
    where: SalesExecutiveWhereUniqueInput
  }

  /**
   * SalesExecutive findFirst
   */
  export type SalesExecutiveFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesExecutive
     */
    select?: SalesExecutiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesExecutive
     */
    omit?: SalesExecutiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesExecutiveInclude<ExtArgs> | null
    /**
     * Filter, which SalesExecutive to fetch.
     */
    where?: SalesExecutiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesExecutives to fetch.
     */
    orderBy?: SalesExecutiveOrderByWithRelationInput | SalesExecutiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalesExecutives.
     */
    cursor?: SalesExecutiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesExecutives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesExecutives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalesExecutives.
     */
    distinct?: SalesExecutiveScalarFieldEnum | SalesExecutiveScalarFieldEnum[]
  }

  /**
   * SalesExecutive findFirstOrThrow
   */
  export type SalesExecutiveFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesExecutive
     */
    select?: SalesExecutiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesExecutive
     */
    omit?: SalesExecutiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesExecutiveInclude<ExtArgs> | null
    /**
     * Filter, which SalesExecutive to fetch.
     */
    where?: SalesExecutiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesExecutives to fetch.
     */
    orderBy?: SalesExecutiveOrderByWithRelationInput | SalesExecutiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalesExecutives.
     */
    cursor?: SalesExecutiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesExecutives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesExecutives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalesExecutives.
     */
    distinct?: SalesExecutiveScalarFieldEnum | SalesExecutiveScalarFieldEnum[]
  }

  /**
   * SalesExecutive findMany
   */
  export type SalesExecutiveFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesExecutive
     */
    select?: SalesExecutiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesExecutive
     */
    omit?: SalesExecutiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesExecutiveInclude<ExtArgs> | null
    /**
     * Filter, which SalesExecutives to fetch.
     */
    where?: SalesExecutiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesExecutives to fetch.
     */
    orderBy?: SalesExecutiveOrderByWithRelationInput | SalesExecutiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SalesExecutives.
     */
    cursor?: SalesExecutiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesExecutives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesExecutives.
     */
    skip?: number
    distinct?: SalesExecutiveScalarFieldEnum | SalesExecutiveScalarFieldEnum[]
  }

  /**
   * SalesExecutive create
   */
  export type SalesExecutiveCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesExecutive
     */
    select?: SalesExecutiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesExecutive
     */
    omit?: SalesExecutiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesExecutiveInclude<ExtArgs> | null
    /**
     * The data needed to create a SalesExecutive.
     */
    data: XOR<SalesExecutiveCreateInput, SalesExecutiveUncheckedCreateInput>
  }

  /**
   * SalesExecutive createMany
   */
  export type SalesExecutiveCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SalesExecutives.
     */
    data: SalesExecutiveCreateManyInput | SalesExecutiveCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SalesExecutive createManyAndReturn
   */
  export type SalesExecutiveCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesExecutive
     */
    select?: SalesExecutiveSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SalesExecutive
     */
    omit?: SalesExecutiveOmit<ExtArgs> | null
    /**
     * The data used to create many SalesExecutives.
     */
    data: SalesExecutiveCreateManyInput | SalesExecutiveCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesExecutiveIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SalesExecutive update
   */
  export type SalesExecutiveUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesExecutive
     */
    select?: SalesExecutiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesExecutive
     */
    omit?: SalesExecutiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesExecutiveInclude<ExtArgs> | null
    /**
     * The data needed to update a SalesExecutive.
     */
    data: XOR<SalesExecutiveUpdateInput, SalesExecutiveUncheckedUpdateInput>
    /**
     * Choose, which SalesExecutive to update.
     */
    where: SalesExecutiveWhereUniqueInput
  }

  /**
   * SalesExecutive updateMany
   */
  export type SalesExecutiveUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SalesExecutives.
     */
    data: XOR<SalesExecutiveUpdateManyMutationInput, SalesExecutiveUncheckedUpdateManyInput>
    /**
     * Filter which SalesExecutives to update
     */
    where?: SalesExecutiveWhereInput
    /**
     * Limit how many SalesExecutives to update.
     */
    limit?: number
  }

  /**
   * SalesExecutive updateManyAndReturn
   */
  export type SalesExecutiveUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesExecutive
     */
    select?: SalesExecutiveSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SalesExecutive
     */
    omit?: SalesExecutiveOmit<ExtArgs> | null
    /**
     * The data used to update SalesExecutives.
     */
    data: XOR<SalesExecutiveUpdateManyMutationInput, SalesExecutiveUncheckedUpdateManyInput>
    /**
     * Filter which SalesExecutives to update
     */
    where?: SalesExecutiveWhereInput
    /**
     * Limit how many SalesExecutives to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesExecutiveIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SalesExecutive upsert
   */
  export type SalesExecutiveUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesExecutive
     */
    select?: SalesExecutiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesExecutive
     */
    omit?: SalesExecutiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesExecutiveInclude<ExtArgs> | null
    /**
     * The filter to search for the SalesExecutive to update in case it exists.
     */
    where: SalesExecutiveWhereUniqueInput
    /**
     * In case the SalesExecutive found by the `where` argument doesn't exist, create a new SalesExecutive with this data.
     */
    create: XOR<SalesExecutiveCreateInput, SalesExecutiveUncheckedCreateInput>
    /**
     * In case the SalesExecutive was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SalesExecutiveUpdateInput, SalesExecutiveUncheckedUpdateInput>
  }

  /**
   * SalesExecutive delete
   */
  export type SalesExecutiveDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesExecutive
     */
    select?: SalesExecutiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesExecutive
     */
    omit?: SalesExecutiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesExecutiveInclude<ExtArgs> | null
    /**
     * Filter which SalesExecutive to delete.
     */
    where: SalesExecutiveWhereUniqueInput
  }

  /**
   * SalesExecutive deleteMany
   */
  export type SalesExecutiveDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalesExecutives to delete
     */
    where?: SalesExecutiveWhereInput
    /**
     * Limit how many SalesExecutives to delete.
     */
    limit?: number
  }

  /**
   * SalesExecutive.bankDetails
   */
  export type SalesExecutive$bankDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetails
     */
    select?: BankDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankDetails
     */
    omit?: BankDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankDetailsInclude<ExtArgs> | null
    where?: BankDetailsWhereInput
  }

  /**
   * SalesExecutive without action
   */
  export type SalesExecutiveDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesExecutive
     */
    select?: SalesExecutiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesExecutive
     */
    omit?: SalesExecutiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesExecutiveInclude<ExtArgs> | null
  }


  /**
   * Model Store
   */

  export type AggregateStore = {
    _count: StoreCountAggregateOutputType | null
    _min: StoreMinAggregateOutputType | null
    _max: StoreMaxAggregateOutputType | null
  }

  export type StoreMinAggregateOutputType = {
    userId: string | null
    storeId: string | null
    storeName: string | null
    ownerName: string | null
    ownerPhone: string | null
    ownerEmail: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StoreMaxAggregateOutputType = {
    userId: string | null
    storeId: string | null
    storeName: string | null
    ownerName: string | null
    ownerPhone: string | null
    ownerEmail: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StoreCountAggregateOutputType = {
    userId: number
    storeId: number
    storeName: number
    ownerName: number
    ownerPhone: number
    ownerEmail: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StoreMinAggregateInputType = {
    userId?: true
    storeId?: true
    storeName?: true
    ownerName?: true
    ownerPhone?: true
    ownerEmail?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StoreMaxAggregateInputType = {
    userId?: true
    storeId?: true
    storeName?: true
    ownerName?: true
    ownerPhone?: true
    ownerEmail?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StoreCountAggregateInputType = {
    userId?: true
    storeId?: true
    storeName?: true
    ownerName?: true
    ownerPhone?: true
    ownerEmail?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StoreAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Store to aggregate.
     */
    where?: StoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stores to fetch.
     */
    orderBy?: StoreOrderByWithRelationInput | StoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Stores
    **/
    _count?: true | StoreCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StoreMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StoreMaxAggregateInputType
  }

  export type GetStoreAggregateType<T extends StoreAggregateArgs> = {
        [P in keyof T & keyof AggregateStore]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStore[P]>
      : GetScalarType<T[P], AggregateStore[P]>
  }




  export type StoreGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoreWhereInput
    orderBy?: StoreOrderByWithAggregationInput | StoreOrderByWithAggregationInput[]
    by: StoreScalarFieldEnum[] | StoreScalarFieldEnum
    having?: StoreScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StoreCountAggregateInputType | true
    _min?: StoreMinAggregateInputType
    _max?: StoreMaxAggregateInputType
  }

  export type StoreGroupByOutputType = {
    userId: string
    storeId: string
    storeName: string
    ownerName: string
    ownerPhone: string
    ownerEmail: string
    createdAt: Date
    updatedAt: Date
    _count: StoreCountAggregateOutputType | null
    _min: StoreMinAggregateOutputType | null
    _max: StoreMaxAggregateOutputType | null
  }

  type GetStoreGroupByPayload<T extends StoreGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StoreGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StoreGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StoreGroupByOutputType[P]>
            : GetScalarType<T[P], StoreGroupByOutputType[P]>
        }
      >
    >


  export type StoreSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    storeId?: boolean
    storeName?: boolean
    ownerName?: boolean
    ownerPhone?: boolean
    ownerEmail?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    address?: boolean | Store$addressArgs<ExtArgs>
    bankDetails?: boolean | Store$bankDetailsArgs<ExtArgs>
  }, ExtArgs["result"]["store"]>

  export type StoreSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    storeId?: boolean
    storeName?: boolean
    ownerName?: boolean
    ownerPhone?: boolean
    ownerEmail?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["store"]>

  export type StoreSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    storeId?: boolean
    storeName?: boolean
    ownerName?: boolean
    ownerPhone?: boolean
    ownerEmail?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["store"]>

  export type StoreSelectScalar = {
    userId?: boolean
    storeId?: boolean
    storeName?: boolean
    ownerName?: boolean
    ownerPhone?: boolean
    ownerEmail?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StoreOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "storeId" | "storeName" | "ownerName" | "ownerPhone" | "ownerEmail" | "createdAt" | "updatedAt", ExtArgs["result"]["store"]>
  export type StoreInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    address?: boolean | Store$addressArgs<ExtArgs>
    bankDetails?: boolean | Store$bankDetailsArgs<ExtArgs>
  }
  export type StoreIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type StoreIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $StorePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Store"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      address: Prisma.$AddressPayload<ExtArgs> | null
      bankDetails: Prisma.$BankDetailsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      storeId: string
      storeName: string
      ownerName: string
      ownerPhone: string
      ownerEmail: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["store"]>
    composites: {}
  }

  type StoreGetPayload<S extends boolean | null | undefined | StoreDefaultArgs> = $Result.GetResult<Prisma.$StorePayload, S>

  type StoreCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StoreFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StoreCountAggregateInputType | true
    }

  export interface StoreDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Store'], meta: { name: 'Store' } }
    /**
     * Find zero or one Store that matches the filter.
     * @param {StoreFindUniqueArgs} args - Arguments to find a Store
     * @example
     * // Get one Store
     * const store = await prisma.store.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StoreFindUniqueArgs>(args: SelectSubset<T, StoreFindUniqueArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Store that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StoreFindUniqueOrThrowArgs} args - Arguments to find a Store
     * @example
     * // Get one Store
     * const store = await prisma.store.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StoreFindUniqueOrThrowArgs>(args: SelectSubset<T, StoreFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Store that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreFindFirstArgs} args - Arguments to find a Store
     * @example
     * // Get one Store
     * const store = await prisma.store.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StoreFindFirstArgs>(args?: SelectSubset<T, StoreFindFirstArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Store that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreFindFirstOrThrowArgs} args - Arguments to find a Store
     * @example
     * // Get one Store
     * const store = await prisma.store.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StoreFindFirstOrThrowArgs>(args?: SelectSubset<T, StoreFindFirstOrThrowArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Stores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Stores
     * const stores = await prisma.store.findMany()
     * 
     * // Get first 10 Stores
     * const stores = await prisma.store.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const storeWithUserIdOnly = await prisma.store.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends StoreFindManyArgs>(args?: SelectSubset<T, StoreFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Store.
     * @param {StoreCreateArgs} args - Arguments to create a Store.
     * @example
     * // Create one Store
     * const Store = await prisma.store.create({
     *   data: {
     *     // ... data to create a Store
     *   }
     * })
     * 
     */
    create<T extends StoreCreateArgs>(args: SelectSubset<T, StoreCreateArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Stores.
     * @param {StoreCreateManyArgs} args - Arguments to create many Stores.
     * @example
     * // Create many Stores
     * const store = await prisma.store.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StoreCreateManyArgs>(args?: SelectSubset<T, StoreCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Stores and returns the data saved in the database.
     * @param {StoreCreateManyAndReturnArgs} args - Arguments to create many Stores.
     * @example
     * // Create many Stores
     * const store = await prisma.store.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Stores and only return the `userId`
     * const storeWithUserIdOnly = await prisma.store.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StoreCreateManyAndReturnArgs>(args?: SelectSubset<T, StoreCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Store.
     * @param {StoreDeleteArgs} args - Arguments to delete one Store.
     * @example
     * // Delete one Store
     * const Store = await prisma.store.delete({
     *   where: {
     *     // ... filter to delete one Store
     *   }
     * })
     * 
     */
    delete<T extends StoreDeleteArgs>(args: SelectSubset<T, StoreDeleteArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Store.
     * @param {StoreUpdateArgs} args - Arguments to update one Store.
     * @example
     * // Update one Store
     * const store = await prisma.store.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StoreUpdateArgs>(args: SelectSubset<T, StoreUpdateArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Stores.
     * @param {StoreDeleteManyArgs} args - Arguments to filter Stores to delete.
     * @example
     * // Delete a few Stores
     * const { count } = await prisma.store.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StoreDeleteManyArgs>(args?: SelectSubset<T, StoreDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Stores
     * const store = await prisma.store.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StoreUpdateManyArgs>(args: SelectSubset<T, StoreUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stores and returns the data updated in the database.
     * @param {StoreUpdateManyAndReturnArgs} args - Arguments to update many Stores.
     * @example
     * // Update many Stores
     * const store = await prisma.store.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Stores and only return the `userId`
     * const storeWithUserIdOnly = await prisma.store.updateManyAndReturn({
     *   select: { userId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StoreUpdateManyAndReturnArgs>(args: SelectSubset<T, StoreUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Store.
     * @param {StoreUpsertArgs} args - Arguments to update or create a Store.
     * @example
     * // Update or create a Store
     * const store = await prisma.store.upsert({
     *   create: {
     *     // ... data to create a Store
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Store we want to update
     *   }
     * })
     */
    upsert<T extends StoreUpsertArgs>(args: SelectSubset<T, StoreUpsertArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Stores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreCountArgs} args - Arguments to filter Stores to count.
     * @example
     * // Count the number of Stores
     * const count = await prisma.store.count({
     *   where: {
     *     // ... the filter for the Stores we want to count
     *   }
     * })
    **/
    count<T extends StoreCountArgs>(
      args?: Subset<T, StoreCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StoreCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Store.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StoreAggregateArgs>(args: Subset<T, StoreAggregateArgs>): Prisma.PrismaPromise<GetStoreAggregateType<T>>

    /**
     * Group by Store.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StoreGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StoreGroupByArgs['orderBy'] }
        : { orderBy?: StoreGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StoreGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStoreGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Store model
   */
  readonly fields: StoreFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Store.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StoreClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    address<T extends Store$addressArgs<ExtArgs> = {}>(args?: Subset<T, Store$addressArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    bankDetails<T extends Store$bankDetailsArgs<ExtArgs> = {}>(args?: Subset<T, Store$bankDetailsArgs<ExtArgs>>): Prisma__BankDetailsClient<$Result.GetResult<Prisma.$BankDetailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Store model
   */
  interface StoreFieldRefs {
    readonly userId: FieldRef<"Store", 'String'>
    readonly storeId: FieldRef<"Store", 'String'>
    readonly storeName: FieldRef<"Store", 'String'>
    readonly ownerName: FieldRef<"Store", 'String'>
    readonly ownerPhone: FieldRef<"Store", 'String'>
    readonly ownerEmail: FieldRef<"Store", 'String'>
    readonly createdAt: FieldRef<"Store", 'DateTime'>
    readonly updatedAt: FieldRef<"Store", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Store findUnique
   */
  export type StoreFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * Filter, which Store to fetch.
     */
    where: StoreWhereUniqueInput
  }

  /**
   * Store findUniqueOrThrow
   */
  export type StoreFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * Filter, which Store to fetch.
     */
    where: StoreWhereUniqueInput
  }

  /**
   * Store findFirst
   */
  export type StoreFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * Filter, which Store to fetch.
     */
    where?: StoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stores to fetch.
     */
    orderBy?: StoreOrderByWithRelationInput | StoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stores.
     */
    cursor?: StoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stores.
     */
    distinct?: StoreScalarFieldEnum | StoreScalarFieldEnum[]
  }

  /**
   * Store findFirstOrThrow
   */
  export type StoreFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * Filter, which Store to fetch.
     */
    where?: StoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stores to fetch.
     */
    orderBy?: StoreOrderByWithRelationInput | StoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stores.
     */
    cursor?: StoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stores.
     */
    distinct?: StoreScalarFieldEnum | StoreScalarFieldEnum[]
  }

  /**
   * Store findMany
   */
  export type StoreFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * Filter, which Stores to fetch.
     */
    where?: StoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stores to fetch.
     */
    orderBy?: StoreOrderByWithRelationInput | StoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Stores.
     */
    cursor?: StoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stores.
     */
    skip?: number
    distinct?: StoreScalarFieldEnum | StoreScalarFieldEnum[]
  }

  /**
   * Store create
   */
  export type StoreCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * The data needed to create a Store.
     */
    data: XOR<StoreCreateInput, StoreUncheckedCreateInput>
  }

  /**
   * Store createMany
   */
  export type StoreCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Stores.
     */
    data: StoreCreateManyInput | StoreCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Store createManyAndReturn
   */
  export type StoreCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * The data used to create many Stores.
     */
    data: StoreCreateManyInput | StoreCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Store update
   */
  export type StoreUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * The data needed to update a Store.
     */
    data: XOR<StoreUpdateInput, StoreUncheckedUpdateInput>
    /**
     * Choose, which Store to update.
     */
    where: StoreWhereUniqueInput
  }

  /**
   * Store updateMany
   */
  export type StoreUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Stores.
     */
    data: XOR<StoreUpdateManyMutationInput, StoreUncheckedUpdateManyInput>
    /**
     * Filter which Stores to update
     */
    where?: StoreWhereInput
    /**
     * Limit how many Stores to update.
     */
    limit?: number
  }

  /**
   * Store updateManyAndReturn
   */
  export type StoreUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * The data used to update Stores.
     */
    data: XOR<StoreUpdateManyMutationInput, StoreUncheckedUpdateManyInput>
    /**
     * Filter which Stores to update
     */
    where?: StoreWhereInput
    /**
     * Limit how many Stores to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Store upsert
   */
  export type StoreUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * The filter to search for the Store to update in case it exists.
     */
    where: StoreWhereUniqueInput
    /**
     * In case the Store found by the `where` argument doesn't exist, create a new Store with this data.
     */
    create: XOR<StoreCreateInput, StoreUncheckedCreateInput>
    /**
     * In case the Store was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StoreUpdateInput, StoreUncheckedUpdateInput>
  }

  /**
   * Store delete
   */
  export type StoreDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * Filter which Store to delete.
     */
    where: StoreWhereUniqueInput
  }

  /**
   * Store deleteMany
   */
  export type StoreDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Stores to delete
     */
    where?: StoreWhereInput
    /**
     * Limit how many Stores to delete.
     */
    limit?: number
  }

  /**
   * Store.address
   */
  export type Store$addressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    where?: AddressWhereInput
  }

  /**
   * Store.bankDetails
   */
  export type Store$bankDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetails
     */
    select?: BankDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankDetails
     */
    omit?: BankDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankDetailsInclude<ExtArgs> | null
    where?: BankDetailsWhereInput
  }

  /**
   * Store without action
   */
  export type StoreDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
  }


  /**
   * Model BankDetails
   */

  export type AggregateBankDetails = {
    _count: BankDetailsCountAggregateOutputType | null
    _min: BankDetailsMinAggregateOutputType | null
    _max: BankDetailsMaxAggregateOutputType | null
  }

  export type BankDetailsMinAggregateOutputType = {
    id: string | null
    accountNumber: string | null
    ifsc: string | null
    bankName: string | null
    beneficiaryName: string | null
    upiId: string | null
    managerId: string | null
    technicianId: string | null
    fieldExecId: string | null
    salesExecId: string | null
    storeId: string | null
  }

  export type BankDetailsMaxAggregateOutputType = {
    id: string | null
    accountNumber: string | null
    ifsc: string | null
    bankName: string | null
    beneficiaryName: string | null
    upiId: string | null
    managerId: string | null
    technicianId: string | null
    fieldExecId: string | null
    salesExecId: string | null
    storeId: string | null
  }

  export type BankDetailsCountAggregateOutputType = {
    id: number
    accountNumber: number
    ifsc: number
    bankName: number
    beneficiaryName: number
    upiId: number
    managerId: number
    technicianId: number
    fieldExecId: number
    salesExecId: number
    storeId: number
    _all: number
  }


  export type BankDetailsMinAggregateInputType = {
    id?: true
    accountNumber?: true
    ifsc?: true
    bankName?: true
    beneficiaryName?: true
    upiId?: true
    managerId?: true
    technicianId?: true
    fieldExecId?: true
    salesExecId?: true
    storeId?: true
  }

  export type BankDetailsMaxAggregateInputType = {
    id?: true
    accountNumber?: true
    ifsc?: true
    bankName?: true
    beneficiaryName?: true
    upiId?: true
    managerId?: true
    technicianId?: true
    fieldExecId?: true
    salesExecId?: true
    storeId?: true
  }

  export type BankDetailsCountAggregateInputType = {
    id?: true
    accountNumber?: true
    ifsc?: true
    bankName?: true
    beneficiaryName?: true
    upiId?: true
    managerId?: true
    technicianId?: true
    fieldExecId?: true
    salesExecId?: true
    storeId?: true
    _all?: true
  }

  export type BankDetailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BankDetails to aggregate.
     */
    where?: BankDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankDetails to fetch.
     */
    orderBy?: BankDetailsOrderByWithRelationInput | BankDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BankDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BankDetails
    **/
    _count?: true | BankDetailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BankDetailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BankDetailsMaxAggregateInputType
  }

  export type GetBankDetailsAggregateType<T extends BankDetailsAggregateArgs> = {
        [P in keyof T & keyof AggregateBankDetails]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBankDetails[P]>
      : GetScalarType<T[P], AggregateBankDetails[P]>
  }




  export type BankDetailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BankDetailsWhereInput
    orderBy?: BankDetailsOrderByWithAggregationInput | BankDetailsOrderByWithAggregationInput[]
    by: BankDetailsScalarFieldEnum[] | BankDetailsScalarFieldEnum
    having?: BankDetailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BankDetailsCountAggregateInputType | true
    _min?: BankDetailsMinAggregateInputType
    _max?: BankDetailsMaxAggregateInputType
  }

  export type BankDetailsGroupByOutputType = {
    id: string
    accountNumber: string | null
    ifsc: string | null
    bankName: string | null
    beneficiaryName: string | null
    upiId: string | null
    managerId: string | null
    technicianId: string | null
    fieldExecId: string | null
    salesExecId: string | null
    storeId: string | null
    _count: BankDetailsCountAggregateOutputType | null
    _min: BankDetailsMinAggregateOutputType | null
    _max: BankDetailsMaxAggregateOutputType | null
  }

  type GetBankDetailsGroupByPayload<T extends BankDetailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BankDetailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BankDetailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BankDetailsGroupByOutputType[P]>
            : GetScalarType<T[P], BankDetailsGroupByOutputType[P]>
        }
      >
    >


  export type BankDetailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountNumber?: boolean
    ifsc?: boolean
    bankName?: boolean
    beneficiaryName?: boolean
    upiId?: boolean
    managerId?: boolean
    technicianId?: boolean
    fieldExecId?: boolean
    salesExecId?: boolean
    storeId?: boolean
    manager?: boolean | BankDetails$managerArgs<ExtArgs>
    technician?: boolean | BankDetails$technicianArgs<ExtArgs>
    fieldExecutive?: boolean | BankDetails$fieldExecutiveArgs<ExtArgs>
    salesExecutive?: boolean | BankDetails$salesExecutiveArgs<ExtArgs>
    store?: boolean | BankDetails$storeArgs<ExtArgs>
  }, ExtArgs["result"]["bankDetails"]>

  export type BankDetailsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountNumber?: boolean
    ifsc?: boolean
    bankName?: boolean
    beneficiaryName?: boolean
    upiId?: boolean
    managerId?: boolean
    technicianId?: boolean
    fieldExecId?: boolean
    salesExecId?: boolean
    storeId?: boolean
    manager?: boolean | BankDetails$managerArgs<ExtArgs>
    technician?: boolean | BankDetails$technicianArgs<ExtArgs>
    fieldExecutive?: boolean | BankDetails$fieldExecutiveArgs<ExtArgs>
    salesExecutive?: boolean | BankDetails$salesExecutiveArgs<ExtArgs>
    store?: boolean | BankDetails$storeArgs<ExtArgs>
  }, ExtArgs["result"]["bankDetails"]>

  export type BankDetailsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountNumber?: boolean
    ifsc?: boolean
    bankName?: boolean
    beneficiaryName?: boolean
    upiId?: boolean
    managerId?: boolean
    technicianId?: boolean
    fieldExecId?: boolean
    salesExecId?: boolean
    storeId?: boolean
    manager?: boolean | BankDetails$managerArgs<ExtArgs>
    technician?: boolean | BankDetails$technicianArgs<ExtArgs>
    fieldExecutive?: boolean | BankDetails$fieldExecutiveArgs<ExtArgs>
    salesExecutive?: boolean | BankDetails$salesExecutiveArgs<ExtArgs>
    store?: boolean | BankDetails$storeArgs<ExtArgs>
  }, ExtArgs["result"]["bankDetails"]>

  export type BankDetailsSelectScalar = {
    id?: boolean
    accountNumber?: boolean
    ifsc?: boolean
    bankName?: boolean
    beneficiaryName?: boolean
    upiId?: boolean
    managerId?: boolean
    technicianId?: boolean
    fieldExecId?: boolean
    salesExecId?: boolean
    storeId?: boolean
  }

  export type BankDetailsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "accountNumber" | "ifsc" | "bankName" | "beneficiaryName" | "upiId" | "managerId" | "technicianId" | "fieldExecId" | "salesExecId" | "storeId", ExtArgs["result"]["bankDetails"]>
  export type BankDetailsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    manager?: boolean | BankDetails$managerArgs<ExtArgs>
    technician?: boolean | BankDetails$technicianArgs<ExtArgs>
    fieldExecutive?: boolean | BankDetails$fieldExecutiveArgs<ExtArgs>
    salesExecutive?: boolean | BankDetails$salesExecutiveArgs<ExtArgs>
    store?: boolean | BankDetails$storeArgs<ExtArgs>
  }
  export type BankDetailsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    manager?: boolean | BankDetails$managerArgs<ExtArgs>
    technician?: boolean | BankDetails$technicianArgs<ExtArgs>
    fieldExecutive?: boolean | BankDetails$fieldExecutiveArgs<ExtArgs>
    salesExecutive?: boolean | BankDetails$salesExecutiveArgs<ExtArgs>
    store?: boolean | BankDetails$storeArgs<ExtArgs>
  }
  export type BankDetailsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    manager?: boolean | BankDetails$managerArgs<ExtArgs>
    technician?: boolean | BankDetails$technicianArgs<ExtArgs>
    fieldExecutive?: boolean | BankDetails$fieldExecutiveArgs<ExtArgs>
    salesExecutive?: boolean | BankDetails$salesExecutiveArgs<ExtArgs>
    store?: boolean | BankDetails$storeArgs<ExtArgs>
  }

  export type $BankDetailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BankDetails"
    objects: {
      manager: Prisma.$ManagerPayload<ExtArgs> | null
      technician: Prisma.$TechnicianPayload<ExtArgs> | null
      fieldExecutive: Prisma.$FieldExecutivePayload<ExtArgs> | null
      salesExecutive: Prisma.$SalesExecutivePayload<ExtArgs> | null
      store: Prisma.$StorePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      accountNumber: string | null
      ifsc: string | null
      bankName: string | null
      beneficiaryName: string | null
      upiId: string | null
      managerId: string | null
      technicianId: string | null
      fieldExecId: string | null
      salesExecId: string | null
      storeId: string | null
    }, ExtArgs["result"]["bankDetails"]>
    composites: {}
  }

  type BankDetailsGetPayload<S extends boolean | null | undefined | BankDetailsDefaultArgs> = $Result.GetResult<Prisma.$BankDetailsPayload, S>

  type BankDetailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BankDetailsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BankDetailsCountAggregateInputType | true
    }

  export interface BankDetailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BankDetails'], meta: { name: 'BankDetails' } }
    /**
     * Find zero or one BankDetails that matches the filter.
     * @param {BankDetailsFindUniqueArgs} args - Arguments to find a BankDetails
     * @example
     * // Get one BankDetails
     * const bankDetails = await prisma.bankDetails.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BankDetailsFindUniqueArgs>(args: SelectSubset<T, BankDetailsFindUniqueArgs<ExtArgs>>): Prisma__BankDetailsClient<$Result.GetResult<Prisma.$BankDetailsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BankDetails that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BankDetailsFindUniqueOrThrowArgs} args - Arguments to find a BankDetails
     * @example
     * // Get one BankDetails
     * const bankDetails = await prisma.bankDetails.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BankDetailsFindUniqueOrThrowArgs>(args: SelectSubset<T, BankDetailsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BankDetailsClient<$Result.GetResult<Prisma.$BankDetailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BankDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankDetailsFindFirstArgs} args - Arguments to find a BankDetails
     * @example
     * // Get one BankDetails
     * const bankDetails = await prisma.bankDetails.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BankDetailsFindFirstArgs>(args?: SelectSubset<T, BankDetailsFindFirstArgs<ExtArgs>>): Prisma__BankDetailsClient<$Result.GetResult<Prisma.$BankDetailsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BankDetails that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankDetailsFindFirstOrThrowArgs} args - Arguments to find a BankDetails
     * @example
     * // Get one BankDetails
     * const bankDetails = await prisma.bankDetails.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BankDetailsFindFirstOrThrowArgs>(args?: SelectSubset<T, BankDetailsFindFirstOrThrowArgs<ExtArgs>>): Prisma__BankDetailsClient<$Result.GetResult<Prisma.$BankDetailsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BankDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankDetailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BankDetails
     * const bankDetails = await prisma.bankDetails.findMany()
     * 
     * // Get first 10 BankDetails
     * const bankDetails = await prisma.bankDetails.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bankDetailsWithIdOnly = await prisma.bankDetails.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BankDetailsFindManyArgs>(args?: SelectSubset<T, BankDetailsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BankDetailsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BankDetails.
     * @param {BankDetailsCreateArgs} args - Arguments to create a BankDetails.
     * @example
     * // Create one BankDetails
     * const BankDetails = await prisma.bankDetails.create({
     *   data: {
     *     // ... data to create a BankDetails
     *   }
     * })
     * 
     */
    create<T extends BankDetailsCreateArgs>(args: SelectSubset<T, BankDetailsCreateArgs<ExtArgs>>): Prisma__BankDetailsClient<$Result.GetResult<Prisma.$BankDetailsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BankDetails.
     * @param {BankDetailsCreateManyArgs} args - Arguments to create many BankDetails.
     * @example
     * // Create many BankDetails
     * const bankDetails = await prisma.bankDetails.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BankDetailsCreateManyArgs>(args?: SelectSubset<T, BankDetailsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BankDetails and returns the data saved in the database.
     * @param {BankDetailsCreateManyAndReturnArgs} args - Arguments to create many BankDetails.
     * @example
     * // Create many BankDetails
     * const bankDetails = await prisma.bankDetails.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BankDetails and only return the `id`
     * const bankDetailsWithIdOnly = await prisma.bankDetails.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BankDetailsCreateManyAndReturnArgs>(args?: SelectSubset<T, BankDetailsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BankDetailsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BankDetails.
     * @param {BankDetailsDeleteArgs} args - Arguments to delete one BankDetails.
     * @example
     * // Delete one BankDetails
     * const BankDetails = await prisma.bankDetails.delete({
     *   where: {
     *     // ... filter to delete one BankDetails
     *   }
     * })
     * 
     */
    delete<T extends BankDetailsDeleteArgs>(args: SelectSubset<T, BankDetailsDeleteArgs<ExtArgs>>): Prisma__BankDetailsClient<$Result.GetResult<Prisma.$BankDetailsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BankDetails.
     * @param {BankDetailsUpdateArgs} args - Arguments to update one BankDetails.
     * @example
     * // Update one BankDetails
     * const bankDetails = await prisma.bankDetails.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BankDetailsUpdateArgs>(args: SelectSubset<T, BankDetailsUpdateArgs<ExtArgs>>): Prisma__BankDetailsClient<$Result.GetResult<Prisma.$BankDetailsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BankDetails.
     * @param {BankDetailsDeleteManyArgs} args - Arguments to filter BankDetails to delete.
     * @example
     * // Delete a few BankDetails
     * const { count } = await prisma.bankDetails.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BankDetailsDeleteManyArgs>(args?: SelectSubset<T, BankDetailsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BankDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankDetailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BankDetails
     * const bankDetails = await prisma.bankDetails.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BankDetailsUpdateManyArgs>(args: SelectSubset<T, BankDetailsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BankDetails and returns the data updated in the database.
     * @param {BankDetailsUpdateManyAndReturnArgs} args - Arguments to update many BankDetails.
     * @example
     * // Update many BankDetails
     * const bankDetails = await prisma.bankDetails.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BankDetails and only return the `id`
     * const bankDetailsWithIdOnly = await prisma.bankDetails.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BankDetailsUpdateManyAndReturnArgs>(args: SelectSubset<T, BankDetailsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BankDetailsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BankDetails.
     * @param {BankDetailsUpsertArgs} args - Arguments to update or create a BankDetails.
     * @example
     * // Update or create a BankDetails
     * const bankDetails = await prisma.bankDetails.upsert({
     *   create: {
     *     // ... data to create a BankDetails
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BankDetails we want to update
     *   }
     * })
     */
    upsert<T extends BankDetailsUpsertArgs>(args: SelectSubset<T, BankDetailsUpsertArgs<ExtArgs>>): Prisma__BankDetailsClient<$Result.GetResult<Prisma.$BankDetailsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BankDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankDetailsCountArgs} args - Arguments to filter BankDetails to count.
     * @example
     * // Count the number of BankDetails
     * const count = await prisma.bankDetails.count({
     *   where: {
     *     // ... the filter for the BankDetails we want to count
     *   }
     * })
    **/
    count<T extends BankDetailsCountArgs>(
      args?: Subset<T, BankDetailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BankDetailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BankDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankDetailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BankDetailsAggregateArgs>(args: Subset<T, BankDetailsAggregateArgs>): Prisma.PrismaPromise<GetBankDetailsAggregateType<T>>

    /**
     * Group by BankDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankDetailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BankDetailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BankDetailsGroupByArgs['orderBy'] }
        : { orderBy?: BankDetailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BankDetailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBankDetailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BankDetails model
   */
  readonly fields: BankDetailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BankDetails.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BankDetailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    manager<T extends BankDetails$managerArgs<ExtArgs> = {}>(args?: Subset<T, BankDetails$managerArgs<ExtArgs>>): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    technician<T extends BankDetails$technicianArgs<ExtArgs> = {}>(args?: Subset<T, BankDetails$technicianArgs<ExtArgs>>): Prisma__TechnicianClient<$Result.GetResult<Prisma.$TechnicianPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    fieldExecutive<T extends BankDetails$fieldExecutiveArgs<ExtArgs> = {}>(args?: Subset<T, BankDetails$fieldExecutiveArgs<ExtArgs>>): Prisma__FieldExecutiveClient<$Result.GetResult<Prisma.$FieldExecutivePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    salesExecutive<T extends BankDetails$salesExecutiveArgs<ExtArgs> = {}>(args?: Subset<T, BankDetails$salesExecutiveArgs<ExtArgs>>): Prisma__SalesExecutiveClient<$Result.GetResult<Prisma.$SalesExecutivePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    store<T extends BankDetails$storeArgs<ExtArgs> = {}>(args?: Subset<T, BankDetails$storeArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BankDetails model
   */
  interface BankDetailsFieldRefs {
    readonly id: FieldRef<"BankDetails", 'String'>
    readonly accountNumber: FieldRef<"BankDetails", 'String'>
    readonly ifsc: FieldRef<"BankDetails", 'String'>
    readonly bankName: FieldRef<"BankDetails", 'String'>
    readonly beneficiaryName: FieldRef<"BankDetails", 'String'>
    readonly upiId: FieldRef<"BankDetails", 'String'>
    readonly managerId: FieldRef<"BankDetails", 'String'>
    readonly technicianId: FieldRef<"BankDetails", 'String'>
    readonly fieldExecId: FieldRef<"BankDetails", 'String'>
    readonly salesExecId: FieldRef<"BankDetails", 'String'>
    readonly storeId: FieldRef<"BankDetails", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BankDetails findUnique
   */
  export type BankDetailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetails
     */
    select?: BankDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankDetails
     */
    omit?: BankDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankDetailsInclude<ExtArgs> | null
    /**
     * Filter, which BankDetails to fetch.
     */
    where: BankDetailsWhereUniqueInput
  }

  /**
   * BankDetails findUniqueOrThrow
   */
  export type BankDetailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetails
     */
    select?: BankDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankDetails
     */
    omit?: BankDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankDetailsInclude<ExtArgs> | null
    /**
     * Filter, which BankDetails to fetch.
     */
    where: BankDetailsWhereUniqueInput
  }

  /**
   * BankDetails findFirst
   */
  export type BankDetailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetails
     */
    select?: BankDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankDetails
     */
    omit?: BankDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankDetailsInclude<ExtArgs> | null
    /**
     * Filter, which BankDetails to fetch.
     */
    where?: BankDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankDetails to fetch.
     */
    orderBy?: BankDetailsOrderByWithRelationInput | BankDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BankDetails.
     */
    cursor?: BankDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BankDetails.
     */
    distinct?: BankDetailsScalarFieldEnum | BankDetailsScalarFieldEnum[]
  }

  /**
   * BankDetails findFirstOrThrow
   */
  export type BankDetailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetails
     */
    select?: BankDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankDetails
     */
    omit?: BankDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankDetailsInclude<ExtArgs> | null
    /**
     * Filter, which BankDetails to fetch.
     */
    where?: BankDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankDetails to fetch.
     */
    orderBy?: BankDetailsOrderByWithRelationInput | BankDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BankDetails.
     */
    cursor?: BankDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BankDetails.
     */
    distinct?: BankDetailsScalarFieldEnum | BankDetailsScalarFieldEnum[]
  }

  /**
   * BankDetails findMany
   */
  export type BankDetailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetails
     */
    select?: BankDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankDetails
     */
    omit?: BankDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankDetailsInclude<ExtArgs> | null
    /**
     * Filter, which BankDetails to fetch.
     */
    where?: BankDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankDetails to fetch.
     */
    orderBy?: BankDetailsOrderByWithRelationInput | BankDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BankDetails.
     */
    cursor?: BankDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankDetails.
     */
    skip?: number
    distinct?: BankDetailsScalarFieldEnum | BankDetailsScalarFieldEnum[]
  }

  /**
   * BankDetails create
   */
  export type BankDetailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetails
     */
    select?: BankDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankDetails
     */
    omit?: BankDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankDetailsInclude<ExtArgs> | null
    /**
     * The data needed to create a BankDetails.
     */
    data?: XOR<BankDetailsCreateInput, BankDetailsUncheckedCreateInput>
  }

  /**
   * BankDetails createMany
   */
  export type BankDetailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BankDetails.
     */
    data: BankDetailsCreateManyInput | BankDetailsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BankDetails createManyAndReturn
   */
  export type BankDetailsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetails
     */
    select?: BankDetailsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BankDetails
     */
    omit?: BankDetailsOmit<ExtArgs> | null
    /**
     * The data used to create many BankDetails.
     */
    data: BankDetailsCreateManyInput | BankDetailsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankDetailsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BankDetails update
   */
  export type BankDetailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetails
     */
    select?: BankDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankDetails
     */
    omit?: BankDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankDetailsInclude<ExtArgs> | null
    /**
     * The data needed to update a BankDetails.
     */
    data: XOR<BankDetailsUpdateInput, BankDetailsUncheckedUpdateInput>
    /**
     * Choose, which BankDetails to update.
     */
    where: BankDetailsWhereUniqueInput
  }

  /**
   * BankDetails updateMany
   */
  export type BankDetailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BankDetails.
     */
    data: XOR<BankDetailsUpdateManyMutationInput, BankDetailsUncheckedUpdateManyInput>
    /**
     * Filter which BankDetails to update
     */
    where?: BankDetailsWhereInput
    /**
     * Limit how many BankDetails to update.
     */
    limit?: number
  }

  /**
   * BankDetails updateManyAndReturn
   */
  export type BankDetailsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetails
     */
    select?: BankDetailsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BankDetails
     */
    omit?: BankDetailsOmit<ExtArgs> | null
    /**
     * The data used to update BankDetails.
     */
    data: XOR<BankDetailsUpdateManyMutationInput, BankDetailsUncheckedUpdateManyInput>
    /**
     * Filter which BankDetails to update
     */
    where?: BankDetailsWhereInput
    /**
     * Limit how many BankDetails to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankDetailsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BankDetails upsert
   */
  export type BankDetailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetails
     */
    select?: BankDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankDetails
     */
    omit?: BankDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankDetailsInclude<ExtArgs> | null
    /**
     * The filter to search for the BankDetails to update in case it exists.
     */
    where: BankDetailsWhereUniqueInput
    /**
     * In case the BankDetails found by the `where` argument doesn't exist, create a new BankDetails with this data.
     */
    create: XOR<BankDetailsCreateInput, BankDetailsUncheckedCreateInput>
    /**
     * In case the BankDetails was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BankDetailsUpdateInput, BankDetailsUncheckedUpdateInput>
  }

  /**
   * BankDetails delete
   */
  export type BankDetailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetails
     */
    select?: BankDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankDetails
     */
    omit?: BankDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankDetailsInclude<ExtArgs> | null
    /**
     * Filter which BankDetails to delete.
     */
    where: BankDetailsWhereUniqueInput
  }

  /**
   * BankDetails deleteMany
   */
  export type BankDetailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BankDetails to delete
     */
    where?: BankDetailsWhereInput
    /**
     * Limit how many BankDetails to delete.
     */
    limit?: number
  }

  /**
   * BankDetails.manager
   */
  export type BankDetails$managerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manager
     */
    omit?: ManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
    where?: ManagerWhereInput
  }

  /**
   * BankDetails.technician
   */
  export type BankDetails$technicianArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Technician
     */
    select?: TechnicianSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Technician
     */
    omit?: TechnicianOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicianInclude<ExtArgs> | null
    where?: TechnicianWhereInput
  }

  /**
   * BankDetails.fieldExecutive
   */
  export type BankDetails$fieldExecutiveArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldExecutive
     */
    select?: FieldExecutiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldExecutive
     */
    omit?: FieldExecutiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldExecutiveInclude<ExtArgs> | null
    where?: FieldExecutiveWhereInput
  }

  /**
   * BankDetails.salesExecutive
   */
  export type BankDetails$salesExecutiveArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesExecutive
     */
    select?: SalesExecutiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesExecutive
     */
    omit?: SalesExecutiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesExecutiveInclude<ExtArgs> | null
    where?: SalesExecutiveWhereInput
  }

  /**
   * BankDetails.store
   */
  export type BankDetails$storeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    where?: StoreWhereInput
  }

  /**
   * BankDetails without action
   */
  export type BankDetailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetails
     */
    select?: BankDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankDetails
     */
    omit?: BankDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankDetailsInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _avg: SessionAvgAggregateOutputType | null
    _sum: SessionSumAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionAvgAggregateOutputType = {
    latitude: number | null
    longitude: number | null
  }

  export type SessionSumAggregateOutputType = {
    latitude: number | null
    longitude: number | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    expiresAt: Date | null
    createdAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    device: string | null
    browser: string | null
    os: string | null
    location: string | null
    latitude: number | null
    longitude: number | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    expiresAt: Date | null
    createdAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    device: string | null
    browser: string | null
    os: string | null
    location: string | null
    latitude: number | null
    longitude: number | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    userId: number
    expiresAt: number
    createdAt: number
    ipAddress: number
    userAgent: number
    device: number
    browser: number
    os: number
    location: number
    latitude: number
    longitude: number
    _all: number
  }


  export type SessionAvgAggregateInputType = {
    latitude?: true
    longitude?: true
  }

  export type SessionSumAggregateInputType = {
    latitude?: true
    longitude?: true
  }

  export type SessionMinAggregateInputType = {
    id?: true
    userId?: true
    expiresAt?: true
    createdAt?: true
    ipAddress?: true
    userAgent?: true
    device?: true
    browser?: true
    os?: true
    location?: true
    latitude?: true
    longitude?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    userId?: true
    expiresAt?: true
    createdAt?: true
    ipAddress?: true
    userAgent?: true
    device?: true
    browser?: true
    os?: true
    location?: true
    latitude?: true
    longitude?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    userId?: true
    expiresAt?: true
    createdAt?: true
    ipAddress?: true
    userAgent?: true
    device?: true
    browser?: true
    os?: true
    location?: true
    latitude?: true
    longitude?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _avg?: SessionAvgAggregateInputType
    _sum?: SessionSumAggregateInputType
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    userId: string
    expiresAt: Date
    createdAt: Date
    ipAddress: string | null
    userAgent: string | null
    device: string | null
    browser: string | null
    os: string | null
    location: string | null
    latitude: number | null
    longitude: number | null
    _count: SessionCountAggregateOutputType | null
    _avg: SessionAvgAggregateOutputType | null
    _sum: SessionSumAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    device?: boolean
    browser?: boolean
    os?: boolean
    location?: boolean
    latitude?: boolean
    longitude?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    device?: boolean
    browser?: boolean
    os?: boolean
    location?: boolean
    latitude?: boolean
    longitude?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    device?: boolean
    browser?: boolean
    os?: boolean
    location?: boolean
    latitude?: boolean
    longitude?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    userId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    device?: boolean
    browser?: boolean
    os?: boolean
    location?: boolean
    latitude?: boolean
    longitude?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "expiresAt" | "createdAt" | "ipAddress" | "userAgent" | "device" | "browser" | "os" | "location" | "latitude" | "longitude", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      expiresAt: Date
      createdAt: Date
      ipAddress: string | null
      userAgent: string | null
      device: string | null
      browser: string | null
      os: string | null
      location: string | null
      latitude: number | null
      longitude: number | null
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly expiresAt: FieldRef<"Session", 'DateTime'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
    readonly ipAddress: FieldRef<"Session", 'String'>
    readonly userAgent: FieldRef<"Session", 'String'>
    readonly device: FieldRef<"Session", 'String'>
    readonly browser: FieldRef<"Session", 'String'>
    readonly os: FieldRef<"Session", 'String'>
    readonly location: FieldRef<"Session", 'String'>
    readonly latitude: FieldRef<"Session", 'Float'>
    readonly longitude: FieldRef<"Session", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    body: string | null
    read: boolean | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    body: string | null
    read: boolean | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    body: number
    read: number
    createdAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    body?: true
    read?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    body?: true
    read?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    body?: true
    read?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    userId: string
    title: string
    body: string
    read: boolean
    createdAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    body?: boolean
    read?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    body?: boolean
    read?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    body?: boolean
    read?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    body?: boolean
    read?: boolean
    createdAt?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "title" | "body" | "read" | "createdAt", ExtArgs["result"]["notification"]>

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      title: string
      body: string
      read: boolean
      createdAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly body: FieldRef<"Notification", 'String'>
    readonly read: FieldRef<"Notification", 'Boolean'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
  }


  /**
   * Model DeviceTest
   */

  export type AggregateDeviceTest = {
    _count: DeviceTestCountAggregateOutputType | null
    _min: DeviceTestMinAggregateOutputType | null
    _max: DeviceTestMaxAggregateOutputType | null
  }

  export type DeviceTestMinAggregateOutputType = {
    id: string | null
    testId: string | null
    employeeId: string | null
    imageUrl: string | null
    expiresAt: Date | null
    imei1: string | null
    imei2: string | null
    createdAt: Date | null
  }

  export type DeviceTestMaxAggregateOutputType = {
    id: string | null
    testId: string | null
    employeeId: string | null
    imageUrl: string | null
    expiresAt: Date | null
    imei1: string | null
    imei2: string | null
    createdAt: Date | null
  }

  export type DeviceTestCountAggregateOutputType = {
    id: number
    testId: number
    employeeId: number
    imageUrl: number
    expiresAt: number
    device: number
    imei1: number
    imei2: number
    createdAt: number
    _all: number
  }


  export type DeviceTestMinAggregateInputType = {
    id?: true
    testId?: true
    employeeId?: true
    imageUrl?: true
    expiresAt?: true
    imei1?: true
    imei2?: true
    createdAt?: true
  }

  export type DeviceTestMaxAggregateInputType = {
    id?: true
    testId?: true
    employeeId?: true
    imageUrl?: true
    expiresAt?: true
    imei1?: true
    imei2?: true
    createdAt?: true
  }

  export type DeviceTestCountAggregateInputType = {
    id?: true
    testId?: true
    employeeId?: true
    imageUrl?: true
    expiresAt?: true
    device?: true
    imei1?: true
    imei2?: true
    createdAt?: true
    _all?: true
  }

  export type DeviceTestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeviceTest to aggregate.
     */
    where?: DeviceTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceTests to fetch.
     */
    orderBy?: DeviceTestOrderByWithRelationInput | DeviceTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeviceTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceTests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeviceTests
    **/
    _count?: true | DeviceTestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeviceTestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeviceTestMaxAggregateInputType
  }

  export type GetDeviceTestAggregateType<T extends DeviceTestAggregateArgs> = {
        [P in keyof T & keyof AggregateDeviceTest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeviceTest[P]>
      : GetScalarType<T[P], AggregateDeviceTest[P]>
  }




  export type DeviceTestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceTestWhereInput
    orderBy?: DeviceTestOrderByWithAggregationInput | DeviceTestOrderByWithAggregationInput[]
    by: DeviceTestScalarFieldEnum[] | DeviceTestScalarFieldEnum
    having?: DeviceTestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeviceTestCountAggregateInputType | true
    _min?: DeviceTestMinAggregateInputType
    _max?: DeviceTestMaxAggregateInputType
  }

  export type DeviceTestGroupByOutputType = {
    id: string
    testId: string
    employeeId: string | null
    imageUrl: string | null
    expiresAt: Date
    device: JsonValue
    imei1: string | null
    imei2: string | null
    createdAt: Date
    _count: DeviceTestCountAggregateOutputType | null
    _min: DeviceTestMinAggregateOutputType | null
    _max: DeviceTestMaxAggregateOutputType | null
  }

  type GetDeviceTestGroupByPayload<T extends DeviceTestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeviceTestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeviceTestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeviceTestGroupByOutputType[P]>
            : GetScalarType<T[P], DeviceTestGroupByOutputType[P]>
        }
      >
    >


  export type DeviceTestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    testId?: boolean
    employeeId?: boolean
    imageUrl?: boolean
    expiresAt?: boolean
    device?: boolean
    imei1?: boolean
    imei2?: boolean
    createdAt?: boolean
    connectivityTestResults?: boolean | DeviceTest$connectivityTestResultsArgs<ExtArgs>
    simTestResults?: boolean | DeviceTest$simTestResultsArgs<ExtArgs>
    deviceTestResults?: boolean | DeviceTest$deviceTestResultsArgs<ExtArgs>
    screenTest?: boolean | DeviceTest$screenTestArgs<ExtArgs>
    audioTest?: boolean | DeviceTest$audioTestArgs<ExtArgs>
    proximitySensorTest?: boolean | DeviceTest$proximitySensorTestArgs<ExtArgs>
    cameraTest?: boolean | DeviceTest$cameraTestArgs<ExtArgs>
    fingerprintTest?: boolean | DeviceTest$fingerprintTestArgs<ExtArgs>
    usbTest?: boolean | DeviceTest$usbTestArgs<ExtArgs>
    audioJackTest?: boolean | DeviceTest$audioJackTestArgs<ExtArgs>
    _count?: boolean | DeviceTestCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deviceTest"]>

  export type DeviceTestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    testId?: boolean
    employeeId?: boolean
    imageUrl?: boolean
    expiresAt?: boolean
    device?: boolean
    imei1?: boolean
    imei2?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["deviceTest"]>

  export type DeviceTestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    testId?: boolean
    employeeId?: boolean
    imageUrl?: boolean
    expiresAt?: boolean
    device?: boolean
    imei1?: boolean
    imei2?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["deviceTest"]>

  export type DeviceTestSelectScalar = {
    id?: boolean
    testId?: boolean
    employeeId?: boolean
    imageUrl?: boolean
    expiresAt?: boolean
    device?: boolean
    imei1?: boolean
    imei2?: boolean
    createdAt?: boolean
  }

  export type DeviceTestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "testId" | "employeeId" | "imageUrl" | "expiresAt" | "device" | "imei1" | "imei2" | "createdAt", ExtArgs["result"]["deviceTest"]>
  export type DeviceTestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    connectivityTestResults?: boolean | DeviceTest$connectivityTestResultsArgs<ExtArgs>
    simTestResults?: boolean | DeviceTest$simTestResultsArgs<ExtArgs>
    deviceTestResults?: boolean | DeviceTest$deviceTestResultsArgs<ExtArgs>
    screenTest?: boolean | DeviceTest$screenTestArgs<ExtArgs>
    audioTest?: boolean | DeviceTest$audioTestArgs<ExtArgs>
    proximitySensorTest?: boolean | DeviceTest$proximitySensorTestArgs<ExtArgs>
    cameraTest?: boolean | DeviceTest$cameraTestArgs<ExtArgs>
    fingerprintTest?: boolean | DeviceTest$fingerprintTestArgs<ExtArgs>
    usbTest?: boolean | DeviceTest$usbTestArgs<ExtArgs>
    audioJackTest?: boolean | DeviceTest$audioJackTestArgs<ExtArgs>
    _count?: boolean | DeviceTestCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DeviceTestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type DeviceTestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DeviceTestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeviceTest"
    objects: {
      connectivityTestResults: Prisma.$ConnectivityTestResultPayload<ExtArgs>[]
      simTestResults: Prisma.$SimTestResultPayload<ExtArgs>[]
      deviceTestResults: Prisma.$DeviceTestResultPayload<ExtArgs>[]
      screenTest: Prisma.$ScreenTestPayload<ExtArgs> | null
      audioTest: Prisma.$AudioTestPayload<ExtArgs> | null
      proximitySensorTest: Prisma.$ProximitySensorTestPayload<ExtArgs> | null
      cameraTest: Prisma.$CameraTestPayload<ExtArgs> | null
      fingerprintTest: Prisma.$FingerprintTestPayload<ExtArgs> | null
      usbTest: Prisma.$UsbTestPayload<ExtArgs> | null
      audioJackTest: Prisma.$AudioJackTestPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      testId: string
      employeeId: string | null
      imageUrl: string | null
      expiresAt: Date
      device: Prisma.JsonValue
      imei1: string | null
      imei2: string | null
      createdAt: Date
    }, ExtArgs["result"]["deviceTest"]>
    composites: {}
  }

  type DeviceTestGetPayload<S extends boolean | null | undefined | DeviceTestDefaultArgs> = $Result.GetResult<Prisma.$DeviceTestPayload, S>

  type DeviceTestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeviceTestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeviceTestCountAggregateInputType | true
    }

  export interface DeviceTestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeviceTest'], meta: { name: 'DeviceTest' } }
    /**
     * Find zero or one DeviceTest that matches the filter.
     * @param {DeviceTestFindUniqueArgs} args - Arguments to find a DeviceTest
     * @example
     * // Get one DeviceTest
     * const deviceTest = await prisma.deviceTest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeviceTestFindUniqueArgs>(args: SelectSubset<T, DeviceTestFindUniqueArgs<ExtArgs>>): Prisma__DeviceTestClient<$Result.GetResult<Prisma.$DeviceTestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DeviceTest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeviceTestFindUniqueOrThrowArgs} args - Arguments to find a DeviceTest
     * @example
     * // Get one DeviceTest
     * const deviceTest = await prisma.deviceTest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeviceTestFindUniqueOrThrowArgs>(args: SelectSubset<T, DeviceTestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeviceTestClient<$Result.GetResult<Prisma.$DeviceTestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeviceTest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceTestFindFirstArgs} args - Arguments to find a DeviceTest
     * @example
     * // Get one DeviceTest
     * const deviceTest = await prisma.deviceTest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeviceTestFindFirstArgs>(args?: SelectSubset<T, DeviceTestFindFirstArgs<ExtArgs>>): Prisma__DeviceTestClient<$Result.GetResult<Prisma.$DeviceTestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeviceTest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceTestFindFirstOrThrowArgs} args - Arguments to find a DeviceTest
     * @example
     * // Get one DeviceTest
     * const deviceTest = await prisma.deviceTest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeviceTestFindFirstOrThrowArgs>(args?: SelectSubset<T, DeviceTestFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeviceTestClient<$Result.GetResult<Prisma.$DeviceTestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DeviceTests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceTestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeviceTests
     * const deviceTests = await prisma.deviceTest.findMany()
     * 
     * // Get first 10 DeviceTests
     * const deviceTests = await prisma.deviceTest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deviceTestWithIdOnly = await prisma.deviceTest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeviceTestFindManyArgs>(args?: SelectSubset<T, DeviceTestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceTestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DeviceTest.
     * @param {DeviceTestCreateArgs} args - Arguments to create a DeviceTest.
     * @example
     * // Create one DeviceTest
     * const DeviceTest = await prisma.deviceTest.create({
     *   data: {
     *     // ... data to create a DeviceTest
     *   }
     * })
     * 
     */
    create<T extends DeviceTestCreateArgs>(args: SelectSubset<T, DeviceTestCreateArgs<ExtArgs>>): Prisma__DeviceTestClient<$Result.GetResult<Prisma.$DeviceTestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DeviceTests.
     * @param {DeviceTestCreateManyArgs} args - Arguments to create many DeviceTests.
     * @example
     * // Create many DeviceTests
     * const deviceTest = await prisma.deviceTest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeviceTestCreateManyArgs>(args?: SelectSubset<T, DeviceTestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DeviceTests and returns the data saved in the database.
     * @param {DeviceTestCreateManyAndReturnArgs} args - Arguments to create many DeviceTests.
     * @example
     * // Create many DeviceTests
     * const deviceTest = await prisma.deviceTest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DeviceTests and only return the `id`
     * const deviceTestWithIdOnly = await prisma.deviceTest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeviceTestCreateManyAndReturnArgs>(args?: SelectSubset<T, DeviceTestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceTestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DeviceTest.
     * @param {DeviceTestDeleteArgs} args - Arguments to delete one DeviceTest.
     * @example
     * // Delete one DeviceTest
     * const DeviceTest = await prisma.deviceTest.delete({
     *   where: {
     *     // ... filter to delete one DeviceTest
     *   }
     * })
     * 
     */
    delete<T extends DeviceTestDeleteArgs>(args: SelectSubset<T, DeviceTestDeleteArgs<ExtArgs>>): Prisma__DeviceTestClient<$Result.GetResult<Prisma.$DeviceTestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DeviceTest.
     * @param {DeviceTestUpdateArgs} args - Arguments to update one DeviceTest.
     * @example
     * // Update one DeviceTest
     * const deviceTest = await prisma.deviceTest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeviceTestUpdateArgs>(args: SelectSubset<T, DeviceTestUpdateArgs<ExtArgs>>): Prisma__DeviceTestClient<$Result.GetResult<Prisma.$DeviceTestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DeviceTests.
     * @param {DeviceTestDeleteManyArgs} args - Arguments to filter DeviceTests to delete.
     * @example
     * // Delete a few DeviceTests
     * const { count } = await prisma.deviceTest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeviceTestDeleteManyArgs>(args?: SelectSubset<T, DeviceTestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeviceTests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceTestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeviceTests
     * const deviceTest = await prisma.deviceTest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeviceTestUpdateManyArgs>(args: SelectSubset<T, DeviceTestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeviceTests and returns the data updated in the database.
     * @param {DeviceTestUpdateManyAndReturnArgs} args - Arguments to update many DeviceTests.
     * @example
     * // Update many DeviceTests
     * const deviceTest = await prisma.deviceTest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DeviceTests and only return the `id`
     * const deviceTestWithIdOnly = await prisma.deviceTest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DeviceTestUpdateManyAndReturnArgs>(args: SelectSubset<T, DeviceTestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceTestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DeviceTest.
     * @param {DeviceTestUpsertArgs} args - Arguments to update or create a DeviceTest.
     * @example
     * // Update or create a DeviceTest
     * const deviceTest = await prisma.deviceTest.upsert({
     *   create: {
     *     // ... data to create a DeviceTest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeviceTest we want to update
     *   }
     * })
     */
    upsert<T extends DeviceTestUpsertArgs>(args: SelectSubset<T, DeviceTestUpsertArgs<ExtArgs>>): Prisma__DeviceTestClient<$Result.GetResult<Prisma.$DeviceTestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DeviceTests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceTestCountArgs} args - Arguments to filter DeviceTests to count.
     * @example
     * // Count the number of DeviceTests
     * const count = await prisma.deviceTest.count({
     *   where: {
     *     // ... the filter for the DeviceTests we want to count
     *   }
     * })
    **/
    count<T extends DeviceTestCountArgs>(
      args?: Subset<T, DeviceTestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeviceTestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeviceTest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceTestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeviceTestAggregateArgs>(args: Subset<T, DeviceTestAggregateArgs>): Prisma.PrismaPromise<GetDeviceTestAggregateType<T>>

    /**
     * Group by DeviceTest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceTestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeviceTestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeviceTestGroupByArgs['orderBy'] }
        : { orderBy?: DeviceTestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeviceTestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeviceTestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeviceTest model
   */
  readonly fields: DeviceTestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeviceTest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeviceTestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    connectivityTestResults<T extends DeviceTest$connectivityTestResultsArgs<ExtArgs> = {}>(args?: Subset<T, DeviceTest$connectivityTestResultsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConnectivityTestResultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    simTestResults<T extends DeviceTest$simTestResultsArgs<ExtArgs> = {}>(args?: Subset<T, DeviceTest$simTestResultsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SimTestResultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    deviceTestResults<T extends DeviceTest$deviceTestResultsArgs<ExtArgs> = {}>(args?: Subset<T, DeviceTest$deviceTestResultsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceTestResultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    screenTest<T extends DeviceTest$screenTestArgs<ExtArgs> = {}>(args?: Subset<T, DeviceTest$screenTestArgs<ExtArgs>>): Prisma__ScreenTestClient<$Result.GetResult<Prisma.$ScreenTestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    audioTest<T extends DeviceTest$audioTestArgs<ExtArgs> = {}>(args?: Subset<T, DeviceTest$audioTestArgs<ExtArgs>>): Prisma__AudioTestClient<$Result.GetResult<Prisma.$AudioTestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    proximitySensorTest<T extends DeviceTest$proximitySensorTestArgs<ExtArgs> = {}>(args?: Subset<T, DeviceTest$proximitySensorTestArgs<ExtArgs>>): Prisma__ProximitySensorTestClient<$Result.GetResult<Prisma.$ProximitySensorTestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    cameraTest<T extends DeviceTest$cameraTestArgs<ExtArgs> = {}>(args?: Subset<T, DeviceTest$cameraTestArgs<ExtArgs>>): Prisma__CameraTestClient<$Result.GetResult<Prisma.$CameraTestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    fingerprintTest<T extends DeviceTest$fingerprintTestArgs<ExtArgs> = {}>(args?: Subset<T, DeviceTest$fingerprintTestArgs<ExtArgs>>): Prisma__FingerprintTestClient<$Result.GetResult<Prisma.$FingerprintTestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    usbTest<T extends DeviceTest$usbTestArgs<ExtArgs> = {}>(args?: Subset<T, DeviceTest$usbTestArgs<ExtArgs>>): Prisma__UsbTestClient<$Result.GetResult<Prisma.$UsbTestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    audioJackTest<T extends DeviceTest$audioJackTestArgs<ExtArgs> = {}>(args?: Subset<T, DeviceTest$audioJackTestArgs<ExtArgs>>): Prisma__AudioJackTestClient<$Result.GetResult<Prisma.$AudioJackTestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeviceTest model
   */
  interface DeviceTestFieldRefs {
    readonly id: FieldRef<"DeviceTest", 'String'>
    readonly testId: FieldRef<"DeviceTest", 'String'>
    readonly employeeId: FieldRef<"DeviceTest", 'String'>
    readonly imageUrl: FieldRef<"DeviceTest", 'String'>
    readonly expiresAt: FieldRef<"DeviceTest", 'DateTime'>
    readonly device: FieldRef<"DeviceTest", 'Json'>
    readonly imei1: FieldRef<"DeviceTest", 'String'>
    readonly imei2: FieldRef<"DeviceTest", 'String'>
    readonly createdAt: FieldRef<"DeviceTest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DeviceTest findUnique
   */
  export type DeviceTestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceTest
     */
    select?: DeviceTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceTest
     */
    omit?: DeviceTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTestInclude<ExtArgs> | null
    /**
     * Filter, which DeviceTest to fetch.
     */
    where: DeviceTestWhereUniqueInput
  }

  /**
   * DeviceTest findUniqueOrThrow
   */
  export type DeviceTestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceTest
     */
    select?: DeviceTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceTest
     */
    omit?: DeviceTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTestInclude<ExtArgs> | null
    /**
     * Filter, which DeviceTest to fetch.
     */
    where: DeviceTestWhereUniqueInput
  }

  /**
   * DeviceTest findFirst
   */
  export type DeviceTestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceTest
     */
    select?: DeviceTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceTest
     */
    omit?: DeviceTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTestInclude<ExtArgs> | null
    /**
     * Filter, which DeviceTest to fetch.
     */
    where?: DeviceTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceTests to fetch.
     */
    orderBy?: DeviceTestOrderByWithRelationInput | DeviceTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeviceTests.
     */
    cursor?: DeviceTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceTests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeviceTests.
     */
    distinct?: DeviceTestScalarFieldEnum | DeviceTestScalarFieldEnum[]
  }

  /**
   * DeviceTest findFirstOrThrow
   */
  export type DeviceTestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceTest
     */
    select?: DeviceTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceTest
     */
    omit?: DeviceTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTestInclude<ExtArgs> | null
    /**
     * Filter, which DeviceTest to fetch.
     */
    where?: DeviceTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceTests to fetch.
     */
    orderBy?: DeviceTestOrderByWithRelationInput | DeviceTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeviceTests.
     */
    cursor?: DeviceTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceTests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeviceTests.
     */
    distinct?: DeviceTestScalarFieldEnum | DeviceTestScalarFieldEnum[]
  }

  /**
   * DeviceTest findMany
   */
  export type DeviceTestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceTest
     */
    select?: DeviceTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceTest
     */
    omit?: DeviceTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTestInclude<ExtArgs> | null
    /**
     * Filter, which DeviceTests to fetch.
     */
    where?: DeviceTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceTests to fetch.
     */
    orderBy?: DeviceTestOrderByWithRelationInput | DeviceTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeviceTests.
     */
    cursor?: DeviceTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceTests.
     */
    skip?: number
    distinct?: DeviceTestScalarFieldEnum | DeviceTestScalarFieldEnum[]
  }

  /**
   * DeviceTest create
   */
  export type DeviceTestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceTest
     */
    select?: DeviceTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceTest
     */
    omit?: DeviceTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTestInclude<ExtArgs> | null
    /**
     * The data needed to create a DeviceTest.
     */
    data: XOR<DeviceTestCreateInput, DeviceTestUncheckedCreateInput>
  }

  /**
   * DeviceTest createMany
   */
  export type DeviceTestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeviceTests.
     */
    data: DeviceTestCreateManyInput | DeviceTestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeviceTest createManyAndReturn
   */
  export type DeviceTestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceTest
     */
    select?: DeviceTestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceTest
     */
    omit?: DeviceTestOmit<ExtArgs> | null
    /**
     * The data used to create many DeviceTests.
     */
    data: DeviceTestCreateManyInput | DeviceTestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeviceTest update
   */
  export type DeviceTestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceTest
     */
    select?: DeviceTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceTest
     */
    omit?: DeviceTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTestInclude<ExtArgs> | null
    /**
     * The data needed to update a DeviceTest.
     */
    data: XOR<DeviceTestUpdateInput, DeviceTestUncheckedUpdateInput>
    /**
     * Choose, which DeviceTest to update.
     */
    where: DeviceTestWhereUniqueInput
  }

  /**
   * DeviceTest updateMany
   */
  export type DeviceTestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeviceTests.
     */
    data: XOR<DeviceTestUpdateManyMutationInput, DeviceTestUncheckedUpdateManyInput>
    /**
     * Filter which DeviceTests to update
     */
    where?: DeviceTestWhereInput
    /**
     * Limit how many DeviceTests to update.
     */
    limit?: number
  }

  /**
   * DeviceTest updateManyAndReturn
   */
  export type DeviceTestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceTest
     */
    select?: DeviceTestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceTest
     */
    omit?: DeviceTestOmit<ExtArgs> | null
    /**
     * The data used to update DeviceTests.
     */
    data: XOR<DeviceTestUpdateManyMutationInput, DeviceTestUncheckedUpdateManyInput>
    /**
     * Filter which DeviceTests to update
     */
    where?: DeviceTestWhereInput
    /**
     * Limit how many DeviceTests to update.
     */
    limit?: number
  }

  /**
   * DeviceTest upsert
   */
  export type DeviceTestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceTest
     */
    select?: DeviceTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceTest
     */
    omit?: DeviceTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTestInclude<ExtArgs> | null
    /**
     * The filter to search for the DeviceTest to update in case it exists.
     */
    where: DeviceTestWhereUniqueInput
    /**
     * In case the DeviceTest found by the `where` argument doesn't exist, create a new DeviceTest with this data.
     */
    create: XOR<DeviceTestCreateInput, DeviceTestUncheckedCreateInput>
    /**
     * In case the DeviceTest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeviceTestUpdateInput, DeviceTestUncheckedUpdateInput>
  }

  /**
   * DeviceTest delete
   */
  export type DeviceTestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceTest
     */
    select?: DeviceTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceTest
     */
    omit?: DeviceTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTestInclude<ExtArgs> | null
    /**
     * Filter which DeviceTest to delete.
     */
    where: DeviceTestWhereUniqueInput
  }

  /**
   * DeviceTest deleteMany
   */
  export type DeviceTestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeviceTests to delete
     */
    where?: DeviceTestWhereInput
    /**
     * Limit how many DeviceTests to delete.
     */
    limit?: number
  }

  /**
   * DeviceTest.connectivityTestResults
   */
  export type DeviceTest$connectivityTestResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConnectivityTestResult
     */
    select?: ConnectivityTestResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConnectivityTestResult
     */
    omit?: ConnectivityTestResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectivityTestResultInclude<ExtArgs> | null
    where?: ConnectivityTestResultWhereInput
    orderBy?: ConnectivityTestResultOrderByWithRelationInput | ConnectivityTestResultOrderByWithRelationInput[]
    cursor?: ConnectivityTestResultWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConnectivityTestResultScalarFieldEnum | ConnectivityTestResultScalarFieldEnum[]
  }

  /**
   * DeviceTest.simTestResults
   */
  export type DeviceTest$simTestResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimTestResult
     */
    select?: SimTestResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SimTestResult
     */
    omit?: SimTestResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimTestResultInclude<ExtArgs> | null
    where?: SimTestResultWhereInput
    orderBy?: SimTestResultOrderByWithRelationInput | SimTestResultOrderByWithRelationInput[]
    cursor?: SimTestResultWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SimTestResultScalarFieldEnum | SimTestResultScalarFieldEnum[]
  }

  /**
   * DeviceTest.deviceTestResults
   */
  export type DeviceTest$deviceTestResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceTestResult
     */
    select?: DeviceTestResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceTestResult
     */
    omit?: DeviceTestResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTestResultInclude<ExtArgs> | null
    where?: DeviceTestResultWhereInput
    orderBy?: DeviceTestResultOrderByWithRelationInput | DeviceTestResultOrderByWithRelationInput[]
    cursor?: DeviceTestResultWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeviceTestResultScalarFieldEnum | DeviceTestResultScalarFieldEnum[]
  }

  /**
   * DeviceTest.screenTest
   */
  export type DeviceTest$screenTestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScreenTest
     */
    select?: ScreenTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScreenTest
     */
    omit?: ScreenTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenTestInclude<ExtArgs> | null
    where?: ScreenTestWhereInput
  }

  /**
   * DeviceTest.audioTest
   */
  export type DeviceTest$audioTestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioTest
     */
    select?: AudioTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AudioTest
     */
    omit?: AudioTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioTestInclude<ExtArgs> | null
    where?: AudioTestWhereInput
  }

  /**
   * DeviceTest.proximitySensorTest
   */
  export type DeviceTest$proximitySensorTestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProximitySensorTest
     */
    select?: ProximitySensorTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProximitySensorTest
     */
    omit?: ProximitySensorTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProximitySensorTestInclude<ExtArgs> | null
    where?: ProximitySensorTestWhereInput
  }

  /**
   * DeviceTest.cameraTest
   */
  export type DeviceTest$cameraTestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CameraTest
     */
    select?: CameraTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CameraTest
     */
    omit?: CameraTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CameraTestInclude<ExtArgs> | null
    where?: CameraTestWhereInput
  }

  /**
   * DeviceTest.fingerprintTest
   */
  export type DeviceTest$fingerprintTestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FingerprintTest
     */
    select?: FingerprintTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FingerprintTest
     */
    omit?: FingerprintTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FingerprintTestInclude<ExtArgs> | null
    where?: FingerprintTestWhereInput
  }

  /**
   * DeviceTest.usbTest
   */
  export type DeviceTest$usbTestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsbTest
     */
    select?: UsbTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsbTest
     */
    omit?: UsbTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsbTestInclude<ExtArgs> | null
    where?: UsbTestWhereInput
  }

  /**
   * DeviceTest.audioJackTest
   */
  export type DeviceTest$audioJackTestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioJackTest
     */
    select?: AudioJackTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AudioJackTest
     */
    omit?: AudioJackTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioJackTestInclude<ExtArgs> | null
    where?: AudioJackTestWhereInput
  }

  /**
   * DeviceTest without action
   */
  export type DeviceTestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceTest
     */
    select?: DeviceTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceTest
     */
    omit?: DeviceTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTestInclude<ExtArgs> | null
  }


  /**
   * Model ConnectivityTestResult
   */

  export type AggregateConnectivityTestResult = {
    _count: ConnectivityTestResultCountAggregateOutputType | null
    _min: ConnectivityTestResultMinAggregateOutputType | null
    _max: ConnectivityTestResultMaxAggregateOutputType | null
  }

  export type ConnectivityTestResultMinAggregateOutputType = {
    id: string | null
    name: string | null
    status: boolean | null
    message: string | null
    timestamp: Date | null
    deviceTestId: string | null
  }

  export type ConnectivityTestResultMaxAggregateOutputType = {
    id: string | null
    name: string | null
    status: boolean | null
    message: string | null
    timestamp: Date | null
    deviceTestId: string | null
  }

  export type ConnectivityTestResultCountAggregateOutputType = {
    id: number
    name: number
    status: number
    message: number
    timestamp: number
    deviceTestId: number
    _all: number
  }


  export type ConnectivityTestResultMinAggregateInputType = {
    id?: true
    name?: true
    status?: true
    message?: true
    timestamp?: true
    deviceTestId?: true
  }

  export type ConnectivityTestResultMaxAggregateInputType = {
    id?: true
    name?: true
    status?: true
    message?: true
    timestamp?: true
    deviceTestId?: true
  }

  export type ConnectivityTestResultCountAggregateInputType = {
    id?: true
    name?: true
    status?: true
    message?: true
    timestamp?: true
    deviceTestId?: true
    _all?: true
  }

  export type ConnectivityTestResultAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConnectivityTestResult to aggregate.
     */
    where?: ConnectivityTestResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConnectivityTestResults to fetch.
     */
    orderBy?: ConnectivityTestResultOrderByWithRelationInput | ConnectivityTestResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConnectivityTestResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConnectivityTestResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConnectivityTestResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConnectivityTestResults
    **/
    _count?: true | ConnectivityTestResultCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConnectivityTestResultMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConnectivityTestResultMaxAggregateInputType
  }

  export type GetConnectivityTestResultAggregateType<T extends ConnectivityTestResultAggregateArgs> = {
        [P in keyof T & keyof AggregateConnectivityTestResult]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConnectivityTestResult[P]>
      : GetScalarType<T[P], AggregateConnectivityTestResult[P]>
  }




  export type ConnectivityTestResultGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConnectivityTestResultWhereInput
    orderBy?: ConnectivityTestResultOrderByWithAggregationInput | ConnectivityTestResultOrderByWithAggregationInput[]
    by: ConnectivityTestResultScalarFieldEnum[] | ConnectivityTestResultScalarFieldEnum
    having?: ConnectivityTestResultScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConnectivityTestResultCountAggregateInputType | true
    _min?: ConnectivityTestResultMinAggregateInputType
    _max?: ConnectivityTestResultMaxAggregateInputType
  }

  export type ConnectivityTestResultGroupByOutputType = {
    id: string
    name: string
    status: boolean
    message: string | null
    timestamp: Date | null
    deviceTestId: string
    _count: ConnectivityTestResultCountAggregateOutputType | null
    _min: ConnectivityTestResultMinAggregateOutputType | null
    _max: ConnectivityTestResultMaxAggregateOutputType | null
  }

  type GetConnectivityTestResultGroupByPayload<T extends ConnectivityTestResultGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConnectivityTestResultGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConnectivityTestResultGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConnectivityTestResultGroupByOutputType[P]>
            : GetScalarType<T[P], ConnectivityTestResultGroupByOutputType[P]>
        }
      >
    >


  export type ConnectivityTestResultSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    status?: boolean
    message?: boolean
    timestamp?: boolean
    deviceTestId?: boolean
    deviceTest?: boolean | DeviceTestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["connectivityTestResult"]>

  export type ConnectivityTestResultSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    status?: boolean
    message?: boolean
    timestamp?: boolean
    deviceTestId?: boolean
    deviceTest?: boolean | DeviceTestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["connectivityTestResult"]>

  export type ConnectivityTestResultSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    status?: boolean
    message?: boolean
    timestamp?: boolean
    deviceTestId?: boolean
    deviceTest?: boolean | DeviceTestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["connectivityTestResult"]>

  export type ConnectivityTestResultSelectScalar = {
    id?: boolean
    name?: boolean
    status?: boolean
    message?: boolean
    timestamp?: boolean
    deviceTestId?: boolean
  }

  export type ConnectivityTestResultOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "status" | "message" | "timestamp" | "deviceTestId", ExtArgs["result"]["connectivityTestResult"]>
  export type ConnectivityTestResultInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deviceTest?: boolean | DeviceTestDefaultArgs<ExtArgs>
  }
  export type ConnectivityTestResultIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deviceTest?: boolean | DeviceTestDefaultArgs<ExtArgs>
  }
  export type ConnectivityTestResultIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deviceTest?: boolean | DeviceTestDefaultArgs<ExtArgs>
  }

  export type $ConnectivityTestResultPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConnectivityTestResult"
    objects: {
      deviceTest: Prisma.$DeviceTestPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      status: boolean
      message: string | null
      timestamp: Date | null
      deviceTestId: string
    }, ExtArgs["result"]["connectivityTestResult"]>
    composites: {}
  }

  type ConnectivityTestResultGetPayload<S extends boolean | null | undefined | ConnectivityTestResultDefaultArgs> = $Result.GetResult<Prisma.$ConnectivityTestResultPayload, S>

  type ConnectivityTestResultCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConnectivityTestResultFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConnectivityTestResultCountAggregateInputType | true
    }

  export interface ConnectivityTestResultDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConnectivityTestResult'], meta: { name: 'ConnectivityTestResult' } }
    /**
     * Find zero or one ConnectivityTestResult that matches the filter.
     * @param {ConnectivityTestResultFindUniqueArgs} args - Arguments to find a ConnectivityTestResult
     * @example
     * // Get one ConnectivityTestResult
     * const connectivityTestResult = await prisma.connectivityTestResult.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConnectivityTestResultFindUniqueArgs>(args: SelectSubset<T, ConnectivityTestResultFindUniqueArgs<ExtArgs>>): Prisma__ConnectivityTestResultClient<$Result.GetResult<Prisma.$ConnectivityTestResultPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ConnectivityTestResult that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConnectivityTestResultFindUniqueOrThrowArgs} args - Arguments to find a ConnectivityTestResult
     * @example
     * // Get one ConnectivityTestResult
     * const connectivityTestResult = await prisma.connectivityTestResult.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConnectivityTestResultFindUniqueOrThrowArgs>(args: SelectSubset<T, ConnectivityTestResultFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConnectivityTestResultClient<$Result.GetResult<Prisma.$ConnectivityTestResultPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConnectivityTestResult that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectivityTestResultFindFirstArgs} args - Arguments to find a ConnectivityTestResult
     * @example
     * // Get one ConnectivityTestResult
     * const connectivityTestResult = await prisma.connectivityTestResult.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConnectivityTestResultFindFirstArgs>(args?: SelectSubset<T, ConnectivityTestResultFindFirstArgs<ExtArgs>>): Prisma__ConnectivityTestResultClient<$Result.GetResult<Prisma.$ConnectivityTestResultPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConnectivityTestResult that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectivityTestResultFindFirstOrThrowArgs} args - Arguments to find a ConnectivityTestResult
     * @example
     * // Get one ConnectivityTestResult
     * const connectivityTestResult = await prisma.connectivityTestResult.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConnectivityTestResultFindFirstOrThrowArgs>(args?: SelectSubset<T, ConnectivityTestResultFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConnectivityTestResultClient<$Result.GetResult<Prisma.$ConnectivityTestResultPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ConnectivityTestResults that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectivityTestResultFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConnectivityTestResults
     * const connectivityTestResults = await prisma.connectivityTestResult.findMany()
     * 
     * // Get first 10 ConnectivityTestResults
     * const connectivityTestResults = await prisma.connectivityTestResult.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const connectivityTestResultWithIdOnly = await prisma.connectivityTestResult.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConnectivityTestResultFindManyArgs>(args?: SelectSubset<T, ConnectivityTestResultFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConnectivityTestResultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ConnectivityTestResult.
     * @param {ConnectivityTestResultCreateArgs} args - Arguments to create a ConnectivityTestResult.
     * @example
     * // Create one ConnectivityTestResult
     * const ConnectivityTestResult = await prisma.connectivityTestResult.create({
     *   data: {
     *     // ... data to create a ConnectivityTestResult
     *   }
     * })
     * 
     */
    create<T extends ConnectivityTestResultCreateArgs>(args: SelectSubset<T, ConnectivityTestResultCreateArgs<ExtArgs>>): Prisma__ConnectivityTestResultClient<$Result.GetResult<Prisma.$ConnectivityTestResultPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ConnectivityTestResults.
     * @param {ConnectivityTestResultCreateManyArgs} args - Arguments to create many ConnectivityTestResults.
     * @example
     * // Create many ConnectivityTestResults
     * const connectivityTestResult = await prisma.connectivityTestResult.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConnectivityTestResultCreateManyArgs>(args?: SelectSubset<T, ConnectivityTestResultCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ConnectivityTestResults and returns the data saved in the database.
     * @param {ConnectivityTestResultCreateManyAndReturnArgs} args - Arguments to create many ConnectivityTestResults.
     * @example
     * // Create many ConnectivityTestResults
     * const connectivityTestResult = await prisma.connectivityTestResult.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ConnectivityTestResults and only return the `id`
     * const connectivityTestResultWithIdOnly = await prisma.connectivityTestResult.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConnectivityTestResultCreateManyAndReturnArgs>(args?: SelectSubset<T, ConnectivityTestResultCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConnectivityTestResultPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ConnectivityTestResult.
     * @param {ConnectivityTestResultDeleteArgs} args - Arguments to delete one ConnectivityTestResult.
     * @example
     * // Delete one ConnectivityTestResult
     * const ConnectivityTestResult = await prisma.connectivityTestResult.delete({
     *   where: {
     *     // ... filter to delete one ConnectivityTestResult
     *   }
     * })
     * 
     */
    delete<T extends ConnectivityTestResultDeleteArgs>(args: SelectSubset<T, ConnectivityTestResultDeleteArgs<ExtArgs>>): Prisma__ConnectivityTestResultClient<$Result.GetResult<Prisma.$ConnectivityTestResultPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ConnectivityTestResult.
     * @param {ConnectivityTestResultUpdateArgs} args - Arguments to update one ConnectivityTestResult.
     * @example
     * // Update one ConnectivityTestResult
     * const connectivityTestResult = await prisma.connectivityTestResult.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConnectivityTestResultUpdateArgs>(args: SelectSubset<T, ConnectivityTestResultUpdateArgs<ExtArgs>>): Prisma__ConnectivityTestResultClient<$Result.GetResult<Prisma.$ConnectivityTestResultPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ConnectivityTestResults.
     * @param {ConnectivityTestResultDeleteManyArgs} args - Arguments to filter ConnectivityTestResults to delete.
     * @example
     * // Delete a few ConnectivityTestResults
     * const { count } = await prisma.connectivityTestResult.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConnectivityTestResultDeleteManyArgs>(args?: SelectSubset<T, ConnectivityTestResultDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConnectivityTestResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectivityTestResultUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConnectivityTestResults
     * const connectivityTestResult = await prisma.connectivityTestResult.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConnectivityTestResultUpdateManyArgs>(args: SelectSubset<T, ConnectivityTestResultUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConnectivityTestResults and returns the data updated in the database.
     * @param {ConnectivityTestResultUpdateManyAndReturnArgs} args - Arguments to update many ConnectivityTestResults.
     * @example
     * // Update many ConnectivityTestResults
     * const connectivityTestResult = await prisma.connectivityTestResult.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ConnectivityTestResults and only return the `id`
     * const connectivityTestResultWithIdOnly = await prisma.connectivityTestResult.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConnectivityTestResultUpdateManyAndReturnArgs>(args: SelectSubset<T, ConnectivityTestResultUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConnectivityTestResultPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ConnectivityTestResult.
     * @param {ConnectivityTestResultUpsertArgs} args - Arguments to update or create a ConnectivityTestResult.
     * @example
     * // Update or create a ConnectivityTestResult
     * const connectivityTestResult = await prisma.connectivityTestResult.upsert({
     *   create: {
     *     // ... data to create a ConnectivityTestResult
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConnectivityTestResult we want to update
     *   }
     * })
     */
    upsert<T extends ConnectivityTestResultUpsertArgs>(args: SelectSubset<T, ConnectivityTestResultUpsertArgs<ExtArgs>>): Prisma__ConnectivityTestResultClient<$Result.GetResult<Prisma.$ConnectivityTestResultPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ConnectivityTestResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectivityTestResultCountArgs} args - Arguments to filter ConnectivityTestResults to count.
     * @example
     * // Count the number of ConnectivityTestResults
     * const count = await prisma.connectivityTestResult.count({
     *   where: {
     *     // ... the filter for the ConnectivityTestResults we want to count
     *   }
     * })
    **/
    count<T extends ConnectivityTestResultCountArgs>(
      args?: Subset<T, ConnectivityTestResultCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConnectivityTestResultCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConnectivityTestResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectivityTestResultAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConnectivityTestResultAggregateArgs>(args: Subset<T, ConnectivityTestResultAggregateArgs>): Prisma.PrismaPromise<GetConnectivityTestResultAggregateType<T>>

    /**
     * Group by ConnectivityTestResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectivityTestResultGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConnectivityTestResultGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConnectivityTestResultGroupByArgs['orderBy'] }
        : { orderBy?: ConnectivityTestResultGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConnectivityTestResultGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConnectivityTestResultGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConnectivityTestResult model
   */
  readonly fields: ConnectivityTestResultFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConnectivityTestResult.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConnectivityTestResultClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    deviceTest<T extends DeviceTestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DeviceTestDefaultArgs<ExtArgs>>): Prisma__DeviceTestClient<$Result.GetResult<Prisma.$DeviceTestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ConnectivityTestResult model
   */
  interface ConnectivityTestResultFieldRefs {
    readonly id: FieldRef<"ConnectivityTestResult", 'String'>
    readonly name: FieldRef<"ConnectivityTestResult", 'String'>
    readonly status: FieldRef<"ConnectivityTestResult", 'Boolean'>
    readonly message: FieldRef<"ConnectivityTestResult", 'String'>
    readonly timestamp: FieldRef<"ConnectivityTestResult", 'DateTime'>
    readonly deviceTestId: FieldRef<"ConnectivityTestResult", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ConnectivityTestResult findUnique
   */
  export type ConnectivityTestResultFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConnectivityTestResult
     */
    select?: ConnectivityTestResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConnectivityTestResult
     */
    omit?: ConnectivityTestResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectivityTestResultInclude<ExtArgs> | null
    /**
     * Filter, which ConnectivityTestResult to fetch.
     */
    where: ConnectivityTestResultWhereUniqueInput
  }

  /**
   * ConnectivityTestResult findUniqueOrThrow
   */
  export type ConnectivityTestResultFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConnectivityTestResult
     */
    select?: ConnectivityTestResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConnectivityTestResult
     */
    omit?: ConnectivityTestResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectivityTestResultInclude<ExtArgs> | null
    /**
     * Filter, which ConnectivityTestResult to fetch.
     */
    where: ConnectivityTestResultWhereUniqueInput
  }

  /**
   * ConnectivityTestResult findFirst
   */
  export type ConnectivityTestResultFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConnectivityTestResult
     */
    select?: ConnectivityTestResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConnectivityTestResult
     */
    omit?: ConnectivityTestResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectivityTestResultInclude<ExtArgs> | null
    /**
     * Filter, which ConnectivityTestResult to fetch.
     */
    where?: ConnectivityTestResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConnectivityTestResults to fetch.
     */
    orderBy?: ConnectivityTestResultOrderByWithRelationInput | ConnectivityTestResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConnectivityTestResults.
     */
    cursor?: ConnectivityTestResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConnectivityTestResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConnectivityTestResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConnectivityTestResults.
     */
    distinct?: ConnectivityTestResultScalarFieldEnum | ConnectivityTestResultScalarFieldEnum[]
  }

  /**
   * ConnectivityTestResult findFirstOrThrow
   */
  export type ConnectivityTestResultFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConnectivityTestResult
     */
    select?: ConnectivityTestResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConnectivityTestResult
     */
    omit?: ConnectivityTestResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectivityTestResultInclude<ExtArgs> | null
    /**
     * Filter, which ConnectivityTestResult to fetch.
     */
    where?: ConnectivityTestResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConnectivityTestResults to fetch.
     */
    orderBy?: ConnectivityTestResultOrderByWithRelationInput | ConnectivityTestResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConnectivityTestResults.
     */
    cursor?: ConnectivityTestResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConnectivityTestResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConnectivityTestResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConnectivityTestResults.
     */
    distinct?: ConnectivityTestResultScalarFieldEnum | ConnectivityTestResultScalarFieldEnum[]
  }

  /**
   * ConnectivityTestResult findMany
   */
  export type ConnectivityTestResultFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConnectivityTestResult
     */
    select?: ConnectivityTestResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConnectivityTestResult
     */
    omit?: ConnectivityTestResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectivityTestResultInclude<ExtArgs> | null
    /**
     * Filter, which ConnectivityTestResults to fetch.
     */
    where?: ConnectivityTestResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConnectivityTestResults to fetch.
     */
    orderBy?: ConnectivityTestResultOrderByWithRelationInput | ConnectivityTestResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConnectivityTestResults.
     */
    cursor?: ConnectivityTestResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConnectivityTestResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConnectivityTestResults.
     */
    skip?: number
    distinct?: ConnectivityTestResultScalarFieldEnum | ConnectivityTestResultScalarFieldEnum[]
  }

  /**
   * ConnectivityTestResult create
   */
  export type ConnectivityTestResultCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConnectivityTestResult
     */
    select?: ConnectivityTestResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConnectivityTestResult
     */
    omit?: ConnectivityTestResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectivityTestResultInclude<ExtArgs> | null
    /**
     * The data needed to create a ConnectivityTestResult.
     */
    data: XOR<ConnectivityTestResultCreateInput, ConnectivityTestResultUncheckedCreateInput>
  }

  /**
   * ConnectivityTestResult createMany
   */
  export type ConnectivityTestResultCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConnectivityTestResults.
     */
    data: ConnectivityTestResultCreateManyInput | ConnectivityTestResultCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConnectivityTestResult createManyAndReturn
   */
  export type ConnectivityTestResultCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConnectivityTestResult
     */
    select?: ConnectivityTestResultSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConnectivityTestResult
     */
    omit?: ConnectivityTestResultOmit<ExtArgs> | null
    /**
     * The data used to create many ConnectivityTestResults.
     */
    data: ConnectivityTestResultCreateManyInput | ConnectivityTestResultCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectivityTestResultIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConnectivityTestResult update
   */
  export type ConnectivityTestResultUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConnectivityTestResult
     */
    select?: ConnectivityTestResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConnectivityTestResult
     */
    omit?: ConnectivityTestResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectivityTestResultInclude<ExtArgs> | null
    /**
     * The data needed to update a ConnectivityTestResult.
     */
    data: XOR<ConnectivityTestResultUpdateInput, ConnectivityTestResultUncheckedUpdateInput>
    /**
     * Choose, which ConnectivityTestResult to update.
     */
    where: ConnectivityTestResultWhereUniqueInput
  }

  /**
   * ConnectivityTestResult updateMany
   */
  export type ConnectivityTestResultUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConnectivityTestResults.
     */
    data: XOR<ConnectivityTestResultUpdateManyMutationInput, ConnectivityTestResultUncheckedUpdateManyInput>
    /**
     * Filter which ConnectivityTestResults to update
     */
    where?: ConnectivityTestResultWhereInput
    /**
     * Limit how many ConnectivityTestResults to update.
     */
    limit?: number
  }

  /**
   * ConnectivityTestResult updateManyAndReturn
   */
  export type ConnectivityTestResultUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConnectivityTestResult
     */
    select?: ConnectivityTestResultSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConnectivityTestResult
     */
    omit?: ConnectivityTestResultOmit<ExtArgs> | null
    /**
     * The data used to update ConnectivityTestResults.
     */
    data: XOR<ConnectivityTestResultUpdateManyMutationInput, ConnectivityTestResultUncheckedUpdateManyInput>
    /**
     * Filter which ConnectivityTestResults to update
     */
    where?: ConnectivityTestResultWhereInput
    /**
     * Limit how many ConnectivityTestResults to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectivityTestResultIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConnectivityTestResult upsert
   */
  export type ConnectivityTestResultUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConnectivityTestResult
     */
    select?: ConnectivityTestResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConnectivityTestResult
     */
    omit?: ConnectivityTestResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectivityTestResultInclude<ExtArgs> | null
    /**
     * The filter to search for the ConnectivityTestResult to update in case it exists.
     */
    where: ConnectivityTestResultWhereUniqueInput
    /**
     * In case the ConnectivityTestResult found by the `where` argument doesn't exist, create a new ConnectivityTestResult with this data.
     */
    create: XOR<ConnectivityTestResultCreateInput, ConnectivityTestResultUncheckedCreateInput>
    /**
     * In case the ConnectivityTestResult was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConnectivityTestResultUpdateInput, ConnectivityTestResultUncheckedUpdateInput>
  }

  /**
   * ConnectivityTestResult delete
   */
  export type ConnectivityTestResultDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConnectivityTestResult
     */
    select?: ConnectivityTestResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConnectivityTestResult
     */
    omit?: ConnectivityTestResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectivityTestResultInclude<ExtArgs> | null
    /**
     * Filter which ConnectivityTestResult to delete.
     */
    where: ConnectivityTestResultWhereUniqueInput
  }

  /**
   * ConnectivityTestResult deleteMany
   */
  export type ConnectivityTestResultDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConnectivityTestResults to delete
     */
    where?: ConnectivityTestResultWhereInput
    /**
     * Limit how many ConnectivityTestResults to delete.
     */
    limit?: number
  }

  /**
   * ConnectivityTestResult without action
   */
  export type ConnectivityTestResultDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConnectivityTestResult
     */
    select?: ConnectivityTestResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConnectivityTestResult
     */
    omit?: ConnectivityTestResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectivityTestResultInclude<ExtArgs> | null
  }


  /**
   * Model DeviceTestResult
   */

  export type AggregateDeviceTestResult = {
    _count: DeviceTestResultCountAggregateOutputType | null
    _min: DeviceTestResultMinAggregateOutputType | null
    _max: DeviceTestResultMaxAggregateOutputType | null
  }

  export type DeviceTestResultMinAggregateOutputType = {
    id: string | null
    name: string | null
    status: boolean | null
    message: string | null
    timestamp: Date | null
    deviceTestId: string | null
  }

  export type DeviceTestResultMaxAggregateOutputType = {
    id: string | null
    name: string | null
    status: boolean | null
    message: string | null
    timestamp: Date | null
    deviceTestId: string | null
  }

  export type DeviceTestResultCountAggregateOutputType = {
    id: number
    name: number
    status: number
    message: number
    timestamp: number
    deviceTestId: number
    _all: number
  }


  export type DeviceTestResultMinAggregateInputType = {
    id?: true
    name?: true
    status?: true
    message?: true
    timestamp?: true
    deviceTestId?: true
  }

  export type DeviceTestResultMaxAggregateInputType = {
    id?: true
    name?: true
    status?: true
    message?: true
    timestamp?: true
    deviceTestId?: true
  }

  export type DeviceTestResultCountAggregateInputType = {
    id?: true
    name?: true
    status?: true
    message?: true
    timestamp?: true
    deviceTestId?: true
    _all?: true
  }

  export type DeviceTestResultAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeviceTestResult to aggregate.
     */
    where?: DeviceTestResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceTestResults to fetch.
     */
    orderBy?: DeviceTestResultOrderByWithRelationInput | DeviceTestResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeviceTestResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceTestResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceTestResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeviceTestResults
    **/
    _count?: true | DeviceTestResultCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeviceTestResultMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeviceTestResultMaxAggregateInputType
  }

  export type GetDeviceTestResultAggregateType<T extends DeviceTestResultAggregateArgs> = {
        [P in keyof T & keyof AggregateDeviceTestResult]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeviceTestResult[P]>
      : GetScalarType<T[P], AggregateDeviceTestResult[P]>
  }




  export type DeviceTestResultGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceTestResultWhereInput
    orderBy?: DeviceTestResultOrderByWithAggregationInput | DeviceTestResultOrderByWithAggregationInput[]
    by: DeviceTestResultScalarFieldEnum[] | DeviceTestResultScalarFieldEnum
    having?: DeviceTestResultScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeviceTestResultCountAggregateInputType | true
    _min?: DeviceTestResultMinAggregateInputType
    _max?: DeviceTestResultMaxAggregateInputType
  }

  export type DeviceTestResultGroupByOutputType = {
    id: string
    name: string
    status: boolean
    message: string | null
    timestamp: Date | null
    deviceTestId: string
    _count: DeviceTestResultCountAggregateOutputType | null
    _min: DeviceTestResultMinAggregateOutputType | null
    _max: DeviceTestResultMaxAggregateOutputType | null
  }

  type GetDeviceTestResultGroupByPayload<T extends DeviceTestResultGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeviceTestResultGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeviceTestResultGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeviceTestResultGroupByOutputType[P]>
            : GetScalarType<T[P], DeviceTestResultGroupByOutputType[P]>
        }
      >
    >


  export type DeviceTestResultSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    status?: boolean
    message?: boolean
    timestamp?: boolean
    deviceTestId?: boolean
    deviceTest?: boolean | DeviceTestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deviceTestResult"]>

  export type DeviceTestResultSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    status?: boolean
    message?: boolean
    timestamp?: boolean
    deviceTestId?: boolean
    deviceTest?: boolean | DeviceTestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deviceTestResult"]>

  export type DeviceTestResultSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    status?: boolean
    message?: boolean
    timestamp?: boolean
    deviceTestId?: boolean
    deviceTest?: boolean | DeviceTestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deviceTestResult"]>

  export type DeviceTestResultSelectScalar = {
    id?: boolean
    name?: boolean
    status?: boolean
    message?: boolean
    timestamp?: boolean
    deviceTestId?: boolean
  }

  export type DeviceTestResultOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "status" | "message" | "timestamp" | "deviceTestId", ExtArgs["result"]["deviceTestResult"]>
  export type DeviceTestResultInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deviceTest?: boolean | DeviceTestDefaultArgs<ExtArgs>
  }
  export type DeviceTestResultIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deviceTest?: boolean | DeviceTestDefaultArgs<ExtArgs>
  }
  export type DeviceTestResultIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deviceTest?: boolean | DeviceTestDefaultArgs<ExtArgs>
  }

  export type $DeviceTestResultPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeviceTestResult"
    objects: {
      deviceTest: Prisma.$DeviceTestPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      status: boolean
      message: string | null
      timestamp: Date | null
      deviceTestId: string
    }, ExtArgs["result"]["deviceTestResult"]>
    composites: {}
  }

  type DeviceTestResultGetPayload<S extends boolean | null | undefined | DeviceTestResultDefaultArgs> = $Result.GetResult<Prisma.$DeviceTestResultPayload, S>

  type DeviceTestResultCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeviceTestResultFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeviceTestResultCountAggregateInputType | true
    }

  export interface DeviceTestResultDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeviceTestResult'], meta: { name: 'DeviceTestResult' } }
    /**
     * Find zero or one DeviceTestResult that matches the filter.
     * @param {DeviceTestResultFindUniqueArgs} args - Arguments to find a DeviceTestResult
     * @example
     * // Get one DeviceTestResult
     * const deviceTestResult = await prisma.deviceTestResult.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeviceTestResultFindUniqueArgs>(args: SelectSubset<T, DeviceTestResultFindUniqueArgs<ExtArgs>>): Prisma__DeviceTestResultClient<$Result.GetResult<Prisma.$DeviceTestResultPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DeviceTestResult that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeviceTestResultFindUniqueOrThrowArgs} args - Arguments to find a DeviceTestResult
     * @example
     * // Get one DeviceTestResult
     * const deviceTestResult = await prisma.deviceTestResult.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeviceTestResultFindUniqueOrThrowArgs>(args: SelectSubset<T, DeviceTestResultFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeviceTestResultClient<$Result.GetResult<Prisma.$DeviceTestResultPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeviceTestResult that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceTestResultFindFirstArgs} args - Arguments to find a DeviceTestResult
     * @example
     * // Get one DeviceTestResult
     * const deviceTestResult = await prisma.deviceTestResult.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeviceTestResultFindFirstArgs>(args?: SelectSubset<T, DeviceTestResultFindFirstArgs<ExtArgs>>): Prisma__DeviceTestResultClient<$Result.GetResult<Prisma.$DeviceTestResultPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeviceTestResult that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceTestResultFindFirstOrThrowArgs} args - Arguments to find a DeviceTestResult
     * @example
     * // Get one DeviceTestResult
     * const deviceTestResult = await prisma.deviceTestResult.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeviceTestResultFindFirstOrThrowArgs>(args?: SelectSubset<T, DeviceTestResultFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeviceTestResultClient<$Result.GetResult<Prisma.$DeviceTestResultPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DeviceTestResults that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceTestResultFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeviceTestResults
     * const deviceTestResults = await prisma.deviceTestResult.findMany()
     * 
     * // Get first 10 DeviceTestResults
     * const deviceTestResults = await prisma.deviceTestResult.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deviceTestResultWithIdOnly = await prisma.deviceTestResult.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeviceTestResultFindManyArgs>(args?: SelectSubset<T, DeviceTestResultFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceTestResultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DeviceTestResult.
     * @param {DeviceTestResultCreateArgs} args - Arguments to create a DeviceTestResult.
     * @example
     * // Create one DeviceTestResult
     * const DeviceTestResult = await prisma.deviceTestResult.create({
     *   data: {
     *     // ... data to create a DeviceTestResult
     *   }
     * })
     * 
     */
    create<T extends DeviceTestResultCreateArgs>(args: SelectSubset<T, DeviceTestResultCreateArgs<ExtArgs>>): Prisma__DeviceTestResultClient<$Result.GetResult<Prisma.$DeviceTestResultPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DeviceTestResults.
     * @param {DeviceTestResultCreateManyArgs} args - Arguments to create many DeviceTestResults.
     * @example
     * // Create many DeviceTestResults
     * const deviceTestResult = await prisma.deviceTestResult.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeviceTestResultCreateManyArgs>(args?: SelectSubset<T, DeviceTestResultCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DeviceTestResults and returns the data saved in the database.
     * @param {DeviceTestResultCreateManyAndReturnArgs} args - Arguments to create many DeviceTestResults.
     * @example
     * // Create many DeviceTestResults
     * const deviceTestResult = await prisma.deviceTestResult.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DeviceTestResults and only return the `id`
     * const deviceTestResultWithIdOnly = await prisma.deviceTestResult.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeviceTestResultCreateManyAndReturnArgs>(args?: SelectSubset<T, DeviceTestResultCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceTestResultPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DeviceTestResult.
     * @param {DeviceTestResultDeleteArgs} args - Arguments to delete one DeviceTestResult.
     * @example
     * // Delete one DeviceTestResult
     * const DeviceTestResult = await prisma.deviceTestResult.delete({
     *   where: {
     *     // ... filter to delete one DeviceTestResult
     *   }
     * })
     * 
     */
    delete<T extends DeviceTestResultDeleteArgs>(args: SelectSubset<T, DeviceTestResultDeleteArgs<ExtArgs>>): Prisma__DeviceTestResultClient<$Result.GetResult<Prisma.$DeviceTestResultPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DeviceTestResult.
     * @param {DeviceTestResultUpdateArgs} args - Arguments to update one DeviceTestResult.
     * @example
     * // Update one DeviceTestResult
     * const deviceTestResult = await prisma.deviceTestResult.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeviceTestResultUpdateArgs>(args: SelectSubset<T, DeviceTestResultUpdateArgs<ExtArgs>>): Prisma__DeviceTestResultClient<$Result.GetResult<Prisma.$DeviceTestResultPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DeviceTestResults.
     * @param {DeviceTestResultDeleteManyArgs} args - Arguments to filter DeviceTestResults to delete.
     * @example
     * // Delete a few DeviceTestResults
     * const { count } = await prisma.deviceTestResult.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeviceTestResultDeleteManyArgs>(args?: SelectSubset<T, DeviceTestResultDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeviceTestResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceTestResultUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeviceTestResults
     * const deviceTestResult = await prisma.deviceTestResult.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeviceTestResultUpdateManyArgs>(args: SelectSubset<T, DeviceTestResultUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeviceTestResults and returns the data updated in the database.
     * @param {DeviceTestResultUpdateManyAndReturnArgs} args - Arguments to update many DeviceTestResults.
     * @example
     * // Update many DeviceTestResults
     * const deviceTestResult = await prisma.deviceTestResult.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DeviceTestResults and only return the `id`
     * const deviceTestResultWithIdOnly = await prisma.deviceTestResult.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DeviceTestResultUpdateManyAndReturnArgs>(args: SelectSubset<T, DeviceTestResultUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceTestResultPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DeviceTestResult.
     * @param {DeviceTestResultUpsertArgs} args - Arguments to update or create a DeviceTestResult.
     * @example
     * // Update or create a DeviceTestResult
     * const deviceTestResult = await prisma.deviceTestResult.upsert({
     *   create: {
     *     // ... data to create a DeviceTestResult
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeviceTestResult we want to update
     *   }
     * })
     */
    upsert<T extends DeviceTestResultUpsertArgs>(args: SelectSubset<T, DeviceTestResultUpsertArgs<ExtArgs>>): Prisma__DeviceTestResultClient<$Result.GetResult<Prisma.$DeviceTestResultPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DeviceTestResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceTestResultCountArgs} args - Arguments to filter DeviceTestResults to count.
     * @example
     * // Count the number of DeviceTestResults
     * const count = await prisma.deviceTestResult.count({
     *   where: {
     *     // ... the filter for the DeviceTestResults we want to count
     *   }
     * })
    **/
    count<T extends DeviceTestResultCountArgs>(
      args?: Subset<T, DeviceTestResultCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeviceTestResultCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeviceTestResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceTestResultAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeviceTestResultAggregateArgs>(args: Subset<T, DeviceTestResultAggregateArgs>): Prisma.PrismaPromise<GetDeviceTestResultAggregateType<T>>

    /**
     * Group by DeviceTestResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceTestResultGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeviceTestResultGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeviceTestResultGroupByArgs['orderBy'] }
        : { orderBy?: DeviceTestResultGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeviceTestResultGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeviceTestResultGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeviceTestResult model
   */
  readonly fields: DeviceTestResultFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeviceTestResult.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeviceTestResultClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    deviceTest<T extends DeviceTestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DeviceTestDefaultArgs<ExtArgs>>): Prisma__DeviceTestClient<$Result.GetResult<Prisma.$DeviceTestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeviceTestResult model
   */
  interface DeviceTestResultFieldRefs {
    readonly id: FieldRef<"DeviceTestResult", 'String'>
    readonly name: FieldRef<"DeviceTestResult", 'String'>
    readonly status: FieldRef<"DeviceTestResult", 'Boolean'>
    readonly message: FieldRef<"DeviceTestResult", 'String'>
    readonly timestamp: FieldRef<"DeviceTestResult", 'DateTime'>
    readonly deviceTestId: FieldRef<"DeviceTestResult", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DeviceTestResult findUnique
   */
  export type DeviceTestResultFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceTestResult
     */
    select?: DeviceTestResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceTestResult
     */
    omit?: DeviceTestResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTestResultInclude<ExtArgs> | null
    /**
     * Filter, which DeviceTestResult to fetch.
     */
    where: DeviceTestResultWhereUniqueInput
  }

  /**
   * DeviceTestResult findUniqueOrThrow
   */
  export type DeviceTestResultFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceTestResult
     */
    select?: DeviceTestResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceTestResult
     */
    omit?: DeviceTestResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTestResultInclude<ExtArgs> | null
    /**
     * Filter, which DeviceTestResult to fetch.
     */
    where: DeviceTestResultWhereUniqueInput
  }

  /**
   * DeviceTestResult findFirst
   */
  export type DeviceTestResultFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceTestResult
     */
    select?: DeviceTestResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceTestResult
     */
    omit?: DeviceTestResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTestResultInclude<ExtArgs> | null
    /**
     * Filter, which DeviceTestResult to fetch.
     */
    where?: DeviceTestResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceTestResults to fetch.
     */
    orderBy?: DeviceTestResultOrderByWithRelationInput | DeviceTestResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeviceTestResults.
     */
    cursor?: DeviceTestResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceTestResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceTestResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeviceTestResults.
     */
    distinct?: DeviceTestResultScalarFieldEnum | DeviceTestResultScalarFieldEnum[]
  }

  /**
   * DeviceTestResult findFirstOrThrow
   */
  export type DeviceTestResultFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceTestResult
     */
    select?: DeviceTestResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceTestResult
     */
    omit?: DeviceTestResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTestResultInclude<ExtArgs> | null
    /**
     * Filter, which DeviceTestResult to fetch.
     */
    where?: DeviceTestResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceTestResults to fetch.
     */
    orderBy?: DeviceTestResultOrderByWithRelationInput | DeviceTestResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeviceTestResults.
     */
    cursor?: DeviceTestResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceTestResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceTestResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeviceTestResults.
     */
    distinct?: DeviceTestResultScalarFieldEnum | DeviceTestResultScalarFieldEnum[]
  }

  /**
   * DeviceTestResult findMany
   */
  export type DeviceTestResultFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceTestResult
     */
    select?: DeviceTestResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceTestResult
     */
    omit?: DeviceTestResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTestResultInclude<ExtArgs> | null
    /**
     * Filter, which DeviceTestResults to fetch.
     */
    where?: DeviceTestResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceTestResults to fetch.
     */
    orderBy?: DeviceTestResultOrderByWithRelationInput | DeviceTestResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeviceTestResults.
     */
    cursor?: DeviceTestResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceTestResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceTestResults.
     */
    skip?: number
    distinct?: DeviceTestResultScalarFieldEnum | DeviceTestResultScalarFieldEnum[]
  }

  /**
   * DeviceTestResult create
   */
  export type DeviceTestResultCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceTestResult
     */
    select?: DeviceTestResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceTestResult
     */
    omit?: DeviceTestResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTestResultInclude<ExtArgs> | null
    /**
     * The data needed to create a DeviceTestResult.
     */
    data: XOR<DeviceTestResultCreateInput, DeviceTestResultUncheckedCreateInput>
  }

  /**
   * DeviceTestResult createMany
   */
  export type DeviceTestResultCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeviceTestResults.
     */
    data: DeviceTestResultCreateManyInput | DeviceTestResultCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeviceTestResult createManyAndReturn
   */
  export type DeviceTestResultCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceTestResult
     */
    select?: DeviceTestResultSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceTestResult
     */
    omit?: DeviceTestResultOmit<ExtArgs> | null
    /**
     * The data used to create many DeviceTestResults.
     */
    data: DeviceTestResultCreateManyInput | DeviceTestResultCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTestResultIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeviceTestResult update
   */
  export type DeviceTestResultUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceTestResult
     */
    select?: DeviceTestResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceTestResult
     */
    omit?: DeviceTestResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTestResultInclude<ExtArgs> | null
    /**
     * The data needed to update a DeviceTestResult.
     */
    data: XOR<DeviceTestResultUpdateInput, DeviceTestResultUncheckedUpdateInput>
    /**
     * Choose, which DeviceTestResult to update.
     */
    where: DeviceTestResultWhereUniqueInput
  }

  /**
   * DeviceTestResult updateMany
   */
  export type DeviceTestResultUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeviceTestResults.
     */
    data: XOR<DeviceTestResultUpdateManyMutationInput, DeviceTestResultUncheckedUpdateManyInput>
    /**
     * Filter which DeviceTestResults to update
     */
    where?: DeviceTestResultWhereInput
    /**
     * Limit how many DeviceTestResults to update.
     */
    limit?: number
  }

  /**
   * DeviceTestResult updateManyAndReturn
   */
  export type DeviceTestResultUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceTestResult
     */
    select?: DeviceTestResultSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceTestResult
     */
    omit?: DeviceTestResultOmit<ExtArgs> | null
    /**
     * The data used to update DeviceTestResults.
     */
    data: XOR<DeviceTestResultUpdateManyMutationInput, DeviceTestResultUncheckedUpdateManyInput>
    /**
     * Filter which DeviceTestResults to update
     */
    where?: DeviceTestResultWhereInput
    /**
     * Limit how many DeviceTestResults to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTestResultIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeviceTestResult upsert
   */
  export type DeviceTestResultUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceTestResult
     */
    select?: DeviceTestResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceTestResult
     */
    omit?: DeviceTestResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTestResultInclude<ExtArgs> | null
    /**
     * The filter to search for the DeviceTestResult to update in case it exists.
     */
    where: DeviceTestResultWhereUniqueInput
    /**
     * In case the DeviceTestResult found by the `where` argument doesn't exist, create a new DeviceTestResult with this data.
     */
    create: XOR<DeviceTestResultCreateInput, DeviceTestResultUncheckedCreateInput>
    /**
     * In case the DeviceTestResult was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeviceTestResultUpdateInput, DeviceTestResultUncheckedUpdateInput>
  }

  /**
   * DeviceTestResult delete
   */
  export type DeviceTestResultDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceTestResult
     */
    select?: DeviceTestResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceTestResult
     */
    omit?: DeviceTestResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTestResultInclude<ExtArgs> | null
    /**
     * Filter which DeviceTestResult to delete.
     */
    where: DeviceTestResultWhereUniqueInput
  }

  /**
   * DeviceTestResult deleteMany
   */
  export type DeviceTestResultDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeviceTestResults to delete
     */
    where?: DeviceTestResultWhereInput
    /**
     * Limit how many DeviceTestResults to delete.
     */
    limit?: number
  }

  /**
   * DeviceTestResult without action
   */
  export type DeviceTestResultDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceTestResult
     */
    select?: DeviceTestResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceTestResult
     */
    omit?: DeviceTestResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTestResultInclude<ExtArgs> | null
  }


  /**
   * Model SimTestResult
   */

  export type AggregateSimTestResult = {
    _count: SimTestResultCountAggregateOutputType | null
    _min: SimTestResultMinAggregateOutputType | null
    _max: SimTestResultMaxAggregateOutputType | null
  }

  export type SimTestResultMinAggregateOutputType = {
    id: string | null
    name: string | null
    status: boolean | null
    timestamp: Date | null
    deviceTestId: string | null
  }

  export type SimTestResultMaxAggregateOutputType = {
    id: string | null
    name: string | null
    status: boolean | null
    timestamp: Date | null
    deviceTestId: string | null
  }

  export type SimTestResultCountAggregateOutputType = {
    id: number
    name: number
    status: number
    timestamp: number
    deviceTestId: number
    _all: number
  }


  export type SimTestResultMinAggregateInputType = {
    id?: true
    name?: true
    status?: true
    timestamp?: true
    deviceTestId?: true
  }

  export type SimTestResultMaxAggregateInputType = {
    id?: true
    name?: true
    status?: true
    timestamp?: true
    deviceTestId?: true
  }

  export type SimTestResultCountAggregateInputType = {
    id?: true
    name?: true
    status?: true
    timestamp?: true
    deviceTestId?: true
    _all?: true
  }

  export type SimTestResultAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SimTestResult to aggregate.
     */
    where?: SimTestResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SimTestResults to fetch.
     */
    orderBy?: SimTestResultOrderByWithRelationInput | SimTestResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SimTestResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SimTestResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SimTestResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SimTestResults
    **/
    _count?: true | SimTestResultCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SimTestResultMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SimTestResultMaxAggregateInputType
  }

  export type GetSimTestResultAggregateType<T extends SimTestResultAggregateArgs> = {
        [P in keyof T & keyof AggregateSimTestResult]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSimTestResult[P]>
      : GetScalarType<T[P], AggregateSimTestResult[P]>
  }




  export type SimTestResultGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SimTestResultWhereInput
    orderBy?: SimTestResultOrderByWithAggregationInput | SimTestResultOrderByWithAggregationInput[]
    by: SimTestResultScalarFieldEnum[] | SimTestResultScalarFieldEnum
    having?: SimTestResultScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SimTestResultCountAggregateInputType | true
    _min?: SimTestResultMinAggregateInputType
    _max?: SimTestResultMaxAggregateInputType
  }

  export type SimTestResultGroupByOutputType = {
    id: string
    name: string
    status: boolean
    timestamp: Date | null
    deviceTestId: string
    _count: SimTestResultCountAggregateOutputType | null
    _min: SimTestResultMinAggregateOutputType | null
    _max: SimTestResultMaxAggregateOutputType | null
  }

  type GetSimTestResultGroupByPayload<T extends SimTestResultGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SimTestResultGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SimTestResultGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SimTestResultGroupByOutputType[P]>
            : GetScalarType<T[P], SimTestResultGroupByOutputType[P]>
        }
      >
    >


  export type SimTestResultSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    status?: boolean
    timestamp?: boolean
    deviceTestId?: boolean
    deviceTest?: boolean | DeviceTestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["simTestResult"]>

  export type SimTestResultSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    status?: boolean
    timestamp?: boolean
    deviceTestId?: boolean
    deviceTest?: boolean | DeviceTestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["simTestResult"]>

  export type SimTestResultSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    status?: boolean
    timestamp?: boolean
    deviceTestId?: boolean
    deviceTest?: boolean | DeviceTestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["simTestResult"]>

  export type SimTestResultSelectScalar = {
    id?: boolean
    name?: boolean
    status?: boolean
    timestamp?: boolean
    deviceTestId?: boolean
  }

  export type SimTestResultOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "status" | "timestamp" | "deviceTestId", ExtArgs["result"]["simTestResult"]>
  export type SimTestResultInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deviceTest?: boolean | DeviceTestDefaultArgs<ExtArgs>
  }
  export type SimTestResultIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deviceTest?: boolean | DeviceTestDefaultArgs<ExtArgs>
  }
  export type SimTestResultIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deviceTest?: boolean | DeviceTestDefaultArgs<ExtArgs>
  }

  export type $SimTestResultPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SimTestResult"
    objects: {
      deviceTest: Prisma.$DeviceTestPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      status: boolean
      timestamp: Date | null
      deviceTestId: string
    }, ExtArgs["result"]["simTestResult"]>
    composites: {}
  }

  type SimTestResultGetPayload<S extends boolean | null | undefined | SimTestResultDefaultArgs> = $Result.GetResult<Prisma.$SimTestResultPayload, S>

  type SimTestResultCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SimTestResultFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SimTestResultCountAggregateInputType | true
    }

  export interface SimTestResultDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SimTestResult'], meta: { name: 'SimTestResult' } }
    /**
     * Find zero or one SimTestResult that matches the filter.
     * @param {SimTestResultFindUniqueArgs} args - Arguments to find a SimTestResult
     * @example
     * // Get one SimTestResult
     * const simTestResult = await prisma.simTestResult.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SimTestResultFindUniqueArgs>(args: SelectSubset<T, SimTestResultFindUniqueArgs<ExtArgs>>): Prisma__SimTestResultClient<$Result.GetResult<Prisma.$SimTestResultPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SimTestResult that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SimTestResultFindUniqueOrThrowArgs} args - Arguments to find a SimTestResult
     * @example
     * // Get one SimTestResult
     * const simTestResult = await prisma.simTestResult.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SimTestResultFindUniqueOrThrowArgs>(args: SelectSubset<T, SimTestResultFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SimTestResultClient<$Result.GetResult<Prisma.$SimTestResultPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SimTestResult that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimTestResultFindFirstArgs} args - Arguments to find a SimTestResult
     * @example
     * // Get one SimTestResult
     * const simTestResult = await prisma.simTestResult.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SimTestResultFindFirstArgs>(args?: SelectSubset<T, SimTestResultFindFirstArgs<ExtArgs>>): Prisma__SimTestResultClient<$Result.GetResult<Prisma.$SimTestResultPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SimTestResult that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimTestResultFindFirstOrThrowArgs} args - Arguments to find a SimTestResult
     * @example
     * // Get one SimTestResult
     * const simTestResult = await prisma.simTestResult.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SimTestResultFindFirstOrThrowArgs>(args?: SelectSubset<T, SimTestResultFindFirstOrThrowArgs<ExtArgs>>): Prisma__SimTestResultClient<$Result.GetResult<Prisma.$SimTestResultPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SimTestResults that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimTestResultFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SimTestResults
     * const simTestResults = await prisma.simTestResult.findMany()
     * 
     * // Get first 10 SimTestResults
     * const simTestResults = await prisma.simTestResult.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const simTestResultWithIdOnly = await prisma.simTestResult.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SimTestResultFindManyArgs>(args?: SelectSubset<T, SimTestResultFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SimTestResultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SimTestResult.
     * @param {SimTestResultCreateArgs} args - Arguments to create a SimTestResult.
     * @example
     * // Create one SimTestResult
     * const SimTestResult = await prisma.simTestResult.create({
     *   data: {
     *     // ... data to create a SimTestResult
     *   }
     * })
     * 
     */
    create<T extends SimTestResultCreateArgs>(args: SelectSubset<T, SimTestResultCreateArgs<ExtArgs>>): Prisma__SimTestResultClient<$Result.GetResult<Prisma.$SimTestResultPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SimTestResults.
     * @param {SimTestResultCreateManyArgs} args - Arguments to create many SimTestResults.
     * @example
     * // Create many SimTestResults
     * const simTestResult = await prisma.simTestResult.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SimTestResultCreateManyArgs>(args?: SelectSubset<T, SimTestResultCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SimTestResults and returns the data saved in the database.
     * @param {SimTestResultCreateManyAndReturnArgs} args - Arguments to create many SimTestResults.
     * @example
     * // Create many SimTestResults
     * const simTestResult = await prisma.simTestResult.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SimTestResults and only return the `id`
     * const simTestResultWithIdOnly = await prisma.simTestResult.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SimTestResultCreateManyAndReturnArgs>(args?: SelectSubset<T, SimTestResultCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SimTestResultPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SimTestResult.
     * @param {SimTestResultDeleteArgs} args - Arguments to delete one SimTestResult.
     * @example
     * // Delete one SimTestResult
     * const SimTestResult = await prisma.simTestResult.delete({
     *   where: {
     *     // ... filter to delete one SimTestResult
     *   }
     * })
     * 
     */
    delete<T extends SimTestResultDeleteArgs>(args: SelectSubset<T, SimTestResultDeleteArgs<ExtArgs>>): Prisma__SimTestResultClient<$Result.GetResult<Prisma.$SimTestResultPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SimTestResult.
     * @param {SimTestResultUpdateArgs} args - Arguments to update one SimTestResult.
     * @example
     * // Update one SimTestResult
     * const simTestResult = await prisma.simTestResult.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SimTestResultUpdateArgs>(args: SelectSubset<T, SimTestResultUpdateArgs<ExtArgs>>): Prisma__SimTestResultClient<$Result.GetResult<Prisma.$SimTestResultPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SimTestResults.
     * @param {SimTestResultDeleteManyArgs} args - Arguments to filter SimTestResults to delete.
     * @example
     * // Delete a few SimTestResults
     * const { count } = await prisma.simTestResult.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SimTestResultDeleteManyArgs>(args?: SelectSubset<T, SimTestResultDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SimTestResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimTestResultUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SimTestResults
     * const simTestResult = await prisma.simTestResult.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SimTestResultUpdateManyArgs>(args: SelectSubset<T, SimTestResultUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SimTestResults and returns the data updated in the database.
     * @param {SimTestResultUpdateManyAndReturnArgs} args - Arguments to update many SimTestResults.
     * @example
     * // Update many SimTestResults
     * const simTestResult = await prisma.simTestResult.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SimTestResults and only return the `id`
     * const simTestResultWithIdOnly = await prisma.simTestResult.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SimTestResultUpdateManyAndReturnArgs>(args: SelectSubset<T, SimTestResultUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SimTestResultPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SimTestResult.
     * @param {SimTestResultUpsertArgs} args - Arguments to update or create a SimTestResult.
     * @example
     * // Update or create a SimTestResult
     * const simTestResult = await prisma.simTestResult.upsert({
     *   create: {
     *     // ... data to create a SimTestResult
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SimTestResult we want to update
     *   }
     * })
     */
    upsert<T extends SimTestResultUpsertArgs>(args: SelectSubset<T, SimTestResultUpsertArgs<ExtArgs>>): Prisma__SimTestResultClient<$Result.GetResult<Prisma.$SimTestResultPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SimTestResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimTestResultCountArgs} args - Arguments to filter SimTestResults to count.
     * @example
     * // Count the number of SimTestResults
     * const count = await prisma.simTestResult.count({
     *   where: {
     *     // ... the filter for the SimTestResults we want to count
     *   }
     * })
    **/
    count<T extends SimTestResultCountArgs>(
      args?: Subset<T, SimTestResultCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SimTestResultCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SimTestResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimTestResultAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SimTestResultAggregateArgs>(args: Subset<T, SimTestResultAggregateArgs>): Prisma.PrismaPromise<GetSimTestResultAggregateType<T>>

    /**
     * Group by SimTestResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimTestResultGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SimTestResultGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SimTestResultGroupByArgs['orderBy'] }
        : { orderBy?: SimTestResultGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SimTestResultGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSimTestResultGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SimTestResult model
   */
  readonly fields: SimTestResultFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SimTestResult.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SimTestResultClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    deviceTest<T extends DeviceTestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DeviceTestDefaultArgs<ExtArgs>>): Prisma__DeviceTestClient<$Result.GetResult<Prisma.$DeviceTestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SimTestResult model
   */
  interface SimTestResultFieldRefs {
    readonly id: FieldRef<"SimTestResult", 'String'>
    readonly name: FieldRef<"SimTestResult", 'String'>
    readonly status: FieldRef<"SimTestResult", 'Boolean'>
    readonly timestamp: FieldRef<"SimTestResult", 'DateTime'>
    readonly deviceTestId: FieldRef<"SimTestResult", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SimTestResult findUnique
   */
  export type SimTestResultFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimTestResult
     */
    select?: SimTestResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SimTestResult
     */
    omit?: SimTestResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimTestResultInclude<ExtArgs> | null
    /**
     * Filter, which SimTestResult to fetch.
     */
    where: SimTestResultWhereUniqueInput
  }

  /**
   * SimTestResult findUniqueOrThrow
   */
  export type SimTestResultFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimTestResult
     */
    select?: SimTestResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SimTestResult
     */
    omit?: SimTestResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimTestResultInclude<ExtArgs> | null
    /**
     * Filter, which SimTestResult to fetch.
     */
    where: SimTestResultWhereUniqueInput
  }

  /**
   * SimTestResult findFirst
   */
  export type SimTestResultFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimTestResult
     */
    select?: SimTestResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SimTestResult
     */
    omit?: SimTestResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimTestResultInclude<ExtArgs> | null
    /**
     * Filter, which SimTestResult to fetch.
     */
    where?: SimTestResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SimTestResults to fetch.
     */
    orderBy?: SimTestResultOrderByWithRelationInput | SimTestResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SimTestResults.
     */
    cursor?: SimTestResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SimTestResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SimTestResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SimTestResults.
     */
    distinct?: SimTestResultScalarFieldEnum | SimTestResultScalarFieldEnum[]
  }

  /**
   * SimTestResult findFirstOrThrow
   */
  export type SimTestResultFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimTestResult
     */
    select?: SimTestResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SimTestResult
     */
    omit?: SimTestResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimTestResultInclude<ExtArgs> | null
    /**
     * Filter, which SimTestResult to fetch.
     */
    where?: SimTestResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SimTestResults to fetch.
     */
    orderBy?: SimTestResultOrderByWithRelationInput | SimTestResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SimTestResults.
     */
    cursor?: SimTestResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SimTestResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SimTestResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SimTestResults.
     */
    distinct?: SimTestResultScalarFieldEnum | SimTestResultScalarFieldEnum[]
  }

  /**
   * SimTestResult findMany
   */
  export type SimTestResultFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimTestResult
     */
    select?: SimTestResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SimTestResult
     */
    omit?: SimTestResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimTestResultInclude<ExtArgs> | null
    /**
     * Filter, which SimTestResults to fetch.
     */
    where?: SimTestResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SimTestResults to fetch.
     */
    orderBy?: SimTestResultOrderByWithRelationInput | SimTestResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SimTestResults.
     */
    cursor?: SimTestResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SimTestResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SimTestResults.
     */
    skip?: number
    distinct?: SimTestResultScalarFieldEnum | SimTestResultScalarFieldEnum[]
  }

  /**
   * SimTestResult create
   */
  export type SimTestResultCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimTestResult
     */
    select?: SimTestResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SimTestResult
     */
    omit?: SimTestResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimTestResultInclude<ExtArgs> | null
    /**
     * The data needed to create a SimTestResult.
     */
    data: XOR<SimTestResultCreateInput, SimTestResultUncheckedCreateInput>
  }

  /**
   * SimTestResult createMany
   */
  export type SimTestResultCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SimTestResults.
     */
    data: SimTestResultCreateManyInput | SimTestResultCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SimTestResult createManyAndReturn
   */
  export type SimTestResultCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimTestResult
     */
    select?: SimTestResultSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SimTestResult
     */
    omit?: SimTestResultOmit<ExtArgs> | null
    /**
     * The data used to create many SimTestResults.
     */
    data: SimTestResultCreateManyInput | SimTestResultCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimTestResultIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SimTestResult update
   */
  export type SimTestResultUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimTestResult
     */
    select?: SimTestResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SimTestResult
     */
    omit?: SimTestResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimTestResultInclude<ExtArgs> | null
    /**
     * The data needed to update a SimTestResult.
     */
    data: XOR<SimTestResultUpdateInput, SimTestResultUncheckedUpdateInput>
    /**
     * Choose, which SimTestResult to update.
     */
    where: SimTestResultWhereUniqueInput
  }

  /**
   * SimTestResult updateMany
   */
  export type SimTestResultUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SimTestResults.
     */
    data: XOR<SimTestResultUpdateManyMutationInput, SimTestResultUncheckedUpdateManyInput>
    /**
     * Filter which SimTestResults to update
     */
    where?: SimTestResultWhereInput
    /**
     * Limit how many SimTestResults to update.
     */
    limit?: number
  }

  /**
   * SimTestResult updateManyAndReturn
   */
  export type SimTestResultUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimTestResult
     */
    select?: SimTestResultSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SimTestResult
     */
    omit?: SimTestResultOmit<ExtArgs> | null
    /**
     * The data used to update SimTestResults.
     */
    data: XOR<SimTestResultUpdateManyMutationInput, SimTestResultUncheckedUpdateManyInput>
    /**
     * Filter which SimTestResults to update
     */
    where?: SimTestResultWhereInput
    /**
     * Limit how many SimTestResults to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimTestResultIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SimTestResult upsert
   */
  export type SimTestResultUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimTestResult
     */
    select?: SimTestResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SimTestResult
     */
    omit?: SimTestResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimTestResultInclude<ExtArgs> | null
    /**
     * The filter to search for the SimTestResult to update in case it exists.
     */
    where: SimTestResultWhereUniqueInput
    /**
     * In case the SimTestResult found by the `where` argument doesn't exist, create a new SimTestResult with this data.
     */
    create: XOR<SimTestResultCreateInput, SimTestResultUncheckedCreateInput>
    /**
     * In case the SimTestResult was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SimTestResultUpdateInput, SimTestResultUncheckedUpdateInput>
  }

  /**
   * SimTestResult delete
   */
  export type SimTestResultDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimTestResult
     */
    select?: SimTestResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SimTestResult
     */
    omit?: SimTestResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimTestResultInclude<ExtArgs> | null
    /**
     * Filter which SimTestResult to delete.
     */
    where: SimTestResultWhereUniqueInput
  }

  /**
   * SimTestResult deleteMany
   */
  export type SimTestResultDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SimTestResults to delete
     */
    where?: SimTestResultWhereInput
    /**
     * Limit how many SimTestResults to delete.
     */
    limit?: number
  }

  /**
   * SimTestResult without action
   */
  export type SimTestResultDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimTestResult
     */
    select?: SimTestResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SimTestResult
     */
    omit?: SimTestResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimTestResultInclude<ExtArgs> | null
  }


  /**
   * Model ScreenTest
   */

  export type AggregateScreenTest = {
    _count: ScreenTestCountAggregateOutputType | null
    _min: ScreenTestMinAggregateOutputType | null
    _max: ScreenTestMaxAggregateOutputType | null
  }

  export type ScreenTestMinAggregateOutputType = {
    id: string | null
    multiTouch: boolean | null
    dotCoverage: boolean | null
    completed: boolean | null
    timestamp: Date | null
    deviceTestId: string | null
  }

  export type ScreenTestMaxAggregateOutputType = {
    id: string | null
    multiTouch: boolean | null
    dotCoverage: boolean | null
    completed: boolean | null
    timestamp: Date | null
    deviceTestId: string | null
  }

  export type ScreenTestCountAggregateOutputType = {
    id: number
    multiTouch: number
    dotCoverage: number
    completed: number
    timestamp: number
    deviceTestId: number
    _all: number
  }


  export type ScreenTestMinAggregateInputType = {
    id?: true
    multiTouch?: true
    dotCoverage?: true
    completed?: true
    timestamp?: true
    deviceTestId?: true
  }

  export type ScreenTestMaxAggregateInputType = {
    id?: true
    multiTouch?: true
    dotCoverage?: true
    completed?: true
    timestamp?: true
    deviceTestId?: true
  }

  export type ScreenTestCountAggregateInputType = {
    id?: true
    multiTouch?: true
    dotCoverage?: true
    completed?: true
    timestamp?: true
    deviceTestId?: true
    _all?: true
  }

  export type ScreenTestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScreenTest to aggregate.
     */
    where?: ScreenTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScreenTests to fetch.
     */
    orderBy?: ScreenTestOrderByWithRelationInput | ScreenTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ScreenTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScreenTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScreenTests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ScreenTests
    **/
    _count?: true | ScreenTestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScreenTestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScreenTestMaxAggregateInputType
  }

  export type GetScreenTestAggregateType<T extends ScreenTestAggregateArgs> = {
        [P in keyof T & keyof AggregateScreenTest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateScreenTest[P]>
      : GetScalarType<T[P], AggregateScreenTest[P]>
  }




  export type ScreenTestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScreenTestWhereInput
    orderBy?: ScreenTestOrderByWithAggregationInput | ScreenTestOrderByWithAggregationInput[]
    by: ScreenTestScalarFieldEnum[] | ScreenTestScalarFieldEnum
    having?: ScreenTestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScreenTestCountAggregateInputType | true
    _min?: ScreenTestMinAggregateInputType
    _max?: ScreenTestMaxAggregateInputType
  }

  export type ScreenTestGroupByOutputType = {
    id: string
    multiTouch: boolean
    dotCoverage: boolean
    completed: boolean
    timestamp: Date | null
    deviceTestId: string
    _count: ScreenTestCountAggregateOutputType | null
    _min: ScreenTestMinAggregateOutputType | null
    _max: ScreenTestMaxAggregateOutputType | null
  }

  type GetScreenTestGroupByPayload<T extends ScreenTestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScreenTestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScreenTestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScreenTestGroupByOutputType[P]>
            : GetScalarType<T[P], ScreenTestGroupByOutputType[P]>
        }
      >
    >


  export type ScreenTestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    multiTouch?: boolean
    dotCoverage?: boolean
    completed?: boolean
    timestamp?: boolean
    deviceTestId?: boolean
    deviceTest?: boolean | DeviceTestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["screenTest"]>

  export type ScreenTestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    multiTouch?: boolean
    dotCoverage?: boolean
    completed?: boolean
    timestamp?: boolean
    deviceTestId?: boolean
    deviceTest?: boolean | DeviceTestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["screenTest"]>

  export type ScreenTestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    multiTouch?: boolean
    dotCoverage?: boolean
    completed?: boolean
    timestamp?: boolean
    deviceTestId?: boolean
    deviceTest?: boolean | DeviceTestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["screenTest"]>

  export type ScreenTestSelectScalar = {
    id?: boolean
    multiTouch?: boolean
    dotCoverage?: boolean
    completed?: boolean
    timestamp?: boolean
    deviceTestId?: boolean
  }

  export type ScreenTestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "multiTouch" | "dotCoverage" | "completed" | "timestamp" | "deviceTestId", ExtArgs["result"]["screenTest"]>
  export type ScreenTestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deviceTest?: boolean | DeviceTestDefaultArgs<ExtArgs>
  }
  export type ScreenTestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deviceTest?: boolean | DeviceTestDefaultArgs<ExtArgs>
  }
  export type ScreenTestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deviceTest?: boolean | DeviceTestDefaultArgs<ExtArgs>
  }

  export type $ScreenTestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ScreenTest"
    objects: {
      deviceTest: Prisma.$DeviceTestPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      multiTouch: boolean
      dotCoverage: boolean
      completed: boolean
      timestamp: Date | null
      deviceTestId: string
    }, ExtArgs["result"]["screenTest"]>
    composites: {}
  }

  type ScreenTestGetPayload<S extends boolean | null | undefined | ScreenTestDefaultArgs> = $Result.GetResult<Prisma.$ScreenTestPayload, S>

  type ScreenTestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ScreenTestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ScreenTestCountAggregateInputType | true
    }

  export interface ScreenTestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ScreenTest'], meta: { name: 'ScreenTest' } }
    /**
     * Find zero or one ScreenTest that matches the filter.
     * @param {ScreenTestFindUniqueArgs} args - Arguments to find a ScreenTest
     * @example
     * // Get one ScreenTest
     * const screenTest = await prisma.screenTest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ScreenTestFindUniqueArgs>(args: SelectSubset<T, ScreenTestFindUniqueArgs<ExtArgs>>): Prisma__ScreenTestClient<$Result.GetResult<Prisma.$ScreenTestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ScreenTest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ScreenTestFindUniqueOrThrowArgs} args - Arguments to find a ScreenTest
     * @example
     * // Get one ScreenTest
     * const screenTest = await prisma.screenTest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ScreenTestFindUniqueOrThrowArgs>(args: SelectSubset<T, ScreenTestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ScreenTestClient<$Result.GetResult<Prisma.$ScreenTestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ScreenTest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScreenTestFindFirstArgs} args - Arguments to find a ScreenTest
     * @example
     * // Get one ScreenTest
     * const screenTest = await prisma.screenTest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ScreenTestFindFirstArgs>(args?: SelectSubset<T, ScreenTestFindFirstArgs<ExtArgs>>): Prisma__ScreenTestClient<$Result.GetResult<Prisma.$ScreenTestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ScreenTest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScreenTestFindFirstOrThrowArgs} args - Arguments to find a ScreenTest
     * @example
     * // Get one ScreenTest
     * const screenTest = await prisma.screenTest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ScreenTestFindFirstOrThrowArgs>(args?: SelectSubset<T, ScreenTestFindFirstOrThrowArgs<ExtArgs>>): Prisma__ScreenTestClient<$Result.GetResult<Prisma.$ScreenTestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ScreenTests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScreenTestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ScreenTests
     * const screenTests = await prisma.screenTest.findMany()
     * 
     * // Get first 10 ScreenTests
     * const screenTests = await prisma.screenTest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const screenTestWithIdOnly = await prisma.screenTest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ScreenTestFindManyArgs>(args?: SelectSubset<T, ScreenTestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScreenTestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ScreenTest.
     * @param {ScreenTestCreateArgs} args - Arguments to create a ScreenTest.
     * @example
     * // Create one ScreenTest
     * const ScreenTest = await prisma.screenTest.create({
     *   data: {
     *     // ... data to create a ScreenTest
     *   }
     * })
     * 
     */
    create<T extends ScreenTestCreateArgs>(args: SelectSubset<T, ScreenTestCreateArgs<ExtArgs>>): Prisma__ScreenTestClient<$Result.GetResult<Prisma.$ScreenTestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ScreenTests.
     * @param {ScreenTestCreateManyArgs} args - Arguments to create many ScreenTests.
     * @example
     * // Create many ScreenTests
     * const screenTest = await prisma.screenTest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ScreenTestCreateManyArgs>(args?: SelectSubset<T, ScreenTestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ScreenTests and returns the data saved in the database.
     * @param {ScreenTestCreateManyAndReturnArgs} args - Arguments to create many ScreenTests.
     * @example
     * // Create many ScreenTests
     * const screenTest = await prisma.screenTest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ScreenTests and only return the `id`
     * const screenTestWithIdOnly = await prisma.screenTest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ScreenTestCreateManyAndReturnArgs>(args?: SelectSubset<T, ScreenTestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScreenTestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ScreenTest.
     * @param {ScreenTestDeleteArgs} args - Arguments to delete one ScreenTest.
     * @example
     * // Delete one ScreenTest
     * const ScreenTest = await prisma.screenTest.delete({
     *   where: {
     *     // ... filter to delete one ScreenTest
     *   }
     * })
     * 
     */
    delete<T extends ScreenTestDeleteArgs>(args: SelectSubset<T, ScreenTestDeleteArgs<ExtArgs>>): Prisma__ScreenTestClient<$Result.GetResult<Prisma.$ScreenTestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ScreenTest.
     * @param {ScreenTestUpdateArgs} args - Arguments to update one ScreenTest.
     * @example
     * // Update one ScreenTest
     * const screenTest = await prisma.screenTest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ScreenTestUpdateArgs>(args: SelectSubset<T, ScreenTestUpdateArgs<ExtArgs>>): Prisma__ScreenTestClient<$Result.GetResult<Prisma.$ScreenTestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ScreenTests.
     * @param {ScreenTestDeleteManyArgs} args - Arguments to filter ScreenTests to delete.
     * @example
     * // Delete a few ScreenTests
     * const { count } = await prisma.screenTest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ScreenTestDeleteManyArgs>(args?: SelectSubset<T, ScreenTestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ScreenTests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScreenTestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ScreenTests
     * const screenTest = await prisma.screenTest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ScreenTestUpdateManyArgs>(args: SelectSubset<T, ScreenTestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ScreenTests and returns the data updated in the database.
     * @param {ScreenTestUpdateManyAndReturnArgs} args - Arguments to update many ScreenTests.
     * @example
     * // Update many ScreenTests
     * const screenTest = await prisma.screenTest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ScreenTests and only return the `id`
     * const screenTestWithIdOnly = await prisma.screenTest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ScreenTestUpdateManyAndReturnArgs>(args: SelectSubset<T, ScreenTestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScreenTestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ScreenTest.
     * @param {ScreenTestUpsertArgs} args - Arguments to update or create a ScreenTest.
     * @example
     * // Update or create a ScreenTest
     * const screenTest = await prisma.screenTest.upsert({
     *   create: {
     *     // ... data to create a ScreenTest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ScreenTest we want to update
     *   }
     * })
     */
    upsert<T extends ScreenTestUpsertArgs>(args: SelectSubset<T, ScreenTestUpsertArgs<ExtArgs>>): Prisma__ScreenTestClient<$Result.GetResult<Prisma.$ScreenTestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ScreenTests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScreenTestCountArgs} args - Arguments to filter ScreenTests to count.
     * @example
     * // Count the number of ScreenTests
     * const count = await prisma.screenTest.count({
     *   where: {
     *     // ... the filter for the ScreenTests we want to count
     *   }
     * })
    **/
    count<T extends ScreenTestCountArgs>(
      args?: Subset<T, ScreenTestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScreenTestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ScreenTest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScreenTestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScreenTestAggregateArgs>(args: Subset<T, ScreenTestAggregateArgs>): Prisma.PrismaPromise<GetScreenTestAggregateType<T>>

    /**
     * Group by ScreenTest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScreenTestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ScreenTestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScreenTestGroupByArgs['orderBy'] }
        : { orderBy?: ScreenTestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ScreenTestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScreenTestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ScreenTest model
   */
  readonly fields: ScreenTestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ScreenTest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ScreenTestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    deviceTest<T extends DeviceTestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DeviceTestDefaultArgs<ExtArgs>>): Prisma__DeviceTestClient<$Result.GetResult<Prisma.$DeviceTestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ScreenTest model
   */
  interface ScreenTestFieldRefs {
    readonly id: FieldRef<"ScreenTest", 'String'>
    readonly multiTouch: FieldRef<"ScreenTest", 'Boolean'>
    readonly dotCoverage: FieldRef<"ScreenTest", 'Boolean'>
    readonly completed: FieldRef<"ScreenTest", 'Boolean'>
    readonly timestamp: FieldRef<"ScreenTest", 'DateTime'>
    readonly deviceTestId: FieldRef<"ScreenTest", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ScreenTest findUnique
   */
  export type ScreenTestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScreenTest
     */
    select?: ScreenTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScreenTest
     */
    omit?: ScreenTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenTestInclude<ExtArgs> | null
    /**
     * Filter, which ScreenTest to fetch.
     */
    where: ScreenTestWhereUniqueInput
  }

  /**
   * ScreenTest findUniqueOrThrow
   */
  export type ScreenTestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScreenTest
     */
    select?: ScreenTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScreenTest
     */
    omit?: ScreenTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenTestInclude<ExtArgs> | null
    /**
     * Filter, which ScreenTest to fetch.
     */
    where: ScreenTestWhereUniqueInput
  }

  /**
   * ScreenTest findFirst
   */
  export type ScreenTestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScreenTest
     */
    select?: ScreenTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScreenTest
     */
    omit?: ScreenTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenTestInclude<ExtArgs> | null
    /**
     * Filter, which ScreenTest to fetch.
     */
    where?: ScreenTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScreenTests to fetch.
     */
    orderBy?: ScreenTestOrderByWithRelationInput | ScreenTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScreenTests.
     */
    cursor?: ScreenTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScreenTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScreenTests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScreenTests.
     */
    distinct?: ScreenTestScalarFieldEnum | ScreenTestScalarFieldEnum[]
  }

  /**
   * ScreenTest findFirstOrThrow
   */
  export type ScreenTestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScreenTest
     */
    select?: ScreenTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScreenTest
     */
    omit?: ScreenTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenTestInclude<ExtArgs> | null
    /**
     * Filter, which ScreenTest to fetch.
     */
    where?: ScreenTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScreenTests to fetch.
     */
    orderBy?: ScreenTestOrderByWithRelationInput | ScreenTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScreenTests.
     */
    cursor?: ScreenTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScreenTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScreenTests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScreenTests.
     */
    distinct?: ScreenTestScalarFieldEnum | ScreenTestScalarFieldEnum[]
  }

  /**
   * ScreenTest findMany
   */
  export type ScreenTestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScreenTest
     */
    select?: ScreenTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScreenTest
     */
    omit?: ScreenTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenTestInclude<ExtArgs> | null
    /**
     * Filter, which ScreenTests to fetch.
     */
    where?: ScreenTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScreenTests to fetch.
     */
    orderBy?: ScreenTestOrderByWithRelationInput | ScreenTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ScreenTests.
     */
    cursor?: ScreenTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScreenTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScreenTests.
     */
    skip?: number
    distinct?: ScreenTestScalarFieldEnum | ScreenTestScalarFieldEnum[]
  }

  /**
   * ScreenTest create
   */
  export type ScreenTestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScreenTest
     */
    select?: ScreenTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScreenTest
     */
    omit?: ScreenTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenTestInclude<ExtArgs> | null
    /**
     * The data needed to create a ScreenTest.
     */
    data: XOR<ScreenTestCreateInput, ScreenTestUncheckedCreateInput>
  }

  /**
   * ScreenTest createMany
   */
  export type ScreenTestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ScreenTests.
     */
    data: ScreenTestCreateManyInput | ScreenTestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ScreenTest createManyAndReturn
   */
  export type ScreenTestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScreenTest
     */
    select?: ScreenTestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ScreenTest
     */
    omit?: ScreenTestOmit<ExtArgs> | null
    /**
     * The data used to create many ScreenTests.
     */
    data: ScreenTestCreateManyInput | ScreenTestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenTestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ScreenTest update
   */
  export type ScreenTestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScreenTest
     */
    select?: ScreenTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScreenTest
     */
    omit?: ScreenTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenTestInclude<ExtArgs> | null
    /**
     * The data needed to update a ScreenTest.
     */
    data: XOR<ScreenTestUpdateInput, ScreenTestUncheckedUpdateInput>
    /**
     * Choose, which ScreenTest to update.
     */
    where: ScreenTestWhereUniqueInput
  }

  /**
   * ScreenTest updateMany
   */
  export type ScreenTestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ScreenTests.
     */
    data: XOR<ScreenTestUpdateManyMutationInput, ScreenTestUncheckedUpdateManyInput>
    /**
     * Filter which ScreenTests to update
     */
    where?: ScreenTestWhereInput
    /**
     * Limit how many ScreenTests to update.
     */
    limit?: number
  }

  /**
   * ScreenTest updateManyAndReturn
   */
  export type ScreenTestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScreenTest
     */
    select?: ScreenTestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ScreenTest
     */
    omit?: ScreenTestOmit<ExtArgs> | null
    /**
     * The data used to update ScreenTests.
     */
    data: XOR<ScreenTestUpdateManyMutationInput, ScreenTestUncheckedUpdateManyInput>
    /**
     * Filter which ScreenTests to update
     */
    where?: ScreenTestWhereInput
    /**
     * Limit how many ScreenTests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenTestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ScreenTest upsert
   */
  export type ScreenTestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScreenTest
     */
    select?: ScreenTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScreenTest
     */
    omit?: ScreenTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenTestInclude<ExtArgs> | null
    /**
     * The filter to search for the ScreenTest to update in case it exists.
     */
    where: ScreenTestWhereUniqueInput
    /**
     * In case the ScreenTest found by the `where` argument doesn't exist, create a new ScreenTest with this data.
     */
    create: XOR<ScreenTestCreateInput, ScreenTestUncheckedCreateInput>
    /**
     * In case the ScreenTest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ScreenTestUpdateInput, ScreenTestUncheckedUpdateInput>
  }

  /**
   * ScreenTest delete
   */
  export type ScreenTestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScreenTest
     */
    select?: ScreenTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScreenTest
     */
    omit?: ScreenTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenTestInclude<ExtArgs> | null
    /**
     * Filter which ScreenTest to delete.
     */
    where: ScreenTestWhereUniqueInput
  }

  /**
   * ScreenTest deleteMany
   */
  export type ScreenTestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScreenTests to delete
     */
    where?: ScreenTestWhereInput
    /**
     * Limit how many ScreenTests to delete.
     */
    limit?: number
  }

  /**
   * ScreenTest without action
   */
  export type ScreenTestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScreenTest
     */
    select?: ScreenTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScreenTest
     */
    omit?: ScreenTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenTestInclude<ExtArgs> | null
  }


  /**
   * Model AudioTest
   */

  export type AggregateAudioTest = {
    _count: AudioTestCountAggregateOutputType | null
    _min: AudioTestMinAggregateOutputType | null
    _max: AudioTestMaxAggregateOutputType | null
  }

  export type AudioTestMinAggregateOutputType = {
    id: string | null
    speaker: boolean | null
    earReceiver: boolean | null
    microphone: boolean | null
    timestamp: Date | null
    deviceTestId: string | null
  }

  export type AudioTestMaxAggregateOutputType = {
    id: string | null
    speaker: boolean | null
    earReceiver: boolean | null
    microphone: boolean | null
    timestamp: Date | null
    deviceTestId: string | null
  }

  export type AudioTestCountAggregateOutputType = {
    id: number
    speaker: number
    earReceiver: number
    microphone: number
    timestamp: number
    deviceTestId: number
    _all: number
  }


  export type AudioTestMinAggregateInputType = {
    id?: true
    speaker?: true
    earReceiver?: true
    microphone?: true
    timestamp?: true
    deviceTestId?: true
  }

  export type AudioTestMaxAggregateInputType = {
    id?: true
    speaker?: true
    earReceiver?: true
    microphone?: true
    timestamp?: true
    deviceTestId?: true
  }

  export type AudioTestCountAggregateInputType = {
    id?: true
    speaker?: true
    earReceiver?: true
    microphone?: true
    timestamp?: true
    deviceTestId?: true
    _all?: true
  }

  export type AudioTestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AudioTest to aggregate.
     */
    where?: AudioTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AudioTests to fetch.
     */
    orderBy?: AudioTestOrderByWithRelationInput | AudioTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AudioTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AudioTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AudioTests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AudioTests
    **/
    _count?: true | AudioTestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AudioTestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AudioTestMaxAggregateInputType
  }

  export type GetAudioTestAggregateType<T extends AudioTestAggregateArgs> = {
        [P in keyof T & keyof AggregateAudioTest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAudioTest[P]>
      : GetScalarType<T[P], AggregateAudioTest[P]>
  }




  export type AudioTestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AudioTestWhereInput
    orderBy?: AudioTestOrderByWithAggregationInput | AudioTestOrderByWithAggregationInput[]
    by: AudioTestScalarFieldEnum[] | AudioTestScalarFieldEnum
    having?: AudioTestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AudioTestCountAggregateInputType | true
    _min?: AudioTestMinAggregateInputType
    _max?: AudioTestMaxAggregateInputType
  }

  export type AudioTestGroupByOutputType = {
    id: string
    speaker: boolean
    earReceiver: boolean
    microphone: boolean
    timestamp: Date | null
    deviceTestId: string
    _count: AudioTestCountAggregateOutputType | null
    _min: AudioTestMinAggregateOutputType | null
    _max: AudioTestMaxAggregateOutputType | null
  }

  type GetAudioTestGroupByPayload<T extends AudioTestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AudioTestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AudioTestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AudioTestGroupByOutputType[P]>
            : GetScalarType<T[P], AudioTestGroupByOutputType[P]>
        }
      >
    >


  export type AudioTestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    speaker?: boolean
    earReceiver?: boolean
    microphone?: boolean
    timestamp?: boolean
    deviceTestId?: boolean
    deviceTest?: boolean | DeviceTestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["audioTest"]>

  export type AudioTestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    speaker?: boolean
    earReceiver?: boolean
    microphone?: boolean
    timestamp?: boolean
    deviceTestId?: boolean
    deviceTest?: boolean | DeviceTestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["audioTest"]>

  export type AudioTestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    speaker?: boolean
    earReceiver?: boolean
    microphone?: boolean
    timestamp?: boolean
    deviceTestId?: boolean
    deviceTest?: boolean | DeviceTestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["audioTest"]>

  export type AudioTestSelectScalar = {
    id?: boolean
    speaker?: boolean
    earReceiver?: boolean
    microphone?: boolean
    timestamp?: boolean
    deviceTestId?: boolean
  }

  export type AudioTestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "speaker" | "earReceiver" | "microphone" | "timestamp" | "deviceTestId", ExtArgs["result"]["audioTest"]>
  export type AudioTestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deviceTest?: boolean | DeviceTestDefaultArgs<ExtArgs>
  }
  export type AudioTestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deviceTest?: boolean | DeviceTestDefaultArgs<ExtArgs>
  }
  export type AudioTestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deviceTest?: boolean | DeviceTestDefaultArgs<ExtArgs>
  }

  export type $AudioTestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AudioTest"
    objects: {
      deviceTest: Prisma.$DeviceTestPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      speaker: boolean
      earReceiver: boolean
      microphone: boolean
      timestamp: Date | null
      deviceTestId: string
    }, ExtArgs["result"]["audioTest"]>
    composites: {}
  }

  type AudioTestGetPayload<S extends boolean | null | undefined | AudioTestDefaultArgs> = $Result.GetResult<Prisma.$AudioTestPayload, S>

  type AudioTestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AudioTestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AudioTestCountAggregateInputType | true
    }

  export interface AudioTestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AudioTest'], meta: { name: 'AudioTest' } }
    /**
     * Find zero or one AudioTest that matches the filter.
     * @param {AudioTestFindUniqueArgs} args - Arguments to find a AudioTest
     * @example
     * // Get one AudioTest
     * const audioTest = await prisma.audioTest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AudioTestFindUniqueArgs>(args: SelectSubset<T, AudioTestFindUniqueArgs<ExtArgs>>): Prisma__AudioTestClient<$Result.GetResult<Prisma.$AudioTestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AudioTest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AudioTestFindUniqueOrThrowArgs} args - Arguments to find a AudioTest
     * @example
     * // Get one AudioTest
     * const audioTest = await prisma.audioTest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AudioTestFindUniqueOrThrowArgs>(args: SelectSubset<T, AudioTestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AudioTestClient<$Result.GetResult<Prisma.$AudioTestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AudioTest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioTestFindFirstArgs} args - Arguments to find a AudioTest
     * @example
     * // Get one AudioTest
     * const audioTest = await prisma.audioTest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AudioTestFindFirstArgs>(args?: SelectSubset<T, AudioTestFindFirstArgs<ExtArgs>>): Prisma__AudioTestClient<$Result.GetResult<Prisma.$AudioTestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AudioTest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioTestFindFirstOrThrowArgs} args - Arguments to find a AudioTest
     * @example
     * // Get one AudioTest
     * const audioTest = await prisma.audioTest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AudioTestFindFirstOrThrowArgs>(args?: SelectSubset<T, AudioTestFindFirstOrThrowArgs<ExtArgs>>): Prisma__AudioTestClient<$Result.GetResult<Prisma.$AudioTestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AudioTests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioTestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AudioTests
     * const audioTests = await prisma.audioTest.findMany()
     * 
     * // Get first 10 AudioTests
     * const audioTests = await prisma.audioTest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const audioTestWithIdOnly = await prisma.audioTest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AudioTestFindManyArgs>(args?: SelectSubset<T, AudioTestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AudioTestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AudioTest.
     * @param {AudioTestCreateArgs} args - Arguments to create a AudioTest.
     * @example
     * // Create one AudioTest
     * const AudioTest = await prisma.audioTest.create({
     *   data: {
     *     // ... data to create a AudioTest
     *   }
     * })
     * 
     */
    create<T extends AudioTestCreateArgs>(args: SelectSubset<T, AudioTestCreateArgs<ExtArgs>>): Prisma__AudioTestClient<$Result.GetResult<Prisma.$AudioTestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AudioTests.
     * @param {AudioTestCreateManyArgs} args - Arguments to create many AudioTests.
     * @example
     * // Create many AudioTests
     * const audioTest = await prisma.audioTest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AudioTestCreateManyArgs>(args?: SelectSubset<T, AudioTestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AudioTests and returns the data saved in the database.
     * @param {AudioTestCreateManyAndReturnArgs} args - Arguments to create many AudioTests.
     * @example
     * // Create many AudioTests
     * const audioTest = await prisma.audioTest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AudioTests and only return the `id`
     * const audioTestWithIdOnly = await prisma.audioTest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AudioTestCreateManyAndReturnArgs>(args?: SelectSubset<T, AudioTestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AudioTestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AudioTest.
     * @param {AudioTestDeleteArgs} args - Arguments to delete one AudioTest.
     * @example
     * // Delete one AudioTest
     * const AudioTest = await prisma.audioTest.delete({
     *   where: {
     *     // ... filter to delete one AudioTest
     *   }
     * })
     * 
     */
    delete<T extends AudioTestDeleteArgs>(args: SelectSubset<T, AudioTestDeleteArgs<ExtArgs>>): Prisma__AudioTestClient<$Result.GetResult<Prisma.$AudioTestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AudioTest.
     * @param {AudioTestUpdateArgs} args - Arguments to update one AudioTest.
     * @example
     * // Update one AudioTest
     * const audioTest = await prisma.audioTest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AudioTestUpdateArgs>(args: SelectSubset<T, AudioTestUpdateArgs<ExtArgs>>): Prisma__AudioTestClient<$Result.GetResult<Prisma.$AudioTestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AudioTests.
     * @param {AudioTestDeleteManyArgs} args - Arguments to filter AudioTests to delete.
     * @example
     * // Delete a few AudioTests
     * const { count } = await prisma.audioTest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AudioTestDeleteManyArgs>(args?: SelectSubset<T, AudioTestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AudioTests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioTestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AudioTests
     * const audioTest = await prisma.audioTest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AudioTestUpdateManyArgs>(args: SelectSubset<T, AudioTestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AudioTests and returns the data updated in the database.
     * @param {AudioTestUpdateManyAndReturnArgs} args - Arguments to update many AudioTests.
     * @example
     * // Update many AudioTests
     * const audioTest = await prisma.audioTest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AudioTests and only return the `id`
     * const audioTestWithIdOnly = await prisma.audioTest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AudioTestUpdateManyAndReturnArgs>(args: SelectSubset<T, AudioTestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AudioTestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AudioTest.
     * @param {AudioTestUpsertArgs} args - Arguments to update or create a AudioTest.
     * @example
     * // Update or create a AudioTest
     * const audioTest = await prisma.audioTest.upsert({
     *   create: {
     *     // ... data to create a AudioTest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AudioTest we want to update
     *   }
     * })
     */
    upsert<T extends AudioTestUpsertArgs>(args: SelectSubset<T, AudioTestUpsertArgs<ExtArgs>>): Prisma__AudioTestClient<$Result.GetResult<Prisma.$AudioTestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AudioTests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioTestCountArgs} args - Arguments to filter AudioTests to count.
     * @example
     * // Count the number of AudioTests
     * const count = await prisma.audioTest.count({
     *   where: {
     *     // ... the filter for the AudioTests we want to count
     *   }
     * })
    **/
    count<T extends AudioTestCountArgs>(
      args?: Subset<T, AudioTestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AudioTestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AudioTest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioTestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AudioTestAggregateArgs>(args: Subset<T, AudioTestAggregateArgs>): Prisma.PrismaPromise<GetAudioTestAggregateType<T>>

    /**
     * Group by AudioTest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioTestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AudioTestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AudioTestGroupByArgs['orderBy'] }
        : { orderBy?: AudioTestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AudioTestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAudioTestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AudioTest model
   */
  readonly fields: AudioTestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AudioTest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AudioTestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    deviceTest<T extends DeviceTestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DeviceTestDefaultArgs<ExtArgs>>): Prisma__DeviceTestClient<$Result.GetResult<Prisma.$DeviceTestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AudioTest model
   */
  interface AudioTestFieldRefs {
    readonly id: FieldRef<"AudioTest", 'String'>
    readonly speaker: FieldRef<"AudioTest", 'Boolean'>
    readonly earReceiver: FieldRef<"AudioTest", 'Boolean'>
    readonly microphone: FieldRef<"AudioTest", 'Boolean'>
    readonly timestamp: FieldRef<"AudioTest", 'DateTime'>
    readonly deviceTestId: FieldRef<"AudioTest", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AudioTest findUnique
   */
  export type AudioTestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioTest
     */
    select?: AudioTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AudioTest
     */
    omit?: AudioTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioTestInclude<ExtArgs> | null
    /**
     * Filter, which AudioTest to fetch.
     */
    where: AudioTestWhereUniqueInput
  }

  /**
   * AudioTest findUniqueOrThrow
   */
  export type AudioTestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioTest
     */
    select?: AudioTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AudioTest
     */
    omit?: AudioTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioTestInclude<ExtArgs> | null
    /**
     * Filter, which AudioTest to fetch.
     */
    where: AudioTestWhereUniqueInput
  }

  /**
   * AudioTest findFirst
   */
  export type AudioTestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioTest
     */
    select?: AudioTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AudioTest
     */
    omit?: AudioTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioTestInclude<ExtArgs> | null
    /**
     * Filter, which AudioTest to fetch.
     */
    where?: AudioTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AudioTests to fetch.
     */
    orderBy?: AudioTestOrderByWithRelationInput | AudioTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AudioTests.
     */
    cursor?: AudioTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AudioTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AudioTests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AudioTests.
     */
    distinct?: AudioTestScalarFieldEnum | AudioTestScalarFieldEnum[]
  }

  /**
   * AudioTest findFirstOrThrow
   */
  export type AudioTestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioTest
     */
    select?: AudioTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AudioTest
     */
    omit?: AudioTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioTestInclude<ExtArgs> | null
    /**
     * Filter, which AudioTest to fetch.
     */
    where?: AudioTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AudioTests to fetch.
     */
    orderBy?: AudioTestOrderByWithRelationInput | AudioTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AudioTests.
     */
    cursor?: AudioTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AudioTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AudioTests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AudioTests.
     */
    distinct?: AudioTestScalarFieldEnum | AudioTestScalarFieldEnum[]
  }

  /**
   * AudioTest findMany
   */
  export type AudioTestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioTest
     */
    select?: AudioTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AudioTest
     */
    omit?: AudioTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioTestInclude<ExtArgs> | null
    /**
     * Filter, which AudioTests to fetch.
     */
    where?: AudioTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AudioTests to fetch.
     */
    orderBy?: AudioTestOrderByWithRelationInput | AudioTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AudioTests.
     */
    cursor?: AudioTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AudioTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AudioTests.
     */
    skip?: number
    distinct?: AudioTestScalarFieldEnum | AudioTestScalarFieldEnum[]
  }

  /**
   * AudioTest create
   */
  export type AudioTestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioTest
     */
    select?: AudioTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AudioTest
     */
    omit?: AudioTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioTestInclude<ExtArgs> | null
    /**
     * The data needed to create a AudioTest.
     */
    data: XOR<AudioTestCreateInput, AudioTestUncheckedCreateInput>
  }

  /**
   * AudioTest createMany
   */
  export type AudioTestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AudioTests.
     */
    data: AudioTestCreateManyInput | AudioTestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AudioTest createManyAndReturn
   */
  export type AudioTestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioTest
     */
    select?: AudioTestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AudioTest
     */
    omit?: AudioTestOmit<ExtArgs> | null
    /**
     * The data used to create many AudioTests.
     */
    data: AudioTestCreateManyInput | AudioTestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioTestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AudioTest update
   */
  export type AudioTestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioTest
     */
    select?: AudioTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AudioTest
     */
    omit?: AudioTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioTestInclude<ExtArgs> | null
    /**
     * The data needed to update a AudioTest.
     */
    data: XOR<AudioTestUpdateInput, AudioTestUncheckedUpdateInput>
    /**
     * Choose, which AudioTest to update.
     */
    where: AudioTestWhereUniqueInput
  }

  /**
   * AudioTest updateMany
   */
  export type AudioTestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AudioTests.
     */
    data: XOR<AudioTestUpdateManyMutationInput, AudioTestUncheckedUpdateManyInput>
    /**
     * Filter which AudioTests to update
     */
    where?: AudioTestWhereInput
    /**
     * Limit how many AudioTests to update.
     */
    limit?: number
  }

  /**
   * AudioTest updateManyAndReturn
   */
  export type AudioTestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioTest
     */
    select?: AudioTestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AudioTest
     */
    omit?: AudioTestOmit<ExtArgs> | null
    /**
     * The data used to update AudioTests.
     */
    data: XOR<AudioTestUpdateManyMutationInput, AudioTestUncheckedUpdateManyInput>
    /**
     * Filter which AudioTests to update
     */
    where?: AudioTestWhereInput
    /**
     * Limit how many AudioTests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioTestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AudioTest upsert
   */
  export type AudioTestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioTest
     */
    select?: AudioTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AudioTest
     */
    omit?: AudioTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioTestInclude<ExtArgs> | null
    /**
     * The filter to search for the AudioTest to update in case it exists.
     */
    where: AudioTestWhereUniqueInput
    /**
     * In case the AudioTest found by the `where` argument doesn't exist, create a new AudioTest with this data.
     */
    create: XOR<AudioTestCreateInput, AudioTestUncheckedCreateInput>
    /**
     * In case the AudioTest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AudioTestUpdateInput, AudioTestUncheckedUpdateInput>
  }

  /**
   * AudioTest delete
   */
  export type AudioTestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioTest
     */
    select?: AudioTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AudioTest
     */
    omit?: AudioTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioTestInclude<ExtArgs> | null
    /**
     * Filter which AudioTest to delete.
     */
    where: AudioTestWhereUniqueInput
  }

  /**
   * AudioTest deleteMany
   */
  export type AudioTestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AudioTests to delete
     */
    where?: AudioTestWhereInput
    /**
     * Limit how many AudioTests to delete.
     */
    limit?: number
  }

  /**
   * AudioTest without action
   */
  export type AudioTestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioTest
     */
    select?: AudioTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AudioTest
     */
    omit?: AudioTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioTestInclude<ExtArgs> | null
  }


  /**
   * Model ProximitySensorTest
   */

  export type AggregateProximitySensorTest = {
    _count: ProximitySensorTestCountAggregateOutputType | null
    _min: ProximitySensorTestMinAggregateOutputType | null
    _max: ProximitySensorTestMaxAggregateOutputType | null
  }

  export type ProximitySensorTestMinAggregateOutputType = {
    id: string | null
    status: boolean | null
    message: string | null
    timestamp: Date | null
    deviceTestId: string | null
  }

  export type ProximitySensorTestMaxAggregateOutputType = {
    id: string | null
    status: boolean | null
    message: string | null
    timestamp: Date | null
    deviceTestId: string | null
  }

  export type ProximitySensorTestCountAggregateOutputType = {
    id: number
    status: number
    message: number
    timestamp: number
    deviceTestId: number
    _all: number
  }


  export type ProximitySensorTestMinAggregateInputType = {
    id?: true
    status?: true
    message?: true
    timestamp?: true
    deviceTestId?: true
  }

  export type ProximitySensorTestMaxAggregateInputType = {
    id?: true
    status?: true
    message?: true
    timestamp?: true
    deviceTestId?: true
  }

  export type ProximitySensorTestCountAggregateInputType = {
    id?: true
    status?: true
    message?: true
    timestamp?: true
    deviceTestId?: true
    _all?: true
  }

  export type ProximitySensorTestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProximitySensorTest to aggregate.
     */
    where?: ProximitySensorTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProximitySensorTests to fetch.
     */
    orderBy?: ProximitySensorTestOrderByWithRelationInput | ProximitySensorTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProximitySensorTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProximitySensorTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProximitySensorTests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProximitySensorTests
    **/
    _count?: true | ProximitySensorTestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProximitySensorTestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProximitySensorTestMaxAggregateInputType
  }

  export type GetProximitySensorTestAggregateType<T extends ProximitySensorTestAggregateArgs> = {
        [P in keyof T & keyof AggregateProximitySensorTest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProximitySensorTest[P]>
      : GetScalarType<T[P], AggregateProximitySensorTest[P]>
  }




  export type ProximitySensorTestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProximitySensorTestWhereInput
    orderBy?: ProximitySensorTestOrderByWithAggregationInput | ProximitySensorTestOrderByWithAggregationInput[]
    by: ProximitySensorTestScalarFieldEnum[] | ProximitySensorTestScalarFieldEnum
    having?: ProximitySensorTestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProximitySensorTestCountAggregateInputType | true
    _min?: ProximitySensorTestMinAggregateInputType
    _max?: ProximitySensorTestMaxAggregateInputType
  }

  export type ProximitySensorTestGroupByOutputType = {
    id: string
    status: boolean
    message: string | null
    timestamp: Date | null
    deviceTestId: string
    _count: ProximitySensorTestCountAggregateOutputType | null
    _min: ProximitySensorTestMinAggregateOutputType | null
    _max: ProximitySensorTestMaxAggregateOutputType | null
  }

  type GetProximitySensorTestGroupByPayload<T extends ProximitySensorTestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProximitySensorTestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProximitySensorTestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProximitySensorTestGroupByOutputType[P]>
            : GetScalarType<T[P], ProximitySensorTestGroupByOutputType[P]>
        }
      >
    >


  export type ProximitySensorTestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    message?: boolean
    timestamp?: boolean
    deviceTestId?: boolean
    deviceTest?: boolean | DeviceTestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["proximitySensorTest"]>

  export type ProximitySensorTestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    message?: boolean
    timestamp?: boolean
    deviceTestId?: boolean
    deviceTest?: boolean | DeviceTestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["proximitySensorTest"]>

  export type ProximitySensorTestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    message?: boolean
    timestamp?: boolean
    deviceTestId?: boolean
    deviceTest?: boolean | DeviceTestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["proximitySensorTest"]>

  export type ProximitySensorTestSelectScalar = {
    id?: boolean
    status?: boolean
    message?: boolean
    timestamp?: boolean
    deviceTestId?: boolean
  }

  export type ProximitySensorTestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "status" | "message" | "timestamp" | "deviceTestId", ExtArgs["result"]["proximitySensorTest"]>
  export type ProximitySensorTestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deviceTest?: boolean | DeviceTestDefaultArgs<ExtArgs>
  }
  export type ProximitySensorTestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deviceTest?: boolean | DeviceTestDefaultArgs<ExtArgs>
  }
  export type ProximitySensorTestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deviceTest?: boolean | DeviceTestDefaultArgs<ExtArgs>
  }

  export type $ProximitySensorTestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProximitySensorTest"
    objects: {
      deviceTest: Prisma.$DeviceTestPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      status: boolean
      message: string | null
      timestamp: Date | null
      deviceTestId: string
    }, ExtArgs["result"]["proximitySensorTest"]>
    composites: {}
  }

  type ProximitySensorTestGetPayload<S extends boolean | null | undefined | ProximitySensorTestDefaultArgs> = $Result.GetResult<Prisma.$ProximitySensorTestPayload, S>

  type ProximitySensorTestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProximitySensorTestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProximitySensorTestCountAggregateInputType | true
    }

  export interface ProximitySensorTestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProximitySensorTest'], meta: { name: 'ProximitySensorTest' } }
    /**
     * Find zero or one ProximitySensorTest that matches the filter.
     * @param {ProximitySensorTestFindUniqueArgs} args - Arguments to find a ProximitySensorTest
     * @example
     * // Get one ProximitySensorTest
     * const proximitySensorTest = await prisma.proximitySensorTest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProximitySensorTestFindUniqueArgs>(args: SelectSubset<T, ProximitySensorTestFindUniqueArgs<ExtArgs>>): Prisma__ProximitySensorTestClient<$Result.GetResult<Prisma.$ProximitySensorTestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProximitySensorTest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProximitySensorTestFindUniqueOrThrowArgs} args - Arguments to find a ProximitySensorTest
     * @example
     * // Get one ProximitySensorTest
     * const proximitySensorTest = await prisma.proximitySensorTest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProximitySensorTestFindUniqueOrThrowArgs>(args: SelectSubset<T, ProximitySensorTestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProximitySensorTestClient<$Result.GetResult<Prisma.$ProximitySensorTestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProximitySensorTest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProximitySensorTestFindFirstArgs} args - Arguments to find a ProximitySensorTest
     * @example
     * // Get one ProximitySensorTest
     * const proximitySensorTest = await prisma.proximitySensorTest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProximitySensorTestFindFirstArgs>(args?: SelectSubset<T, ProximitySensorTestFindFirstArgs<ExtArgs>>): Prisma__ProximitySensorTestClient<$Result.GetResult<Prisma.$ProximitySensorTestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProximitySensorTest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProximitySensorTestFindFirstOrThrowArgs} args - Arguments to find a ProximitySensorTest
     * @example
     * // Get one ProximitySensorTest
     * const proximitySensorTest = await prisma.proximitySensorTest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProximitySensorTestFindFirstOrThrowArgs>(args?: SelectSubset<T, ProximitySensorTestFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProximitySensorTestClient<$Result.GetResult<Prisma.$ProximitySensorTestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProximitySensorTests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProximitySensorTestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProximitySensorTests
     * const proximitySensorTests = await prisma.proximitySensorTest.findMany()
     * 
     * // Get first 10 ProximitySensorTests
     * const proximitySensorTests = await prisma.proximitySensorTest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const proximitySensorTestWithIdOnly = await prisma.proximitySensorTest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProximitySensorTestFindManyArgs>(args?: SelectSubset<T, ProximitySensorTestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProximitySensorTestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProximitySensorTest.
     * @param {ProximitySensorTestCreateArgs} args - Arguments to create a ProximitySensorTest.
     * @example
     * // Create one ProximitySensorTest
     * const ProximitySensorTest = await prisma.proximitySensorTest.create({
     *   data: {
     *     // ... data to create a ProximitySensorTest
     *   }
     * })
     * 
     */
    create<T extends ProximitySensorTestCreateArgs>(args: SelectSubset<T, ProximitySensorTestCreateArgs<ExtArgs>>): Prisma__ProximitySensorTestClient<$Result.GetResult<Prisma.$ProximitySensorTestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProximitySensorTests.
     * @param {ProximitySensorTestCreateManyArgs} args - Arguments to create many ProximitySensorTests.
     * @example
     * // Create many ProximitySensorTests
     * const proximitySensorTest = await prisma.proximitySensorTest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProximitySensorTestCreateManyArgs>(args?: SelectSubset<T, ProximitySensorTestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProximitySensorTests and returns the data saved in the database.
     * @param {ProximitySensorTestCreateManyAndReturnArgs} args - Arguments to create many ProximitySensorTests.
     * @example
     * // Create many ProximitySensorTests
     * const proximitySensorTest = await prisma.proximitySensorTest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProximitySensorTests and only return the `id`
     * const proximitySensorTestWithIdOnly = await prisma.proximitySensorTest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProximitySensorTestCreateManyAndReturnArgs>(args?: SelectSubset<T, ProximitySensorTestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProximitySensorTestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProximitySensorTest.
     * @param {ProximitySensorTestDeleteArgs} args - Arguments to delete one ProximitySensorTest.
     * @example
     * // Delete one ProximitySensorTest
     * const ProximitySensorTest = await prisma.proximitySensorTest.delete({
     *   where: {
     *     // ... filter to delete one ProximitySensorTest
     *   }
     * })
     * 
     */
    delete<T extends ProximitySensorTestDeleteArgs>(args: SelectSubset<T, ProximitySensorTestDeleteArgs<ExtArgs>>): Prisma__ProximitySensorTestClient<$Result.GetResult<Prisma.$ProximitySensorTestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProximitySensorTest.
     * @param {ProximitySensorTestUpdateArgs} args - Arguments to update one ProximitySensorTest.
     * @example
     * // Update one ProximitySensorTest
     * const proximitySensorTest = await prisma.proximitySensorTest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProximitySensorTestUpdateArgs>(args: SelectSubset<T, ProximitySensorTestUpdateArgs<ExtArgs>>): Prisma__ProximitySensorTestClient<$Result.GetResult<Prisma.$ProximitySensorTestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProximitySensorTests.
     * @param {ProximitySensorTestDeleteManyArgs} args - Arguments to filter ProximitySensorTests to delete.
     * @example
     * // Delete a few ProximitySensorTests
     * const { count } = await prisma.proximitySensorTest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProximitySensorTestDeleteManyArgs>(args?: SelectSubset<T, ProximitySensorTestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProximitySensorTests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProximitySensorTestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProximitySensorTests
     * const proximitySensorTest = await prisma.proximitySensorTest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProximitySensorTestUpdateManyArgs>(args: SelectSubset<T, ProximitySensorTestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProximitySensorTests and returns the data updated in the database.
     * @param {ProximitySensorTestUpdateManyAndReturnArgs} args - Arguments to update many ProximitySensorTests.
     * @example
     * // Update many ProximitySensorTests
     * const proximitySensorTest = await prisma.proximitySensorTest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProximitySensorTests and only return the `id`
     * const proximitySensorTestWithIdOnly = await prisma.proximitySensorTest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProximitySensorTestUpdateManyAndReturnArgs>(args: SelectSubset<T, ProximitySensorTestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProximitySensorTestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProximitySensorTest.
     * @param {ProximitySensorTestUpsertArgs} args - Arguments to update or create a ProximitySensorTest.
     * @example
     * // Update or create a ProximitySensorTest
     * const proximitySensorTest = await prisma.proximitySensorTest.upsert({
     *   create: {
     *     // ... data to create a ProximitySensorTest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProximitySensorTest we want to update
     *   }
     * })
     */
    upsert<T extends ProximitySensorTestUpsertArgs>(args: SelectSubset<T, ProximitySensorTestUpsertArgs<ExtArgs>>): Prisma__ProximitySensorTestClient<$Result.GetResult<Prisma.$ProximitySensorTestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProximitySensorTests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProximitySensorTestCountArgs} args - Arguments to filter ProximitySensorTests to count.
     * @example
     * // Count the number of ProximitySensorTests
     * const count = await prisma.proximitySensorTest.count({
     *   where: {
     *     // ... the filter for the ProximitySensorTests we want to count
     *   }
     * })
    **/
    count<T extends ProximitySensorTestCountArgs>(
      args?: Subset<T, ProximitySensorTestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProximitySensorTestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProximitySensorTest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProximitySensorTestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProximitySensorTestAggregateArgs>(args: Subset<T, ProximitySensorTestAggregateArgs>): Prisma.PrismaPromise<GetProximitySensorTestAggregateType<T>>

    /**
     * Group by ProximitySensorTest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProximitySensorTestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProximitySensorTestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProximitySensorTestGroupByArgs['orderBy'] }
        : { orderBy?: ProximitySensorTestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProximitySensorTestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProximitySensorTestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProximitySensorTest model
   */
  readonly fields: ProximitySensorTestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProximitySensorTest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProximitySensorTestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    deviceTest<T extends DeviceTestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DeviceTestDefaultArgs<ExtArgs>>): Prisma__DeviceTestClient<$Result.GetResult<Prisma.$DeviceTestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProximitySensorTest model
   */
  interface ProximitySensorTestFieldRefs {
    readonly id: FieldRef<"ProximitySensorTest", 'String'>
    readonly status: FieldRef<"ProximitySensorTest", 'Boolean'>
    readonly message: FieldRef<"ProximitySensorTest", 'String'>
    readonly timestamp: FieldRef<"ProximitySensorTest", 'DateTime'>
    readonly deviceTestId: FieldRef<"ProximitySensorTest", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ProximitySensorTest findUnique
   */
  export type ProximitySensorTestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProximitySensorTest
     */
    select?: ProximitySensorTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProximitySensorTest
     */
    omit?: ProximitySensorTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProximitySensorTestInclude<ExtArgs> | null
    /**
     * Filter, which ProximitySensorTest to fetch.
     */
    where: ProximitySensorTestWhereUniqueInput
  }

  /**
   * ProximitySensorTest findUniqueOrThrow
   */
  export type ProximitySensorTestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProximitySensorTest
     */
    select?: ProximitySensorTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProximitySensorTest
     */
    omit?: ProximitySensorTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProximitySensorTestInclude<ExtArgs> | null
    /**
     * Filter, which ProximitySensorTest to fetch.
     */
    where: ProximitySensorTestWhereUniqueInput
  }

  /**
   * ProximitySensorTest findFirst
   */
  export type ProximitySensorTestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProximitySensorTest
     */
    select?: ProximitySensorTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProximitySensorTest
     */
    omit?: ProximitySensorTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProximitySensorTestInclude<ExtArgs> | null
    /**
     * Filter, which ProximitySensorTest to fetch.
     */
    where?: ProximitySensorTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProximitySensorTests to fetch.
     */
    orderBy?: ProximitySensorTestOrderByWithRelationInput | ProximitySensorTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProximitySensorTests.
     */
    cursor?: ProximitySensorTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProximitySensorTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProximitySensorTests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProximitySensorTests.
     */
    distinct?: ProximitySensorTestScalarFieldEnum | ProximitySensorTestScalarFieldEnum[]
  }

  /**
   * ProximitySensorTest findFirstOrThrow
   */
  export type ProximitySensorTestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProximitySensorTest
     */
    select?: ProximitySensorTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProximitySensorTest
     */
    omit?: ProximitySensorTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProximitySensorTestInclude<ExtArgs> | null
    /**
     * Filter, which ProximitySensorTest to fetch.
     */
    where?: ProximitySensorTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProximitySensorTests to fetch.
     */
    orderBy?: ProximitySensorTestOrderByWithRelationInput | ProximitySensorTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProximitySensorTests.
     */
    cursor?: ProximitySensorTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProximitySensorTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProximitySensorTests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProximitySensorTests.
     */
    distinct?: ProximitySensorTestScalarFieldEnum | ProximitySensorTestScalarFieldEnum[]
  }

  /**
   * ProximitySensorTest findMany
   */
  export type ProximitySensorTestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProximitySensorTest
     */
    select?: ProximitySensorTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProximitySensorTest
     */
    omit?: ProximitySensorTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProximitySensorTestInclude<ExtArgs> | null
    /**
     * Filter, which ProximitySensorTests to fetch.
     */
    where?: ProximitySensorTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProximitySensorTests to fetch.
     */
    orderBy?: ProximitySensorTestOrderByWithRelationInput | ProximitySensorTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProximitySensorTests.
     */
    cursor?: ProximitySensorTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProximitySensorTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProximitySensorTests.
     */
    skip?: number
    distinct?: ProximitySensorTestScalarFieldEnum | ProximitySensorTestScalarFieldEnum[]
  }

  /**
   * ProximitySensorTest create
   */
  export type ProximitySensorTestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProximitySensorTest
     */
    select?: ProximitySensorTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProximitySensorTest
     */
    omit?: ProximitySensorTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProximitySensorTestInclude<ExtArgs> | null
    /**
     * The data needed to create a ProximitySensorTest.
     */
    data: XOR<ProximitySensorTestCreateInput, ProximitySensorTestUncheckedCreateInput>
  }

  /**
   * ProximitySensorTest createMany
   */
  export type ProximitySensorTestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProximitySensorTests.
     */
    data: ProximitySensorTestCreateManyInput | ProximitySensorTestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProximitySensorTest createManyAndReturn
   */
  export type ProximitySensorTestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProximitySensorTest
     */
    select?: ProximitySensorTestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProximitySensorTest
     */
    omit?: ProximitySensorTestOmit<ExtArgs> | null
    /**
     * The data used to create many ProximitySensorTests.
     */
    data: ProximitySensorTestCreateManyInput | ProximitySensorTestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProximitySensorTestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProximitySensorTest update
   */
  export type ProximitySensorTestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProximitySensorTest
     */
    select?: ProximitySensorTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProximitySensorTest
     */
    omit?: ProximitySensorTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProximitySensorTestInclude<ExtArgs> | null
    /**
     * The data needed to update a ProximitySensorTest.
     */
    data: XOR<ProximitySensorTestUpdateInput, ProximitySensorTestUncheckedUpdateInput>
    /**
     * Choose, which ProximitySensorTest to update.
     */
    where: ProximitySensorTestWhereUniqueInput
  }

  /**
   * ProximitySensorTest updateMany
   */
  export type ProximitySensorTestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProximitySensorTests.
     */
    data: XOR<ProximitySensorTestUpdateManyMutationInput, ProximitySensorTestUncheckedUpdateManyInput>
    /**
     * Filter which ProximitySensorTests to update
     */
    where?: ProximitySensorTestWhereInput
    /**
     * Limit how many ProximitySensorTests to update.
     */
    limit?: number
  }

  /**
   * ProximitySensorTest updateManyAndReturn
   */
  export type ProximitySensorTestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProximitySensorTest
     */
    select?: ProximitySensorTestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProximitySensorTest
     */
    omit?: ProximitySensorTestOmit<ExtArgs> | null
    /**
     * The data used to update ProximitySensorTests.
     */
    data: XOR<ProximitySensorTestUpdateManyMutationInput, ProximitySensorTestUncheckedUpdateManyInput>
    /**
     * Filter which ProximitySensorTests to update
     */
    where?: ProximitySensorTestWhereInput
    /**
     * Limit how many ProximitySensorTests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProximitySensorTestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProximitySensorTest upsert
   */
  export type ProximitySensorTestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProximitySensorTest
     */
    select?: ProximitySensorTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProximitySensorTest
     */
    omit?: ProximitySensorTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProximitySensorTestInclude<ExtArgs> | null
    /**
     * The filter to search for the ProximitySensorTest to update in case it exists.
     */
    where: ProximitySensorTestWhereUniqueInput
    /**
     * In case the ProximitySensorTest found by the `where` argument doesn't exist, create a new ProximitySensorTest with this data.
     */
    create: XOR<ProximitySensorTestCreateInput, ProximitySensorTestUncheckedCreateInput>
    /**
     * In case the ProximitySensorTest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProximitySensorTestUpdateInput, ProximitySensorTestUncheckedUpdateInput>
  }

  /**
   * ProximitySensorTest delete
   */
  export type ProximitySensorTestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProximitySensorTest
     */
    select?: ProximitySensorTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProximitySensorTest
     */
    omit?: ProximitySensorTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProximitySensorTestInclude<ExtArgs> | null
    /**
     * Filter which ProximitySensorTest to delete.
     */
    where: ProximitySensorTestWhereUniqueInput
  }

  /**
   * ProximitySensorTest deleteMany
   */
  export type ProximitySensorTestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProximitySensorTests to delete
     */
    where?: ProximitySensorTestWhereInput
    /**
     * Limit how many ProximitySensorTests to delete.
     */
    limit?: number
  }

  /**
   * ProximitySensorTest without action
   */
  export type ProximitySensorTestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProximitySensorTest
     */
    select?: ProximitySensorTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProximitySensorTest
     */
    omit?: ProximitySensorTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProximitySensorTestInclude<ExtArgs> | null
  }


  /**
   * Model CameraTest
   */

  export type AggregateCameraTest = {
    _count: CameraTestCountAggregateOutputType | null
    _min: CameraTestMinAggregateOutputType | null
    _max: CameraTestMaxAggregateOutputType | null
  }

  export type CameraTestMinAggregateOutputType = {
    id: string | null
    frontCamera: boolean | null
    backCamera: boolean | null
    timestamp: Date | null
    deviceTestId: string | null
  }

  export type CameraTestMaxAggregateOutputType = {
    id: string | null
    frontCamera: boolean | null
    backCamera: boolean | null
    timestamp: Date | null
    deviceTestId: string | null
  }

  export type CameraTestCountAggregateOutputType = {
    id: number
    frontCamera: number
    backCamera: number
    timestamp: number
    deviceTestId: number
    _all: number
  }


  export type CameraTestMinAggregateInputType = {
    id?: true
    frontCamera?: true
    backCamera?: true
    timestamp?: true
    deviceTestId?: true
  }

  export type CameraTestMaxAggregateInputType = {
    id?: true
    frontCamera?: true
    backCamera?: true
    timestamp?: true
    deviceTestId?: true
  }

  export type CameraTestCountAggregateInputType = {
    id?: true
    frontCamera?: true
    backCamera?: true
    timestamp?: true
    deviceTestId?: true
    _all?: true
  }

  export type CameraTestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CameraTest to aggregate.
     */
    where?: CameraTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CameraTests to fetch.
     */
    orderBy?: CameraTestOrderByWithRelationInput | CameraTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CameraTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CameraTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CameraTests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CameraTests
    **/
    _count?: true | CameraTestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CameraTestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CameraTestMaxAggregateInputType
  }

  export type GetCameraTestAggregateType<T extends CameraTestAggregateArgs> = {
        [P in keyof T & keyof AggregateCameraTest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCameraTest[P]>
      : GetScalarType<T[P], AggregateCameraTest[P]>
  }




  export type CameraTestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CameraTestWhereInput
    orderBy?: CameraTestOrderByWithAggregationInput | CameraTestOrderByWithAggregationInput[]
    by: CameraTestScalarFieldEnum[] | CameraTestScalarFieldEnum
    having?: CameraTestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CameraTestCountAggregateInputType | true
    _min?: CameraTestMinAggregateInputType
    _max?: CameraTestMaxAggregateInputType
  }

  export type CameraTestGroupByOutputType = {
    id: string
    frontCamera: boolean
    backCamera: boolean
    timestamp: Date | null
    deviceTestId: string
    _count: CameraTestCountAggregateOutputType | null
    _min: CameraTestMinAggregateOutputType | null
    _max: CameraTestMaxAggregateOutputType | null
  }

  type GetCameraTestGroupByPayload<T extends CameraTestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CameraTestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CameraTestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CameraTestGroupByOutputType[P]>
            : GetScalarType<T[P], CameraTestGroupByOutputType[P]>
        }
      >
    >


  export type CameraTestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    frontCamera?: boolean
    backCamera?: boolean
    timestamp?: boolean
    deviceTestId?: boolean
    deviceTest?: boolean | DeviceTestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cameraTest"]>

  export type CameraTestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    frontCamera?: boolean
    backCamera?: boolean
    timestamp?: boolean
    deviceTestId?: boolean
    deviceTest?: boolean | DeviceTestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cameraTest"]>

  export type CameraTestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    frontCamera?: boolean
    backCamera?: boolean
    timestamp?: boolean
    deviceTestId?: boolean
    deviceTest?: boolean | DeviceTestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cameraTest"]>

  export type CameraTestSelectScalar = {
    id?: boolean
    frontCamera?: boolean
    backCamera?: boolean
    timestamp?: boolean
    deviceTestId?: boolean
  }

  export type CameraTestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "frontCamera" | "backCamera" | "timestamp" | "deviceTestId", ExtArgs["result"]["cameraTest"]>
  export type CameraTestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deviceTest?: boolean | DeviceTestDefaultArgs<ExtArgs>
  }
  export type CameraTestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deviceTest?: boolean | DeviceTestDefaultArgs<ExtArgs>
  }
  export type CameraTestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deviceTest?: boolean | DeviceTestDefaultArgs<ExtArgs>
  }

  export type $CameraTestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CameraTest"
    objects: {
      deviceTest: Prisma.$DeviceTestPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      frontCamera: boolean
      backCamera: boolean
      timestamp: Date | null
      deviceTestId: string
    }, ExtArgs["result"]["cameraTest"]>
    composites: {}
  }

  type CameraTestGetPayload<S extends boolean | null | undefined | CameraTestDefaultArgs> = $Result.GetResult<Prisma.$CameraTestPayload, S>

  type CameraTestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CameraTestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CameraTestCountAggregateInputType | true
    }

  export interface CameraTestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CameraTest'], meta: { name: 'CameraTest' } }
    /**
     * Find zero or one CameraTest that matches the filter.
     * @param {CameraTestFindUniqueArgs} args - Arguments to find a CameraTest
     * @example
     * // Get one CameraTest
     * const cameraTest = await prisma.cameraTest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CameraTestFindUniqueArgs>(args: SelectSubset<T, CameraTestFindUniqueArgs<ExtArgs>>): Prisma__CameraTestClient<$Result.GetResult<Prisma.$CameraTestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CameraTest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CameraTestFindUniqueOrThrowArgs} args - Arguments to find a CameraTest
     * @example
     * // Get one CameraTest
     * const cameraTest = await prisma.cameraTest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CameraTestFindUniqueOrThrowArgs>(args: SelectSubset<T, CameraTestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CameraTestClient<$Result.GetResult<Prisma.$CameraTestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CameraTest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CameraTestFindFirstArgs} args - Arguments to find a CameraTest
     * @example
     * // Get one CameraTest
     * const cameraTest = await prisma.cameraTest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CameraTestFindFirstArgs>(args?: SelectSubset<T, CameraTestFindFirstArgs<ExtArgs>>): Prisma__CameraTestClient<$Result.GetResult<Prisma.$CameraTestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CameraTest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CameraTestFindFirstOrThrowArgs} args - Arguments to find a CameraTest
     * @example
     * // Get one CameraTest
     * const cameraTest = await prisma.cameraTest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CameraTestFindFirstOrThrowArgs>(args?: SelectSubset<T, CameraTestFindFirstOrThrowArgs<ExtArgs>>): Prisma__CameraTestClient<$Result.GetResult<Prisma.$CameraTestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CameraTests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CameraTestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CameraTests
     * const cameraTests = await prisma.cameraTest.findMany()
     * 
     * // Get first 10 CameraTests
     * const cameraTests = await prisma.cameraTest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cameraTestWithIdOnly = await prisma.cameraTest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CameraTestFindManyArgs>(args?: SelectSubset<T, CameraTestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CameraTestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CameraTest.
     * @param {CameraTestCreateArgs} args - Arguments to create a CameraTest.
     * @example
     * // Create one CameraTest
     * const CameraTest = await prisma.cameraTest.create({
     *   data: {
     *     // ... data to create a CameraTest
     *   }
     * })
     * 
     */
    create<T extends CameraTestCreateArgs>(args: SelectSubset<T, CameraTestCreateArgs<ExtArgs>>): Prisma__CameraTestClient<$Result.GetResult<Prisma.$CameraTestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CameraTests.
     * @param {CameraTestCreateManyArgs} args - Arguments to create many CameraTests.
     * @example
     * // Create many CameraTests
     * const cameraTest = await prisma.cameraTest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CameraTestCreateManyArgs>(args?: SelectSubset<T, CameraTestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CameraTests and returns the data saved in the database.
     * @param {CameraTestCreateManyAndReturnArgs} args - Arguments to create many CameraTests.
     * @example
     * // Create many CameraTests
     * const cameraTest = await prisma.cameraTest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CameraTests and only return the `id`
     * const cameraTestWithIdOnly = await prisma.cameraTest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CameraTestCreateManyAndReturnArgs>(args?: SelectSubset<T, CameraTestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CameraTestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CameraTest.
     * @param {CameraTestDeleteArgs} args - Arguments to delete one CameraTest.
     * @example
     * // Delete one CameraTest
     * const CameraTest = await prisma.cameraTest.delete({
     *   where: {
     *     // ... filter to delete one CameraTest
     *   }
     * })
     * 
     */
    delete<T extends CameraTestDeleteArgs>(args: SelectSubset<T, CameraTestDeleteArgs<ExtArgs>>): Prisma__CameraTestClient<$Result.GetResult<Prisma.$CameraTestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CameraTest.
     * @param {CameraTestUpdateArgs} args - Arguments to update one CameraTest.
     * @example
     * // Update one CameraTest
     * const cameraTest = await prisma.cameraTest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CameraTestUpdateArgs>(args: SelectSubset<T, CameraTestUpdateArgs<ExtArgs>>): Prisma__CameraTestClient<$Result.GetResult<Prisma.$CameraTestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CameraTests.
     * @param {CameraTestDeleteManyArgs} args - Arguments to filter CameraTests to delete.
     * @example
     * // Delete a few CameraTests
     * const { count } = await prisma.cameraTest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CameraTestDeleteManyArgs>(args?: SelectSubset<T, CameraTestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CameraTests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CameraTestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CameraTests
     * const cameraTest = await prisma.cameraTest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CameraTestUpdateManyArgs>(args: SelectSubset<T, CameraTestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CameraTests and returns the data updated in the database.
     * @param {CameraTestUpdateManyAndReturnArgs} args - Arguments to update many CameraTests.
     * @example
     * // Update many CameraTests
     * const cameraTest = await prisma.cameraTest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CameraTests and only return the `id`
     * const cameraTestWithIdOnly = await prisma.cameraTest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CameraTestUpdateManyAndReturnArgs>(args: SelectSubset<T, CameraTestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CameraTestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CameraTest.
     * @param {CameraTestUpsertArgs} args - Arguments to update or create a CameraTest.
     * @example
     * // Update or create a CameraTest
     * const cameraTest = await prisma.cameraTest.upsert({
     *   create: {
     *     // ... data to create a CameraTest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CameraTest we want to update
     *   }
     * })
     */
    upsert<T extends CameraTestUpsertArgs>(args: SelectSubset<T, CameraTestUpsertArgs<ExtArgs>>): Prisma__CameraTestClient<$Result.GetResult<Prisma.$CameraTestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CameraTests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CameraTestCountArgs} args - Arguments to filter CameraTests to count.
     * @example
     * // Count the number of CameraTests
     * const count = await prisma.cameraTest.count({
     *   where: {
     *     // ... the filter for the CameraTests we want to count
     *   }
     * })
    **/
    count<T extends CameraTestCountArgs>(
      args?: Subset<T, CameraTestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CameraTestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CameraTest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CameraTestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CameraTestAggregateArgs>(args: Subset<T, CameraTestAggregateArgs>): Prisma.PrismaPromise<GetCameraTestAggregateType<T>>

    /**
     * Group by CameraTest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CameraTestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CameraTestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CameraTestGroupByArgs['orderBy'] }
        : { orderBy?: CameraTestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CameraTestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCameraTestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CameraTest model
   */
  readonly fields: CameraTestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CameraTest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CameraTestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    deviceTest<T extends DeviceTestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DeviceTestDefaultArgs<ExtArgs>>): Prisma__DeviceTestClient<$Result.GetResult<Prisma.$DeviceTestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CameraTest model
   */
  interface CameraTestFieldRefs {
    readonly id: FieldRef<"CameraTest", 'String'>
    readonly frontCamera: FieldRef<"CameraTest", 'Boolean'>
    readonly backCamera: FieldRef<"CameraTest", 'Boolean'>
    readonly timestamp: FieldRef<"CameraTest", 'DateTime'>
    readonly deviceTestId: FieldRef<"CameraTest", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CameraTest findUnique
   */
  export type CameraTestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CameraTest
     */
    select?: CameraTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CameraTest
     */
    omit?: CameraTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CameraTestInclude<ExtArgs> | null
    /**
     * Filter, which CameraTest to fetch.
     */
    where: CameraTestWhereUniqueInput
  }

  /**
   * CameraTest findUniqueOrThrow
   */
  export type CameraTestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CameraTest
     */
    select?: CameraTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CameraTest
     */
    omit?: CameraTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CameraTestInclude<ExtArgs> | null
    /**
     * Filter, which CameraTest to fetch.
     */
    where: CameraTestWhereUniqueInput
  }

  /**
   * CameraTest findFirst
   */
  export type CameraTestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CameraTest
     */
    select?: CameraTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CameraTest
     */
    omit?: CameraTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CameraTestInclude<ExtArgs> | null
    /**
     * Filter, which CameraTest to fetch.
     */
    where?: CameraTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CameraTests to fetch.
     */
    orderBy?: CameraTestOrderByWithRelationInput | CameraTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CameraTests.
     */
    cursor?: CameraTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CameraTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CameraTests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CameraTests.
     */
    distinct?: CameraTestScalarFieldEnum | CameraTestScalarFieldEnum[]
  }

  /**
   * CameraTest findFirstOrThrow
   */
  export type CameraTestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CameraTest
     */
    select?: CameraTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CameraTest
     */
    omit?: CameraTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CameraTestInclude<ExtArgs> | null
    /**
     * Filter, which CameraTest to fetch.
     */
    where?: CameraTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CameraTests to fetch.
     */
    orderBy?: CameraTestOrderByWithRelationInput | CameraTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CameraTests.
     */
    cursor?: CameraTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CameraTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CameraTests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CameraTests.
     */
    distinct?: CameraTestScalarFieldEnum | CameraTestScalarFieldEnum[]
  }

  /**
   * CameraTest findMany
   */
  export type CameraTestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CameraTest
     */
    select?: CameraTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CameraTest
     */
    omit?: CameraTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CameraTestInclude<ExtArgs> | null
    /**
     * Filter, which CameraTests to fetch.
     */
    where?: CameraTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CameraTests to fetch.
     */
    orderBy?: CameraTestOrderByWithRelationInput | CameraTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CameraTests.
     */
    cursor?: CameraTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CameraTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CameraTests.
     */
    skip?: number
    distinct?: CameraTestScalarFieldEnum | CameraTestScalarFieldEnum[]
  }

  /**
   * CameraTest create
   */
  export type CameraTestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CameraTest
     */
    select?: CameraTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CameraTest
     */
    omit?: CameraTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CameraTestInclude<ExtArgs> | null
    /**
     * The data needed to create a CameraTest.
     */
    data: XOR<CameraTestCreateInput, CameraTestUncheckedCreateInput>
  }

  /**
   * CameraTest createMany
   */
  export type CameraTestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CameraTests.
     */
    data: CameraTestCreateManyInput | CameraTestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CameraTest createManyAndReturn
   */
  export type CameraTestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CameraTest
     */
    select?: CameraTestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CameraTest
     */
    omit?: CameraTestOmit<ExtArgs> | null
    /**
     * The data used to create many CameraTests.
     */
    data: CameraTestCreateManyInput | CameraTestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CameraTestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CameraTest update
   */
  export type CameraTestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CameraTest
     */
    select?: CameraTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CameraTest
     */
    omit?: CameraTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CameraTestInclude<ExtArgs> | null
    /**
     * The data needed to update a CameraTest.
     */
    data: XOR<CameraTestUpdateInput, CameraTestUncheckedUpdateInput>
    /**
     * Choose, which CameraTest to update.
     */
    where: CameraTestWhereUniqueInput
  }

  /**
   * CameraTest updateMany
   */
  export type CameraTestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CameraTests.
     */
    data: XOR<CameraTestUpdateManyMutationInput, CameraTestUncheckedUpdateManyInput>
    /**
     * Filter which CameraTests to update
     */
    where?: CameraTestWhereInput
    /**
     * Limit how many CameraTests to update.
     */
    limit?: number
  }

  /**
   * CameraTest updateManyAndReturn
   */
  export type CameraTestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CameraTest
     */
    select?: CameraTestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CameraTest
     */
    omit?: CameraTestOmit<ExtArgs> | null
    /**
     * The data used to update CameraTests.
     */
    data: XOR<CameraTestUpdateManyMutationInput, CameraTestUncheckedUpdateManyInput>
    /**
     * Filter which CameraTests to update
     */
    where?: CameraTestWhereInput
    /**
     * Limit how many CameraTests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CameraTestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CameraTest upsert
   */
  export type CameraTestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CameraTest
     */
    select?: CameraTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CameraTest
     */
    omit?: CameraTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CameraTestInclude<ExtArgs> | null
    /**
     * The filter to search for the CameraTest to update in case it exists.
     */
    where: CameraTestWhereUniqueInput
    /**
     * In case the CameraTest found by the `where` argument doesn't exist, create a new CameraTest with this data.
     */
    create: XOR<CameraTestCreateInput, CameraTestUncheckedCreateInput>
    /**
     * In case the CameraTest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CameraTestUpdateInput, CameraTestUncheckedUpdateInput>
  }

  /**
   * CameraTest delete
   */
  export type CameraTestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CameraTest
     */
    select?: CameraTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CameraTest
     */
    omit?: CameraTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CameraTestInclude<ExtArgs> | null
    /**
     * Filter which CameraTest to delete.
     */
    where: CameraTestWhereUniqueInput
  }

  /**
   * CameraTest deleteMany
   */
  export type CameraTestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CameraTests to delete
     */
    where?: CameraTestWhereInput
    /**
     * Limit how many CameraTests to delete.
     */
    limit?: number
  }

  /**
   * CameraTest without action
   */
  export type CameraTestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CameraTest
     */
    select?: CameraTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CameraTest
     */
    omit?: CameraTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CameraTestInclude<ExtArgs> | null
  }


  /**
   * Model FingerprintTest
   */

  export type AggregateFingerprintTest = {
    _count: FingerprintTestCountAggregateOutputType | null
    _min: FingerprintTestMinAggregateOutputType | null
    _max: FingerprintTestMaxAggregateOutputType | null
  }

  export type FingerprintTestMinAggregateOutputType = {
    id: string | null
    status: boolean | null
    message: string | null
    timestamp: Date | null
    deviceTestId: string | null
  }

  export type FingerprintTestMaxAggregateOutputType = {
    id: string | null
    status: boolean | null
    message: string | null
    timestamp: Date | null
    deviceTestId: string | null
  }

  export type FingerprintTestCountAggregateOutputType = {
    id: number
    status: number
    message: number
    timestamp: number
    deviceTestId: number
    _all: number
  }


  export type FingerprintTestMinAggregateInputType = {
    id?: true
    status?: true
    message?: true
    timestamp?: true
    deviceTestId?: true
  }

  export type FingerprintTestMaxAggregateInputType = {
    id?: true
    status?: true
    message?: true
    timestamp?: true
    deviceTestId?: true
  }

  export type FingerprintTestCountAggregateInputType = {
    id?: true
    status?: true
    message?: true
    timestamp?: true
    deviceTestId?: true
    _all?: true
  }

  export type FingerprintTestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FingerprintTest to aggregate.
     */
    where?: FingerprintTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FingerprintTests to fetch.
     */
    orderBy?: FingerprintTestOrderByWithRelationInput | FingerprintTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FingerprintTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FingerprintTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FingerprintTests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FingerprintTests
    **/
    _count?: true | FingerprintTestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FingerprintTestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FingerprintTestMaxAggregateInputType
  }

  export type GetFingerprintTestAggregateType<T extends FingerprintTestAggregateArgs> = {
        [P in keyof T & keyof AggregateFingerprintTest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFingerprintTest[P]>
      : GetScalarType<T[P], AggregateFingerprintTest[P]>
  }




  export type FingerprintTestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FingerprintTestWhereInput
    orderBy?: FingerprintTestOrderByWithAggregationInput | FingerprintTestOrderByWithAggregationInput[]
    by: FingerprintTestScalarFieldEnum[] | FingerprintTestScalarFieldEnum
    having?: FingerprintTestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FingerprintTestCountAggregateInputType | true
    _min?: FingerprintTestMinAggregateInputType
    _max?: FingerprintTestMaxAggregateInputType
  }

  export type FingerprintTestGroupByOutputType = {
    id: string
    status: boolean
    message: string | null
    timestamp: Date | null
    deviceTestId: string
    _count: FingerprintTestCountAggregateOutputType | null
    _min: FingerprintTestMinAggregateOutputType | null
    _max: FingerprintTestMaxAggregateOutputType | null
  }

  type GetFingerprintTestGroupByPayload<T extends FingerprintTestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FingerprintTestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FingerprintTestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FingerprintTestGroupByOutputType[P]>
            : GetScalarType<T[P], FingerprintTestGroupByOutputType[P]>
        }
      >
    >


  export type FingerprintTestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    message?: boolean
    timestamp?: boolean
    deviceTestId?: boolean
    deviceTest?: boolean | DeviceTestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fingerprintTest"]>

  export type FingerprintTestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    message?: boolean
    timestamp?: boolean
    deviceTestId?: boolean
    deviceTest?: boolean | DeviceTestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fingerprintTest"]>

  export type FingerprintTestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    message?: boolean
    timestamp?: boolean
    deviceTestId?: boolean
    deviceTest?: boolean | DeviceTestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fingerprintTest"]>

  export type FingerprintTestSelectScalar = {
    id?: boolean
    status?: boolean
    message?: boolean
    timestamp?: boolean
    deviceTestId?: boolean
  }

  export type FingerprintTestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "status" | "message" | "timestamp" | "deviceTestId", ExtArgs["result"]["fingerprintTest"]>
  export type FingerprintTestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deviceTest?: boolean | DeviceTestDefaultArgs<ExtArgs>
  }
  export type FingerprintTestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deviceTest?: boolean | DeviceTestDefaultArgs<ExtArgs>
  }
  export type FingerprintTestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deviceTest?: boolean | DeviceTestDefaultArgs<ExtArgs>
  }

  export type $FingerprintTestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FingerprintTest"
    objects: {
      deviceTest: Prisma.$DeviceTestPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      status: boolean
      message: string | null
      timestamp: Date | null
      deviceTestId: string
    }, ExtArgs["result"]["fingerprintTest"]>
    composites: {}
  }

  type FingerprintTestGetPayload<S extends boolean | null | undefined | FingerprintTestDefaultArgs> = $Result.GetResult<Prisma.$FingerprintTestPayload, S>

  type FingerprintTestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FingerprintTestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FingerprintTestCountAggregateInputType | true
    }

  export interface FingerprintTestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FingerprintTest'], meta: { name: 'FingerprintTest' } }
    /**
     * Find zero or one FingerprintTest that matches the filter.
     * @param {FingerprintTestFindUniqueArgs} args - Arguments to find a FingerprintTest
     * @example
     * // Get one FingerprintTest
     * const fingerprintTest = await prisma.fingerprintTest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FingerprintTestFindUniqueArgs>(args: SelectSubset<T, FingerprintTestFindUniqueArgs<ExtArgs>>): Prisma__FingerprintTestClient<$Result.GetResult<Prisma.$FingerprintTestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FingerprintTest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FingerprintTestFindUniqueOrThrowArgs} args - Arguments to find a FingerprintTest
     * @example
     * // Get one FingerprintTest
     * const fingerprintTest = await prisma.fingerprintTest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FingerprintTestFindUniqueOrThrowArgs>(args: SelectSubset<T, FingerprintTestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FingerprintTestClient<$Result.GetResult<Prisma.$FingerprintTestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FingerprintTest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FingerprintTestFindFirstArgs} args - Arguments to find a FingerprintTest
     * @example
     * // Get one FingerprintTest
     * const fingerprintTest = await prisma.fingerprintTest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FingerprintTestFindFirstArgs>(args?: SelectSubset<T, FingerprintTestFindFirstArgs<ExtArgs>>): Prisma__FingerprintTestClient<$Result.GetResult<Prisma.$FingerprintTestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FingerprintTest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FingerprintTestFindFirstOrThrowArgs} args - Arguments to find a FingerprintTest
     * @example
     * // Get one FingerprintTest
     * const fingerprintTest = await prisma.fingerprintTest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FingerprintTestFindFirstOrThrowArgs>(args?: SelectSubset<T, FingerprintTestFindFirstOrThrowArgs<ExtArgs>>): Prisma__FingerprintTestClient<$Result.GetResult<Prisma.$FingerprintTestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FingerprintTests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FingerprintTestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FingerprintTests
     * const fingerprintTests = await prisma.fingerprintTest.findMany()
     * 
     * // Get first 10 FingerprintTests
     * const fingerprintTests = await prisma.fingerprintTest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fingerprintTestWithIdOnly = await prisma.fingerprintTest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FingerprintTestFindManyArgs>(args?: SelectSubset<T, FingerprintTestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FingerprintTestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FingerprintTest.
     * @param {FingerprintTestCreateArgs} args - Arguments to create a FingerprintTest.
     * @example
     * // Create one FingerprintTest
     * const FingerprintTest = await prisma.fingerprintTest.create({
     *   data: {
     *     // ... data to create a FingerprintTest
     *   }
     * })
     * 
     */
    create<T extends FingerprintTestCreateArgs>(args: SelectSubset<T, FingerprintTestCreateArgs<ExtArgs>>): Prisma__FingerprintTestClient<$Result.GetResult<Prisma.$FingerprintTestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FingerprintTests.
     * @param {FingerprintTestCreateManyArgs} args - Arguments to create many FingerprintTests.
     * @example
     * // Create many FingerprintTests
     * const fingerprintTest = await prisma.fingerprintTest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FingerprintTestCreateManyArgs>(args?: SelectSubset<T, FingerprintTestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FingerprintTests and returns the data saved in the database.
     * @param {FingerprintTestCreateManyAndReturnArgs} args - Arguments to create many FingerprintTests.
     * @example
     * // Create many FingerprintTests
     * const fingerprintTest = await prisma.fingerprintTest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FingerprintTests and only return the `id`
     * const fingerprintTestWithIdOnly = await prisma.fingerprintTest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FingerprintTestCreateManyAndReturnArgs>(args?: SelectSubset<T, FingerprintTestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FingerprintTestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FingerprintTest.
     * @param {FingerprintTestDeleteArgs} args - Arguments to delete one FingerprintTest.
     * @example
     * // Delete one FingerprintTest
     * const FingerprintTest = await prisma.fingerprintTest.delete({
     *   where: {
     *     // ... filter to delete one FingerprintTest
     *   }
     * })
     * 
     */
    delete<T extends FingerprintTestDeleteArgs>(args: SelectSubset<T, FingerprintTestDeleteArgs<ExtArgs>>): Prisma__FingerprintTestClient<$Result.GetResult<Prisma.$FingerprintTestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FingerprintTest.
     * @param {FingerprintTestUpdateArgs} args - Arguments to update one FingerprintTest.
     * @example
     * // Update one FingerprintTest
     * const fingerprintTest = await prisma.fingerprintTest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FingerprintTestUpdateArgs>(args: SelectSubset<T, FingerprintTestUpdateArgs<ExtArgs>>): Prisma__FingerprintTestClient<$Result.GetResult<Prisma.$FingerprintTestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FingerprintTests.
     * @param {FingerprintTestDeleteManyArgs} args - Arguments to filter FingerprintTests to delete.
     * @example
     * // Delete a few FingerprintTests
     * const { count } = await prisma.fingerprintTest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FingerprintTestDeleteManyArgs>(args?: SelectSubset<T, FingerprintTestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FingerprintTests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FingerprintTestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FingerprintTests
     * const fingerprintTest = await prisma.fingerprintTest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FingerprintTestUpdateManyArgs>(args: SelectSubset<T, FingerprintTestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FingerprintTests and returns the data updated in the database.
     * @param {FingerprintTestUpdateManyAndReturnArgs} args - Arguments to update many FingerprintTests.
     * @example
     * // Update many FingerprintTests
     * const fingerprintTest = await prisma.fingerprintTest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FingerprintTests and only return the `id`
     * const fingerprintTestWithIdOnly = await prisma.fingerprintTest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FingerprintTestUpdateManyAndReturnArgs>(args: SelectSubset<T, FingerprintTestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FingerprintTestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FingerprintTest.
     * @param {FingerprintTestUpsertArgs} args - Arguments to update or create a FingerprintTest.
     * @example
     * // Update or create a FingerprintTest
     * const fingerprintTest = await prisma.fingerprintTest.upsert({
     *   create: {
     *     // ... data to create a FingerprintTest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FingerprintTest we want to update
     *   }
     * })
     */
    upsert<T extends FingerprintTestUpsertArgs>(args: SelectSubset<T, FingerprintTestUpsertArgs<ExtArgs>>): Prisma__FingerprintTestClient<$Result.GetResult<Prisma.$FingerprintTestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FingerprintTests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FingerprintTestCountArgs} args - Arguments to filter FingerprintTests to count.
     * @example
     * // Count the number of FingerprintTests
     * const count = await prisma.fingerprintTest.count({
     *   where: {
     *     // ... the filter for the FingerprintTests we want to count
     *   }
     * })
    **/
    count<T extends FingerprintTestCountArgs>(
      args?: Subset<T, FingerprintTestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FingerprintTestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FingerprintTest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FingerprintTestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FingerprintTestAggregateArgs>(args: Subset<T, FingerprintTestAggregateArgs>): Prisma.PrismaPromise<GetFingerprintTestAggregateType<T>>

    /**
     * Group by FingerprintTest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FingerprintTestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FingerprintTestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FingerprintTestGroupByArgs['orderBy'] }
        : { orderBy?: FingerprintTestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FingerprintTestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFingerprintTestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FingerprintTest model
   */
  readonly fields: FingerprintTestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FingerprintTest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FingerprintTestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    deviceTest<T extends DeviceTestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DeviceTestDefaultArgs<ExtArgs>>): Prisma__DeviceTestClient<$Result.GetResult<Prisma.$DeviceTestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FingerprintTest model
   */
  interface FingerprintTestFieldRefs {
    readonly id: FieldRef<"FingerprintTest", 'String'>
    readonly status: FieldRef<"FingerprintTest", 'Boolean'>
    readonly message: FieldRef<"FingerprintTest", 'String'>
    readonly timestamp: FieldRef<"FingerprintTest", 'DateTime'>
    readonly deviceTestId: FieldRef<"FingerprintTest", 'String'>
  }
    

  // Custom InputTypes
  /**
   * FingerprintTest findUnique
   */
  export type FingerprintTestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FingerprintTest
     */
    select?: FingerprintTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FingerprintTest
     */
    omit?: FingerprintTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FingerprintTestInclude<ExtArgs> | null
    /**
     * Filter, which FingerprintTest to fetch.
     */
    where: FingerprintTestWhereUniqueInput
  }

  /**
   * FingerprintTest findUniqueOrThrow
   */
  export type FingerprintTestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FingerprintTest
     */
    select?: FingerprintTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FingerprintTest
     */
    omit?: FingerprintTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FingerprintTestInclude<ExtArgs> | null
    /**
     * Filter, which FingerprintTest to fetch.
     */
    where: FingerprintTestWhereUniqueInput
  }

  /**
   * FingerprintTest findFirst
   */
  export type FingerprintTestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FingerprintTest
     */
    select?: FingerprintTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FingerprintTest
     */
    omit?: FingerprintTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FingerprintTestInclude<ExtArgs> | null
    /**
     * Filter, which FingerprintTest to fetch.
     */
    where?: FingerprintTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FingerprintTests to fetch.
     */
    orderBy?: FingerprintTestOrderByWithRelationInput | FingerprintTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FingerprintTests.
     */
    cursor?: FingerprintTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FingerprintTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FingerprintTests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FingerprintTests.
     */
    distinct?: FingerprintTestScalarFieldEnum | FingerprintTestScalarFieldEnum[]
  }

  /**
   * FingerprintTest findFirstOrThrow
   */
  export type FingerprintTestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FingerprintTest
     */
    select?: FingerprintTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FingerprintTest
     */
    omit?: FingerprintTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FingerprintTestInclude<ExtArgs> | null
    /**
     * Filter, which FingerprintTest to fetch.
     */
    where?: FingerprintTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FingerprintTests to fetch.
     */
    orderBy?: FingerprintTestOrderByWithRelationInput | FingerprintTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FingerprintTests.
     */
    cursor?: FingerprintTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FingerprintTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FingerprintTests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FingerprintTests.
     */
    distinct?: FingerprintTestScalarFieldEnum | FingerprintTestScalarFieldEnum[]
  }

  /**
   * FingerprintTest findMany
   */
  export type FingerprintTestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FingerprintTest
     */
    select?: FingerprintTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FingerprintTest
     */
    omit?: FingerprintTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FingerprintTestInclude<ExtArgs> | null
    /**
     * Filter, which FingerprintTests to fetch.
     */
    where?: FingerprintTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FingerprintTests to fetch.
     */
    orderBy?: FingerprintTestOrderByWithRelationInput | FingerprintTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FingerprintTests.
     */
    cursor?: FingerprintTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FingerprintTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FingerprintTests.
     */
    skip?: number
    distinct?: FingerprintTestScalarFieldEnum | FingerprintTestScalarFieldEnum[]
  }

  /**
   * FingerprintTest create
   */
  export type FingerprintTestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FingerprintTest
     */
    select?: FingerprintTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FingerprintTest
     */
    omit?: FingerprintTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FingerprintTestInclude<ExtArgs> | null
    /**
     * The data needed to create a FingerprintTest.
     */
    data: XOR<FingerprintTestCreateInput, FingerprintTestUncheckedCreateInput>
  }

  /**
   * FingerprintTest createMany
   */
  export type FingerprintTestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FingerprintTests.
     */
    data: FingerprintTestCreateManyInput | FingerprintTestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FingerprintTest createManyAndReturn
   */
  export type FingerprintTestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FingerprintTest
     */
    select?: FingerprintTestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FingerprintTest
     */
    omit?: FingerprintTestOmit<ExtArgs> | null
    /**
     * The data used to create many FingerprintTests.
     */
    data: FingerprintTestCreateManyInput | FingerprintTestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FingerprintTestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FingerprintTest update
   */
  export type FingerprintTestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FingerprintTest
     */
    select?: FingerprintTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FingerprintTest
     */
    omit?: FingerprintTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FingerprintTestInclude<ExtArgs> | null
    /**
     * The data needed to update a FingerprintTest.
     */
    data: XOR<FingerprintTestUpdateInput, FingerprintTestUncheckedUpdateInput>
    /**
     * Choose, which FingerprintTest to update.
     */
    where: FingerprintTestWhereUniqueInput
  }

  /**
   * FingerprintTest updateMany
   */
  export type FingerprintTestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FingerprintTests.
     */
    data: XOR<FingerprintTestUpdateManyMutationInput, FingerprintTestUncheckedUpdateManyInput>
    /**
     * Filter which FingerprintTests to update
     */
    where?: FingerprintTestWhereInput
    /**
     * Limit how many FingerprintTests to update.
     */
    limit?: number
  }

  /**
   * FingerprintTest updateManyAndReturn
   */
  export type FingerprintTestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FingerprintTest
     */
    select?: FingerprintTestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FingerprintTest
     */
    omit?: FingerprintTestOmit<ExtArgs> | null
    /**
     * The data used to update FingerprintTests.
     */
    data: XOR<FingerprintTestUpdateManyMutationInput, FingerprintTestUncheckedUpdateManyInput>
    /**
     * Filter which FingerprintTests to update
     */
    where?: FingerprintTestWhereInput
    /**
     * Limit how many FingerprintTests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FingerprintTestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FingerprintTest upsert
   */
  export type FingerprintTestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FingerprintTest
     */
    select?: FingerprintTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FingerprintTest
     */
    omit?: FingerprintTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FingerprintTestInclude<ExtArgs> | null
    /**
     * The filter to search for the FingerprintTest to update in case it exists.
     */
    where: FingerprintTestWhereUniqueInput
    /**
     * In case the FingerprintTest found by the `where` argument doesn't exist, create a new FingerprintTest with this data.
     */
    create: XOR<FingerprintTestCreateInput, FingerprintTestUncheckedCreateInput>
    /**
     * In case the FingerprintTest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FingerprintTestUpdateInput, FingerprintTestUncheckedUpdateInput>
  }

  /**
   * FingerprintTest delete
   */
  export type FingerprintTestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FingerprintTest
     */
    select?: FingerprintTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FingerprintTest
     */
    omit?: FingerprintTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FingerprintTestInclude<ExtArgs> | null
    /**
     * Filter which FingerprintTest to delete.
     */
    where: FingerprintTestWhereUniqueInput
  }

  /**
   * FingerprintTest deleteMany
   */
  export type FingerprintTestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FingerprintTests to delete
     */
    where?: FingerprintTestWhereInput
    /**
     * Limit how many FingerprintTests to delete.
     */
    limit?: number
  }

  /**
   * FingerprintTest without action
   */
  export type FingerprintTestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FingerprintTest
     */
    select?: FingerprintTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FingerprintTest
     */
    omit?: FingerprintTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FingerprintTestInclude<ExtArgs> | null
  }


  /**
   * Model UsbTest
   */

  export type AggregateUsbTest = {
    _count: UsbTestCountAggregateOutputType | null
    _min: UsbTestMinAggregateOutputType | null
    _max: UsbTestMaxAggregateOutputType | null
  }

  export type UsbTestMinAggregateOutputType = {
    id: string | null
    status: boolean | null
    message: string | null
    timestamp: Date | null
    deviceTestId: string | null
  }

  export type UsbTestMaxAggregateOutputType = {
    id: string | null
    status: boolean | null
    message: string | null
    timestamp: Date | null
    deviceTestId: string | null
  }

  export type UsbTestCountAggregateOutputType = {
    id: number
    status: number
    message: number
    timestamp: number
    deviceTestId: number
    _all: number
  }


  export type UsbTestMinAggregateInputType = {
    id?: true
    status?: true
    message?: true
    timestamp?: true
    deviceTestId?: true
  }

  export type UsbTestMaxAggregateInputType = {
    id?: true
    status?: true
    message?: true
    timestamp?: true
    deviceTestId?: true
  }

  export type UsbTestCountAggregateInputType = {
    id?: true
    status?: true
    message?: true
    timestamp?: true
    deviceTestId?: true
    _all?: true
  }

  export type UsbTestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UsbTest to aggregate.
     */
    where?: UsbTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsbTests to fetch.
     */
    orderBy?: UsbTestOrderByWithRelationInput | UsbTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsbTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsbTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsbTests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UsbTests
    **/
    _count?: true | UsbTestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsbTestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsbTestMaxAggregateInputType
  }

  export type GetUsbTestAggregateType<T extends UsbTestAggregateArgs> = {
        [P in keyof T & keyof AggregateUsbTest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsbTest[P]>
      : GetScalarType<T[P], AggregateUsbTest[P]>
  }




  export type UsbTestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsbTestWhereInput
    orderBy?: UsbTestOrderByWithAggregationInput | UsbTestOrderByWithAggregationInput[]
    by: UsbTestScalarFieldEnum[] | UsbTestScalarFieldEnum
    having?: UsbTestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsbTestCountAggregateInputType | true
    _min?: UsbTestMinAggregateInputType
    _max?: UsbTestMaxAggregateInputType
  }

  export type UsbTestGroupByOutputType = {
    id: string
    status: boolean
    message: string | null
    timestamp: Date | null
    deviceTestId: string
    _count: UsbTestCountAggregateOutputType | null
    _min: UsbTestMinAggregateOutputType | null
    _max: UsbTestMaxAggregateOutputType | null
  }

  type GetUsbTestGroupByPayload<T extends UsbTestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsbTestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsbTestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsbTestGroupByOutputType[P]>
            : GetScalarType<T[P], UsbTestGroupByOutputType[P]>
        }
      >
    >


  export type UsbTestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    message?: boolean
    timestamp?: boolean
    deviceTestId?: boolean
    deviceTest?: boolean | DeviceTestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usbTest"]>

  export type UsbTestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    message?: boolean
    timestamp?: boolean
    deviceTestId?: boolean
    deviceTest?: boolean | DeviceTestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usbTest"]>

  export type UsbTestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    message?: boolean
    timestamp?: boolean
    deviceTestId?: boolean
    deviceTest?: boolean | DeviceTestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usbTest"]>

  export type UsbTestSelectScalar = {
    id?: boolean
    status?: boolean
    message?: boolean
    timestamp?: boolean
    deviceTestId?: boolean
  }

  export type UsbTestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "status" | "message" | "timestamp" | "deviceTestId", ExtArgs["result"]["usbTest"]>
  export type UsbTestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deviceTest?: boolean | DeviceTestDefaultArgs<ExtArgs>
  }
  export type UsbTestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deviceTest?: boolean | DeviceTestDefaultArgs<ExtArgs>
  }
  export type UsbTestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deviceTest?: boolean | DeviceTestDefaultArgs<ExtArgs>
  }

  export type $UsbTestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UsbTest"
    objects: {
      deviceTest: Prisma.$DeviceTestPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      status: boolean
      message: string | null
      timestamp: Date | null
      deviceTestId: string
    }, ExtArgs["result"]["usbTest"]>
    composites: {}
  }

  type UsbTestGetPayload<S extends boolean | null | undefined | UsbTestDefaultArgs> = $Result.GetResult<Prisma.$UsbTestPayload, S>

  type UsbTestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UsbTestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsbTestCountAggregateInputType | true
    }

  export interface UsbTestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UsbTest'], meta: { name: 'UsbTest' } }
    /**
     * Find zero or one UsbTest that matches the filter.
     * @param {UsbTestFindUniqueArgs} args - Arguments to find a UsbTest
     * @example
     * // Get one UsbTest
     * const usbTest = await prisma.usbTest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsbTestFindUniqueArgs>(args: SelectSubset<T, UsbTestFindUniqueArgs<ExtArgs>>): Prisma__UsbTestClient<$Result.GetResult<Prisma.$UsbTestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UsbTest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UsbTestFindUniqueOrThrowArgs} args - Arguments to find a UsbTest
     * @example
     * // Get one UsbTest
     * const usbTest = await prisma.usbTest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsbTestFindUniqueOrThrowArgs>(args: SelectSubset<T, UsbTestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsbTestClient<$Result.GetResult<Prisma.$UsbTestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UsbTest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsbTestFindFirstArgs} args - Arguments to find a UsbTest
     * @example
     * // Get one UsbTest
     * const usbTest = await prisma.usbTest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsbTestFindFirstArgs>(args?: SelectSubset<T, UsbTestFindFirstArgs<ExtArgs>>): Prisma__UsbTestClient<$Result.GetResult<Prisma.$UsbTestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UsbTest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsbTestFindFirstOrThrowArgs} args - Arguments to find a UsbTest
     * @example
     * // Get one UsbTest
     * const usbTest = await prisma.usbTest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsbTestFindFirstOrThrowArgs>(args?: SelectSubset<T, UsbTestFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsbTestClient<$Result.GetResult<Prisma.$UsbTestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UsbTests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsbTestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UsbTests
     * const usbTests = await prisma.usbTest.findMany()
     * 
     * // Get first 10 UsbTests
     * const usbTests = await prisma.usbTest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usbTestWithIdOnly = await prisma.usbTest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UsbTestFindManyArgs>(args?: SelectSubset<T, UsbTestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsbTestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UsbTest.
     * @param {UsbTestCreateArgs} args - Arguments to create a UsbTest.
     * @example
     * // Create one UsbTest
     * const UsbTest = await prisma.usbTest.create({
     *   data: {
     *     // ... data to create a UsbTest
     *   }
     * })
     * 
     */
    create<T extends UsbTestCreateArgs>(args: SelectSubset<T, UsbTestCreateArgs<ExtArgs>>): Prisma__UsbTestClient<$Result.GetResult<Prisma.$UsbTestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UsbTests.
     * @param {UsbTestCreateManyArgs} args - Arguments to create many UsbTests.
     * @example
     * // Create many UsbTests
     * const usbTest = await prisma.usbTest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsbTestCreateManyArgs>(args?: SelectSubset<T, UsbTestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UsbTests and returns the data saved in the database.
     * @param {UsbTestCreateManyAndReturnArgs} args - Arguments to create many UsbTests.
     * @example
     * // Create many UsbTests
     * const usbTest = await prisma.usbTest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UsbTests and only return the `id`
     * const usbTestWithIdOnly = await prisma.usbTest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UsbTestCreateManyAndReturnArgs>(args?: SelectSubset<T, UsbTestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsbTestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UsbTest.
     * @param {UsbTestDeleteArgs} args - Arguments to delete one UsbTest.
     * @example
     * // Delete one UsbTest
     * const UsbTest = await prisma.usbTest.delete({
     *   where: {
     *     // ... filter to delete one UsbTest
     *   }
     * })
     * 
     */
    delete<T extends UsbTestDeleteArgs>(args: SelectSubset<T, UsbTestDeleteArgs<ExtArgs>>): Prisma__UsbTestClient<$Result.GetResult<Prisma.$UsbTestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UsbTest.
     * @param {UsbTestUpdateArgs} args - Arguments to update one UsbTest.
     * @example
     * // Update one UsbTest
     * const usbTest = await prisma.usbTest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsbTestUpdateArgs>(args: SelectSubset<T, UsbTestUpdateArgs<ExtArgs>>): Prisma__UsbTestClient<$Result.GetResult<Prisma.$UsbTestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UsbTests.
     * @param {UsbTestDeleteManyArgs} args - Arguments to filter UsbTests to delete.
     * @example
     * // Delete a few UsbTests
     * const { count } = await prisma.usbTest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsbTestDeleteManyArgs>(args?: SelectSubset<T, UsbTestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UsbTests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsbTestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UsbTests
     * const usbTest = await prisma.usbTest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsbTestUpdateManyArgs>(args: SelectSubset<T, UsbTestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UsbTests and returns the data updated in the database.
     * @param {UsbTestUpdateManyAndReturnArgs} args - Arguments to update many UsbTests.
     * @example
     * // Update many UsbTests
     * const usbTest = await prisma.usbTest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UsbTests and only return the `id`
     * const usbTestWithIdOnly = await prisma.usbTest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UsbTestUpdateManyAndReturnArgs>(args: SelectSubset<T, UsbTestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsbTestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UsbTest.
     * @param {UsbTestUpsertArgs} args - Arguments to update or create a UsbTest.
     * @example
     * // Update or create a UsbTest
     * const usbTest = await prisma.usbTest.upsert({
     *   create: {
     *     // ... data to create a UsbTest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UsbTest we want to update
     *   }
     * })
     */
    upsert<T extends UsbTestUpsertArgs>(args: SelectSubset<T, UsbTestUpsertArgs<ExtArgs>>): Prisma__UsbTestClient<$Result.GetResult<Prisma.$UsbTestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UsbTests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsbTestCountArgs} args - Arguments to filter UsbTests to count.
     * @example
     * // Count the number of UsbTests
     * const count = await prisma.usbTest.count({
     *   where: {
     *     // ... the filter for the UsbTests we want to count
     *   }
     * })
    **/
    count<T extends UsbTestCountArgs>(
      args?: Subset<T, UsbTestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsbTestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UsbTest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsbTestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsbTestAggregateArgs>(args: Subset<T, UsbTestAggregateArgs>): Prisma.PrismaPromise<GetUsbTestAggregateType<T>>

    /**
     * Group by UsbTest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsbTestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsbTestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsbTestGroupByArgs['orderBy'] }
        : { orderBy?: UsbTestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsbTestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsbTestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UsbTest model
   */
  readonly fields: UsbTestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UsbTest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsbTestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    deviceTest<T extends DeviceTestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DeviceTestDefaultArgs<ExtArgs>>): Prisma__DeviceTestClient<$Result.GetResult<Prisma.$DeviceTestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UsbTest model
   */
  interface UsbTestFieldRefs {
    readonly id: FieldRef<"UsbTest", 'String'>
    readonly status: FieldRef<"UsbTest", 'Boolean'>
    readonly message: FieldRef<"UsbTest", 'String'>
    readonly timestamp: FieldRef<"UsbTest", 'DateTime'>
    readonly deviceTestId: FieldRef<"UsbTest", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UsbTest findUnique
   */
  export type UsbTestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsbTest
     */
    select?: UsbTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsbTest
     */
    omit?: UsbTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsbTestInclude<ExtArgs> | null
    /**
     * Filter, which UsbTest to fetch.
     */
    where: UsbTestWhereUniqueInput
  }

  /**
   * UsbTest findUniqueOrThrow
   */
  export type UsbTestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsbTest
     */
    select?: UsbTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsbTest
     */
    omit?: UsbTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsbTestInclude<ExtArgs> | null
    /**
     * Filter, which UsbTest to fetch.
     */
    where: UsbTestWhereUniqueInput
  }

  /**
   * UsbTest findFirst
   */
  export type UsbTestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsbTest
     */
    select?: UsbTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsbTest
     */
    omit?: UsbTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsbTestInclude<ExtArgs> | null
    /**
     * Filter, which UsbTest to fetch.
     */
    where?: UsbTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsbTests to fetch.
     */
    orderBy?: UsbTestOrderByWithRelationInput | UsbTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UsbTests.
     */
    cursor?: UsbTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsbTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsbTests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UsbTests.
     */
    distinct?: UsbTestScalarFieldEnum | UsbTestScalarFieldEnum[]
  }

  /**
   * UsbTest findFirstOrThrow
   */
  export type UsbTestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsbTest
     */
    select?: UsbTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsbTest
     */
    omit?: UsbTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsbTestInclude<ExtArgs> | null
    /**
     * Filter, which UsbTest to fetch.
     */
    where?: UsbTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsbTests to fetch.
     */
    orderBy?: UsbTestOrderByWithRelationInput | UsbTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UsbTests.
     */
    cursor?: UsbTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsbTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsbTests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UsbTests.
     */
    distinct?: UsbTestScalarFieldEnum | UsbTestScalarFieldEnum[]
  }

  /**
   * UsbTest findMany
   */
  export type UsbTestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsbTest
     */
    select?: UsbTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsbTest
     */
    omit?: UsbTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsbTestInclude<ExtArgs> | null
    /**
     * Filter, which UsbTests to fetch.
     */
    where?: UsbTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsbTests to fetch.
     */
    orderBy?: UsbTestOrderByWithRelationInput | UsbTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UsbTests.
     */
    cursor?: UsbTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsbTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsbTests.
     */
    skip?: number
    distinct?: UsbTestScalarFieldEnum | UsbTestScalarFieldEnum[]
  }

  /**
   * UsbTest create
   */
  export type UsbTestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsbTest
     */
    select?: UsbTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsbTest
     */
    omit?: UsbTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsbTestInclude<ExtArgs> | null
    /**
     * The data needed to create a UsbTest.
     */
    data: XOR<UsbTestCreateInput, UsbTestUncheckedCreateInput>
  }

  /**
   * UsbTest createMany
   */
  export type UsbTestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UsbTests.
     */
    data: UsbTestCreateManyInput | UsbTestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UsbTest createManyAndReturn
   */
  export type UsbTestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsbTest
     */
    select?: UsbTestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UsbTest
     */
    omit?: UsbTestOmit<ExtArgs> | null
    /**
     * The data used to create many UsbTests.
     */
    data: UsbTestCreateManyInput | UsbTestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsbTestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UsbTest update
   */
  export type UsbTestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsbTest
     */
    select?: UsbTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsbTest
     */
    omit?: UsbTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsbTestInclude<ExtArgs> | null
    /**
     * The data needed to update a UsbTest.
     */
    data: XOR<UsbTestUpdateInput, UsbTestUncheckedUpdateInput>
    /**
     * Choose, which UsbTest to update.
     */
    where: UsbTestWhereUniqueInput
  }

  /**
   * UsbTest updateMany
   */
  export type UsbTestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UsbTests.
     */
    data: XOR<UsbTestUpdateManyMutationInput, UsbTestUncheckedUpdateManyInput>
    /**
     * Filter which UsbTests to update
     */
    where?: UsbTestWhereInput
    /**
     * Limit how many UsbTests to update.
     */
    limit?: number
  }

  /**
   * UsbTest updateManyAndReturn
   */
  export type UsbTestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsbTest
     */
    select?: UsbTestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UsbTest
     */
    omit?: UsbTestOmit<ExtArgs> | null
    /**
     * The data used to update UsbTests.
     */
    data: XOR<UsbTestUpdateManyMutationInput, UsbTestUncheckedUpdateManyInput>
    /**
     * Filter which UsbTests to update
     */
    where?: UsbTestWhereInput
    /**
     * Limit how many UsbTests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsbTestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UsbTest upsert
   */
  export type UsbTestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsbTest
     */
    select?: UsbTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsbTest
     */
    omit?: UsbTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsbTestInclude<ExtArgs> | null
    /**
     * The filter to search for the UsbTest to update in case it exists.
     */
    where: UsbTestWhereUniqueInput
    /**
     * In case the UsbTest found by the `where` argument doesn't exist, create a new UsbTest with this data.
     */
    create: XOR<UsbTestCreateInput, UsbTestUncheckedCreateInput>
    /**
     * In case the UsbTest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsbTestUpdateInput, UsbTestUncheckedUpdateInput>
  }

  /**
   * UsbTest delete
   */
  export type UsbTestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsbTest
     */
    select?: UsbTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsbTest
     */
    omit?: UsbTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsbTestInclude<ExtArgs> | null
    /**
     * Filter which UsbTest to delete.
     */
    where: UsbTestWhereUniqueInput
  }

  /**
   * UsbTest deleteMany
   */
  export type UsbTestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UsbTests to delete
     */
    where?: UsbTestWhereInput
    /**
     * Limit how many UsbTests to delete.
     */
    limit?: number
  }

  /**
   * UsbTest without action
   */
  export type UsbTestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsbTest
     */
    select?: UsbTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsbTest
     */
    omit?: UsbTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsbTestInclude<ExtArgs> | null
  }


  /**
   * Model AudioJackTest
   */

  export type AggregateAudioJackTest = {
    _count: AudioJackTestCountAggregateOutputType | null
    _min: AudioJackTestMinAggregateOutputType | null
    _max: AudioJackTestMaxAggregateOutputType | null
  }

  export type AudioJackTestMinAggregateOutputType = {
    id: string | null
    status: boolean | null
    message: string | null
    timestamp: Date | null
    deviceTestId: string | null
  }

  export type AudioJackTestMaxAggregateOutputType = {
    id: string | null
    status: boolean | null
    message: string | null
    timestamp: Date | null
    deviceTestId: string | null
  }

  export type AudioJackTestCountAggregateOutputType = {
    id: number
    status: number
    message: number
    timestamp: number
    deviceTestId: number
    _all: number
  }


  export type AudioJackTestMinAggregateInputType = {
    id?: true
    status?: true
    message?: true
    timestamp?: true
    deviceTestId?: true
  }

  export type AudioJackTestMaxAggregateInputType = {
    id?: true
    status?: true
    message?: true
    timestamp?: true
    deviceTestId?: true
  }

  export type AudioJackTestCountAggregateInputType = {
    id?: true
    status?: true
    message?: true
    timestamp?: true
    deviceTestId?: true
    _all?: true
  }

  export type AudioJackTestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AudioJackTest to aggregate.
     */
    where?: AudioJackTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AudioJackTests to fetch.
     */
    orderBy?: AudioJackTestOrderByWithRelationInput | AudioJackTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AudioJackTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AudioJackTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AudioJackTests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AudioJackTests
    **/
    _count?: true | AudioJackTestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AudioJackTestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AudioJackTestMaxAggregateInputType
  }

  export type GetAudioJackTestAggregateType<T extends AudioJackTestAggregateArgs> = {
        [P in keyof T & keyof AggregateAudioJackTest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAudioJackTest[P]>
      : GetScalarType<T[P], AggregateAudioJackTest[P]>
  }




  export type AudioJackTestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AudioJackTestWhereInput
    orderBy?: AudioJackTestOrderByWithAggregationInput | AudioJackTestOrderByWithAggregationInput[]
    by: AudioJackTestScalarFieldEnum[] | AudioJackTestScalarFieldEnum
    having?: AudioJackTestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AudioJackTestCountAggregateInputType | true
    _min?: AudioJackTestMinAggregateInputType
    _max?: AudioJackTestMaxAggregateInputType
  }

  export type AudioJackTestGroupByOutputType = {
    id: string
    status: boolean
    message: string | null
    timestamp: Date | null
    deviceTestId: string
    _count: AudioJackTestCountAggregateOutputType | null
    _min: AudioJackTestMinAggregateOutputType | null
    _max: AudioJackTestMaxAggregateOutputType | null
  }

  type GetAudioJackTestGroupByPayload<T extends AudioJackTestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AudioJackTestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AudioJackTestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AudioJackTestGroupByOutputType[P]>
            : GetScalarType<T[P], AudioJackTestGroupByOutputType[P]>
        }
      >
    >


  export type AudioJackTestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    message?: boolean
    timestamp?: boolean
    deviceTestId?: boolean
    deviceTest?: boolean | DeviceTestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["audioJackTest"]>

  export type AudioJackTestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    message?: boolean
    timestamp?: boolean
    deviceTestId?: boolean
    deviceTest?: boolean | DeviceTestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["audioJackTest"]>

  export type AudioJackTestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    message?: boolean
    timestamp?: boolean
    deviceTestId?: boolean
    deviceTest?: boolean | DeviceTestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["audioJackTest"]>

  export type AudioJackTestSelectScalar = {
    id?: boolean
    status?: boolean
    message?: boolean
    timestamp?: boolean
    deviceTestId?: boolean
  }

  export type AudioJackTestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "status" | "message" | "timestamp" | "deviceTestId", ExtArgs["result"]["audioJackTest"]>
  export type AudioJackTestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deviceTest?: boolean | DeviceTestDefaultArgs<ExtArgs>
  }
  export type AudioJackTestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deviceTest?: boolean | DeviceTestDefaultArgs<ExtArgs>
  }
  export type AudioJackTestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deviceTest?: boolean | DeviceTestDefaultArgs<ExtArgs>
  }

  export type $AudioJackTestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AudioJackTest"
    objects: {
      deviceTest: Prisma.$DeviceTestPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      status: boolean
      message: string | null
      timestamp: Date | null
      deviceTestId: string
    }, ExtArgs["result"]["audioJackTest"]>
    composites: {}
  }

  type AudioJackTestGetPayload<S extends boolean | null | undefined | AudioJackTestDefaultArgs> = $Result.GetResult<Prisma.$AudioJackTestPayload, S>

  type AudioJackTestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AudioJackTestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AudioJackTestCountAggregateInputType | true
    }

  export interface AudioJackTestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AudioJackTest'], meta: { name: 'AudioJackTest' } }
    /**
     * Find zero or one AudioJackTest that matches the filter.
     * @param {AudioJackTestFindUniqueArgs} args - Arguments to find a AudioJackTest
     * @example
     * // Get one AudioJackTest
     * const audioJackTest = await prisma.audioJackTest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AudioJackTestFindUniqueArgs>(args: SelectSubset<T, AudioJackTestFindUniqueArgs<ExtArgs>>): Prisma__AudioJackTestClient<$Result.GetResult<Prisma.$AudioJackTestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AudioJackTest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AudioJackTestFindUniqueOrThrowArgs} args - Arguments to find a AudioJackTest
     * @example
     * // Get one AudioJackTest
     * const audioJackTest = await prisma.audioJackTest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AudioJackTestFindUniqueOrThrowArgs>(args: SelectSubset<T, AudioJackTestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AudioJackTestClient<$Result.GetResult<Prisma.$AudioJackTestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AudioJackTest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioJackTestFindFirstArgs} args - Arguments to find a AudioJackTest
     * @example
     * // Get one AudioJackTest
     * const audioJackTest = await prisma.audioJackTest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AudioJackTestFindFirstArgs>(args?: SelectSubset<T, AudioJackTestFindFirstArgs<ExtArgs>>): Prisma__AudioJackTestClient<$Result.GetResult<Prisma.$AudioJackTestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AudioJackTest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioJackTestFindFirstOrThrowArgs} args - Arguments to find a AudioJackTest
     * @example
     * // Get one AudioJackTest
     * const audioJackTest = await prisma.audioJackTest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AudioJackTestFindFirstOrThrowArgs>(args?: SelectSubset<T, AudioJackTestFindFirstOrThrowArgs<ExtArgs>>): Prisma__AudioJackTestClient<$Result.GetResult<Prisma.$AudioJackTestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AudioJackTests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioJackTestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AudioJackTests
     * const audioJackTests = await prisma.audioJackTest.findMany()
     * 
     * // Get first 10 AudioJackTests
     * const audioJackTests = await prisma.audioJackTest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const audioJackTestWithIdOnly = await prisma.audioJackTest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AudioJackTestFindManyArgs>(args?: SelectSubset<T, AudioJackTestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AudioJackTestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AudioJackTest.
     * @param {AudioJackTestCreateArgs} args - Arguments to create a AudioJackTest.
     * @example
     * // Create one AudioJackTest
     * const AudioJackTest = await prisma.audioJackTest.create({
     *   data: {
     *     // ... data to create a AudioJackTest
     *   }
     * })
     * 
     */
    create<T extends AudioJackTestCreateArgs>(args: SelectSubset<T, AudioJackTestCreateArgs<ExtArgs>>): Prisma__AudioJackTestClient<$Result.GetResult<Prisma.$AudioJackTestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AudioJackTests.
     * @param {AudioJackTestCreateManyArgs} args - Arguments to create many AudioJackTests.
     * @example
     * // Create many AudioJackTests
     * const audioJackTest = await prisma.audioJackTest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AudioJackTestCreateManyArgs>(args?: SelectSubset<T, AudioJackTestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AudioJackTests and returns the data saved in the database.
     * @param {AudioJackTestCreateManyAndReturnArgs} args - Arguments to create many AudioJackTests.
     * @example
     * // Create many AudioJackTests
     * const audioJackTest = await prisma.audioJackTest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AudioJackTests and only return the `id`
     * const audioJackTestWithIdOnly = await prisma.audioJackTest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AudioJackTestCreateManyAndReturnArgs>(args?: SelectSubset<T, AudioJackTestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AudioJackTestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AudioJackTest.
     * @param {AudioJackTestDeleteArgs} args - Arguments to delete one AudioJackTest.
     * @example
     * // Delete one AudioJackTest
     * const AudioJackTest = await prisma.audioJackTest.delete({
     *   where: {
     *     // ... filter to delete one AudioJackTest
     *   }
     * })
     * 
     */
    delete<T extends AudioJackTestDeleteArgs>(args: SelectSubset<T, AudioJackTestDeleteArgs<ExtArgs>>): Prisma__AudioJackTestClient<$Result.GetResult<Prisma.$AudioJackTestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AudioJackTest.
     * @param {AudioJackTestUpdateArgs} args - Arguments to update one AudioJackTest.
     * @example
     * // Update one AudioJackTest
     * const audioJackTest = await prisma.audioJackTest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AudioJackTestUpdateArgs>(args: SelectSubset<T, AudioJackTestUpdateArgs<ExtArgs>>): Prisma__AudioJackTestClient<$Result.GetResult<Prisma.$AudioJackTestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AudioJackTests.
     * @param {AudioJackTestDeleteManyArgs} args - Arguments to filter AudioJackTests to delete.
     * @example
     * // Delete a few AudioJackTests
     * const { count } = await prisma.audioJackTest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AudioJackTestDeleteManyArgs>(args?: SelectSubset<T, AudioJackTestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AudioJackTests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioJackTestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AudioJackTests
     * const audioJackTest = await prisma.audioJackTest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AudioJackTestUpdateManyArgs>(args: SelectSubset<T, AudioJackTestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AudioJackTests and returns the data updated in the database.
     * @param {AudioJackTestUpdateManyAndReturnArgs} args - Arguments to update many AudioJackTests.
     * @example
     * // Update many AudioJackTests
     * const audioJackTest = await prisma.audioJackTest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AudioJackTests and only return the `id`
     * const audioJackTestWithIdOnly = await prisma.audioJackTest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AudioJackTestUpdateManyAndReturnArgs>(args: SelectSubset<T, AudioJackTestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AudioJackTestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AudioJackTest.
     * @param {AudioJackTestUpsertArgs} args - Arguments to update or create a AudioJackTest.
     * @example
     * // Update or create a AudioJackTest
     * const audioJackTest = await prisma.audioJackTest.upsert({
     *   create: {
     *     // ... data to create a AudioJackTest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AudioJackTest we want to update
     *   }
     * })
     */
    upsert<T extends AudioJackTestUpsertArgs>(args: SelectSubset<T, AudioJackTestUpsertArgs<ExtArgs>>): Prisma__AudioJackTestClient<$Result.GetResult<Prisma.$AudioJackTestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AudioJackTests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioJackTestCountArgs} args - Arguments to filter AudioJackTests to count.
     * @example
     * // Count the number of AudioJackTests
     * const count = await prisma.audioJackTest.count({
     *   where: {
     *     // ... the filter for the AudioJackTests we want to count
     *   }
     * })
    **/
    count<T extends AudioJackTestCountArgs>(
      args?: Subset<T, AudioJackTestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AudioJackTestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AudioJackTest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioJackTestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AudioJackTestAggregateArgs>(args: Subset<T, AudioJackTestAggregateArgs>): Prisma.PrismaPromise<GetAudioJackTestAggregateType<T>>

    /**
     * Group by AudioJackTest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioJackTestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AudioJackTestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AudioJackTestGroupByArgs['orderBy'] }
        : { orderBy?: AudioJackTestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AudioJackTestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAudioJackTestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AudioJackTest model
   */
  readonly fields: AudioJackTestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AudioJackTest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AudioJackTestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    deviceTest<T extends DeviceTestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DeviceTestDefaultArgs<ExtArgs>>): Prisma__DeviceTestClient<$Result.GetResult<Prisma.$DeviceTestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AudioJackTest model
   */
  interface AudioJackTestFieldRefs {
    readonly id: FieldRef<"AudioJackTest", 'String'>
    readonly status: FieldRef<"AudioJackTest", 'Boolean'>
    readonly message: FieldRef<"AudioJackTest", 'String'>
    readonly timestamp: FieldRef<"AudioJackTest", 'DateTime'>
    readonly deviceTestId: FieldRef<"AudioJackTest", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AudioJackTest findUnique
   */
  export type AudioJackTestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioJackTest
     */
    select?: AudioJackTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AudioJackTest
     */
    omit?: AudioJackTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioJackTestInclude<ExtArgs> | null
    /**
     * Filter, which AudioJackTest to fetch.
     */
    where: AudioJackTestWhereUniqueInput
  }

  /**
   * AudioJackTest findUniqueOrThrow
   */
  export type AudioJackTestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioJackTest
     */
    select?: AudioJackTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AudioJackTest
     */
    omit?: AudioJackTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioJackTestInclude<ExtArgs> | null
    /**
     * Filter, which AudioJackTest to fetch.
     */
    where: AudioJackTestWhereUniqueInput
  }

  /**
   * AudioJackTest findFirst
   */
  export type AudioJackTestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioJackTest
     */
    select?: AudioJackTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AudioJackTest
     */
    omit?: AudioJackTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioJackTestInclude<ExtArgs> | null
    /**
     * Filter, which AudioJackTest to fetch.
     */
    where?: AudioJackTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AudioJackTests to fetch.
     */
    orderBy?: AudioJackTestOrderByWithRelationInput | AudioJackTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AudioJackTests.
     */
    cursor?: AudioJackTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AudioJackTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AudioJackTests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AudioJackTests.
     */
    distinct?: AudioJackTestScalarFieldEnum | AudioJackTestScalarFieldEnum[]
  }

  /**
   * AudioJackTest findFirstOrThrow
   */
  export type AudioJackTestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioJackTest
     */
    select?: AudioJackTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AudioJackTest
     */
    omit?: AudioJackTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioJackTestInclude<ExtArgs> | null
    /**
     * Filter, which AudioJackTest to fetch.
     */
    where?: AudioJackTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AudioJackTests to fetch.
     */
    orderBy?: AudioJackTestOrderByWithRelationInput | AudioJackTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AudioJackTests.
     */
    cursor?: AudioJackTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AudioJackTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AudioJackTests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AudioJackTests.
     */
    distinct?: AudioJackTestScalarFieldEnum | AudioJackTestScalarFieldEnum[]
  }

  /**
   * AudioJackTest findMany
   */
  export type AudioJackTestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioJackTest
     */
    select?: AudioJackTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AudioJackTest
     */
    omit?: AudioJackTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioJackTestInclude<ExtArgs> | null
    /**
     * Filter, which AudioJackTests to fetch.
     */
    where?: AudioJackTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AudioJackTests to fetch.
     */
    orderBy?: AudioJackTestOrderByWithRelationInput | AudioJackTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AudioJackTests.
     */
    cursor?: AudioJackTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AudioJackTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AudioJackTests.
     */
    skip?: number
    distinct?: AudioJackTestScalarFieldEnum | AudioJackTestScalarFieldEnum[]
  }

  /**
   * AudioJackTest create
   */
  export type AudioJackTestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioJackTest
     */
    select?: AudioJackTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AudioJackTest
     */
    omit?: AudioJackTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioJackTestInclude<ExtArgs> | null
    /**
     * The data needed to create a AudioJackTest.
     */
    data: XOR<AudioJackTestCreateInput, AudioJackTestUncheckedCreateInput>
  }

  /**
   * AudioJackTest createMany
   */
  export type AudioJackTestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AudioJackTests.
     */
    data: AudioJackTestCreateManyInput | AudioJackTestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AudioJackTest createManyAndReturn
   */
  export type AudioJackTestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioJackTest
     */
    select?: AudioJackTestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AudioJackTest
     */
    omit?: AudioJackTestOmit<ExtArgs> | null
    /**
     * The data used to create many AudioJackTests.
     */
    data: AudioJackTestCreateManyInput | AudioJackTestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioJackTestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AudioJackTest update
   */
  export type AudioJackTestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioJackTest
     */
    select?: AudioJackTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AudioJackTest
     */
    omit?: AudioJackTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioJackTestInclude<ExtArgs> | null
    /**
     * The data needed to update a AudioJackTest.
     */
    data: XOR<AudioJackTestUpdateInput, AudioJackTestUncheckedUpdateInput>
    /**
     * Choose, which AudioJackTest to update.
     */
    where: AudioJackTestWhereUniqueInput
  }

  /**
   * AudioJackTest updateMany
   */
  export type AudioJackTestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AudioJackTests.
     */
    data: XOR<AudioJackTestUpdateManyMutationInput, AudioJackTestUncheckedUpdateManyInput>
    /**
     * Filter which AudioJackTests to update
     */
    where?: AudioJackTestWhereInput
    /**
     * Limit how many AudioJackTests to update.
     */
    limit?: number
  }

  /**
   * AudioJackTest updateManyAndReturn
   */
  export type AudioJackTestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioJackTest
     */
    select?: AudioJackTestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AudioJackTest
     */
    omit?: AudioJackTestOmit<ExtArgs> | null
    /**
     * The data used to update AudioJackTests.
     */
    data: XOR<AudioJackTestUpdateManyMutationInput, AudioJackTestUncheckedUpdateManyInput>
    /**
     * Filter which AudioJackTests to update
     */
    where?: AudioJackTestWhereInput
    /**
     * Limit how many AudioJackTests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioJackTestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AudioJackTest upsert
   */
  export type AudioJackTestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioJackTest
     */
    select?: AudioJackTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AudioJackTest
     */
    omit?: AudioJackTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioJackTestInclude<ExtArgs> | null
    /**
     * The filter to search for the AudioJackTest to update in case it exists.
     */
    where: AudioJackTestWhereUniqueInput
    /**
     * In case the AudioJackTest found by the `where` argument doesn't exist, create a new AudioJackTest with this data.
     */
    create: XOR<AudioJackTestCreateInput, AudioJackTestUncheckedCreateInput>
    /**
     * In case the AudioJackTest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AudioJackTestUpdateInput, AudioJackTestUncheckedUpdateInput>
  }

  /**
   * AudioJackTest delete
   */
  export type AudioJackTestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioJackTest
     */
    select?: AudioJackTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AudioJackTest
     */
    omit?: AudioJackTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioJackTestInclude<ExtArgs> | null
    /**
     * Filter which AudioJackTest to delete.
     */
    where: AudioJackTestWhereUniqueInput
  }

  /**
   * AudioJackTest deleteMany
   */
  export type AudioJackTestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AudioJackTests to delete
     */
    where?: AudioJackTestWhereInput
    /**
     * Limit how many AudioJackTests to delete.
     */
    limit?: number
  }

  /**
   * AudioJackTest without action
   */
  export type AudioJackTestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioJackTest
     */
    select?: AudioJackTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AudioJackTest
     */
    omit?: AudioJackTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioJackTestInclude<ExtArgs> | null
  }


  /**
   * Model ManualDiagnosticsResult
   */

  export type AggregateManualDiagnosticsResult = {
    _count: ManualDiagnosticsResultCountAggregateOutputType | null
    _min: ManualDiagnosticsResultMinAggregateOutputType | null
    _max: ManualDiagnosticsResultMaxAggregateOutputType | null
  }

  export type ManualDiagnosticsResultMinAggregateOutputType = {
    id: string | null
    diagnoseId: string | null
    employeeId: string | null
    smc: string | null
    variant: string | null
    imei1: string | null
    imei2: string | null
    screenTouch: string | null
    screenSpot: string | null
    screenLines: string | null
    screenPhysical: string | null
    screenDiscolor: string | null
    screenBubble: string | null
    frontCamera: string | null
    backCamera: string | null
    audioJack: string | null
    wifi: string | null
    gps: string | null
    bluetooth: string | null
    volumeButton: string | null
    flashLight: string | null
    fcImageBlurred: string | null
    bcImageBlurred: string | null
    vibrator: string | null
    battery: string | null
    speaker: string | null
    microphone: string | null
    fingerprint: string | null
    proximity: string | null
    chargingPort: string | null
    powerButton: string | null
    faceLock: string | null
    copyScreen: string | null
    sim: string | null
    physicalScratch: string | null
    physicalDent: string | null
    physicalPanel: string | null
    physicalBent: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ManualDiagnosticsResultMaxAggregateOutputType = {
    id: string | null
    diagnoseId: string | null
    employeeId: string | null
    smc: string | null
    variant: string | null
    imei1: string | null
    imei2: string | null
    screenTouch: string | null
    screenSpot: string | null
    screenLines: string | null
    screenPhysical: string | null
    screenDiscolor: string | null
    screenBubble: string | null
    frontCamera: string | null
    backCamera: string | null
    audioJack: string | null
    wifi: string | null
    gps: string | null
    bluetooth: string | null
    volumeButton: string | null
    flashLight: string | null
    fcImageBlurred: string | null
    bcImageBlurred: string | null
    vibrator: string | null
    battery: string | null
    speaker: string | null
    microphone: string | null
    fingerprint: string | null
    proximity: string | null
    chargingPort: string | null
    powerButton: string | null
    faceLock: string | null
    copyScreen: string | null
    sim: string | null
    physicalScratch: string | null
    physicalDent: string | null
    physicalPanel: string | null
    physicalBent: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ManualDiagnosticsResultCountAggregateOutputType = {
    id: number
    diagnoseId: number
    employeeId: number
    smc: number
    variant: number
    imei1: number
    imei2: number
    screenTouch: number
    screenSpot: number
    screenLines: number
    screenPhysical: number
    screenDiscolor: number
    screenBubble: number
    frontCamera: number
    backCamera: number
    audioJack: number
    wifi: number
    gps: number
    bluetooth: number
    volumeButton: number
    flashLight: number
    fcImageBlurred: number
    bcImageBlurred: number
    vibrator: number
    battery: number
    speaker: number
    microphone: number
    fingerprint: number
    proximity: number
    chargingPort: number
    powerButton: number
    faceLock: number
    copyScreen: number
    sim: number
    physicalScratch: number
    physicalDent: number
    physicalPanel: number
    physicalBent: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ManualDiagnosticsResultMinAggregateInputType = {
    id?: true
    diagnoseId?: true
    employeeId?: true
    smc?: true
    variant?: true
    imei1?: true
    imei2?: true
    screenTouch?: true
    screenSpot?: true
    screenLines?: true
    screenPhysical?: true
    screenDiscolor?: true
    screenBubble?: true
    frontCamera?: true
    backCamera?: true
    audioJack?: true
    wifi?: true
    gps?: true
    bluetooth?: true
    volumeButton?: true
    flashLight?: true
    fcImageBlurred?: true
    bcImageBlurred?: true
    vibrator?: true
    battery?: true
    speaker?: true
    microphone?: true
    fingerprint?: true
    proximity?: true
    chargingPort?: true
    powerButton?: true
    faceLock?: true
    copyScreen?: true
    sim?: true
    physicalScratch?: true
    physicalDent?: true
    physicalPanel?: true
    physicalBent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ManualDiagnosticsResultMaxAggregateInputType = {
    id?: true
    diagnoseId?: true
    employeeId?: true
    smc?: true
    variant?: true
    imei1?: true
    imei2?: true
    screenTouch?: true
    screenSpot?: true
    screenLines?: true
    screenPhysical?: true
    screenDiscolor?: true
    screenBubble?: true
    frontCamera?: true
    backCamera?: true
    audioJack?: true
    wifi?: true
    gps?: true
    bluetooth?: true
    volumeButton?: true
    flashLight?: true
    fcImageBlurred?: true
    bcImageBlurred?: true
    vibrator?: true
    battery?: true
    speaker?: true
    microphone?: true
    fingerprint?: true
    proximity?: true
    chargingPort?: true
    powerButton?: true
    faceLock?: true
    copyScreen?: true
    sim?: true
    physicalScratch?: true
    physicalDent?: true
    physicalPanel?: true
    physicalBent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ManualDiagnosticsResultCountAggregateInputType = {
    id?: true
    diagnoseId?: true
    employeeId?: true
    smc?: true
    variant?: true
    imei1?: true
    imei2?: true
    screenTouch?: true
    screenSpot?: true
    screenLines?: true
    screenPhysical?: true
    screenDiscolor?: true
    screenBubble?: true
    frontCamera?: true
    backCamera?: true
    audioJack?: true
    wifi?: true
    gps?: true
    bluetooth?: true
    volumeButton?: true
    flashLight?: true
    fcImageBlurred?: true
    bcImageBlurred?: true
    vibrator?: true
    battery?: true
    speaker?: true
    microphone?: true
    fingerprint?: true
    proximity?: true
    chargingPort?: true
    powerButton?: true
    faceLock?: true
    copyScreen?: true
    sim?: true
    physicalScratch?: true
    physicalDent?: true
    physicalPanel?: true
    physicalBent?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ManualDiagnosticsResultAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ManualDiagnosticsResult to aggregate.
     */
    where?: ManualDiagnosticsResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ManualDiagnosticsResults to fetch.
     */
    orderBy?: ManualDiagnosticsResultOrderByWithRelationInput | ManualDiagnosticsResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ManualDiagnosticsResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ManualDiagnosticsResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ManualDiagnosticsResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ManualDiagnosticsResults
    **/
    _count?: true | ManualDiagnosticsResultCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ManualDiagnosticsResultMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ManualDiagnosticsResultMaxAggregateInputType
  }

  export type GetManualDiagnosticsResultAggregateType<T extends ManualDiagnosticsResultAggregateArgs> = {
        [P in keyof T & keyof AggregateManualDiagnosticsResult]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateManualDiagnosticsResult[P]>
      : GetScalarType<T[P], AggregateManualDiagnosticsResult[P]>
  }




  export type ManualDiagnosticsResultGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ManualDiagnosticsResultWhereInput
    orderBy?: ManualDiagnosticsResultOrderByWithAggregationInput | ManualDiagnosticsResultOrderByWithAggregationInput[]
    by: ManualDiagnosticsResultScalarFieldEnum[] | ManualDiagnosticsResultScalarFieldEnum
    having?: ManualDiagnosticsResultScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ManualDiagnosticsResultCountAggregateInputType | true
    _min?: ManualDiagnosticsResultMinAggregateInputType
    _max?: ManualDiagnosticsResultMaxAggregateInputType
  }

  export type ManualDiagnosticsResultGroupByOutputType = {
    id: string
    diagnoseId: string
    employeeId: string | null
    smc: string
    variant: string
    imei1: string | null
    imei2: string | null
    screenTouch: string
    screenSpot: string
    screenLines: string
    screenPhysical: string
    screenDiscolor: string
    screenBubble: string
    frontCamera: string
    backCamera: string
    audioJack: string
    wifi: string
    gps: string
    bluetooth: string
    volumeButton: string
    flashLight: string
    fcImageBlurred: string
    bcImageBlurred: string
    vibrator: string
    battery: string
    speaker: string
    microphone: string
    fingerprint: string
    proximity: string
    chargingPort: string
    powerButton: string
    faceLock: string
    copyScreen: string
    sim: string
    physicalScratch: string
    physicalDent: string
    physicalPanel: string
    physicalBent: string
    createdAt: Date
    updatedAt: Date
    _count: ManualDiagnosticsResultCountAggregateOutputType | null
    _min: ManualDiagnosticsResultMinAggregateOutputType | null
    _max: ManualDiagnosticsResultMaxAggregateOutputType | null
  }

  type GetManualDiagnosticsResultGroupByPayload<T extends ManualDiagnosticsResultGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ManualDiagnosticsResultGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ManualDiagnosticsResultGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ManualDiagnosticsResultGroupByOutputType[P]>
            : GetScalarType<T[P], ManualDiagnosticsResultGroupByOutputType[P]>
        }
      >
    >


  export type ManualDiagnosticsResultSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    diagnoseId?: boolean
    employeeId?: boolean
    smc?: boolean
    variant?: boolean
    imei1?: boolean
    imei2?: boolean
    screenTouch?: boolean
    screenSpot?: boolean
    screenLines?: boolean
    screenPhysical?: boolean
    screenDiscolor?: boolean
    screenBubble?: boolean
    frontCamera?: boolean
    backCamera?: boolean
    audioJack?: boolean
    wifi?: boolean
    gps?: boolean
    bluetooth?: boolean
    volumeButton?: boolean
    flashLight?: boolean
    fcImageBlurred?: boolean
    bcImageBlurred?: boolean
    vibrator?: boolean
    battery?: boolean
    speaker?: boolean
    microphone?: boolean
    fingerprint?: boolean
    proximity?: boolean
    chargingPort?: boolean
    powerButton?: boolean
    faceLock?: boolean
    copyScreen?: boolean
    sim?: boolean
    physicalScratch?: boolean
    physicalDent?: boolean
    physicalPanel?: boolean
    physicalBent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["manualDiagnosticsResult"]>

  export type ManualDiagnosticsResultSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    diagnoseId?: boolean
    employeeId?: boolean
    smc?: boolean
    variant?: boolean
    imei1?: boolean
    imei2?: boolean
    screenTouch?: boolean
    screenSpot?: boolean
    screenLines?: boolean
    screenPhysical?: boolean
    screenDiscolor?: boolean
    screenBubble?: boolean
    frontCamera?: boolean
    backCamera?: boolean
    audioJack?: boolean
    wifi?: boolean
    gps?: boolean
    bluetooth?: boolean
    volumeButton?: boolean
    flashLight?: boolean
    fcImageBlurred?: boolean
    bcImageBlurred?: boolean
    vibrator?: boolean
    battery?: boolean
    speaker?: boolean
    microphone?: boolean
    fingerprint?: boolean
    proximity?: boolean
    chargingPort?: boolean
    powerButton?: boolean
    faceLock?: boolean
    copyScreen?: boolean
    sim?: boolean
    physicalScratch?: boolean
    physicalDent?: boolean
    physicalPanel?: boolean
    physicalBent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["manualDiagnosticsResult"]>

  export type ManualDiagnosticsResultSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    diagnoseId?: boolean
    employeeId?: boolean
    smc?: boolean
    variant?: boolean
    imei1?: boolean
    imei2?: boolean
    screenTouch?: boolean
    screenSpot?: boolean
    screenLines?: boolean
    screenPhysical?: boolean
    screenDiscolor?: boolean
    screenBubble?: boolean
    frontCamera?: boolean
    backCamera?: boolean
    audioJack?: boolean
    wifi?: boolean
    gps?: boolean
    bluetooth?: boolean
    volumeButton?: boolean
    flashLight?: boolean
    fcImageBlurred?: boolean
    bcImageBlurred?: boolean
    vibrator?: boolean
    battery?: boolean
    speaker?: boolean
    microphone?: boolean
    fingerprint?: boolean
    proximity?: boolean
    chargingPort?: boolean
    powerButton?: boolean
    faceLock?: boolean
    copyScreen?: boolean
    sim?: boolean
    physicalScratch?: boolean
    physicalDent?: boolean
    physicalPanel?: boolean
    physicalBent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["manualDiagnosticsResult"]>

  export type ManualDiagnosticsResultSelectScalar = {
    id?: boolean
    diagnoseId?: boolean
    employeeId?: boolean
    smc?: boolean
    variant?: boolean
    imei1?: boolean
    imei2?: boolean
    screenTouch?: boolean
    screenSpot?: boolean
    screenLines?: boolean
    screenPhysical?: boolean
    screenDiscolor?: boolean
    screenBubble?: boolean
    frontCamera?: boolean
    backCamera?: boolean
    audioJack?: boolean
    wifi?: boolean
    gps?: boolean
    bluetooth?: boolean
    volumeButton?: boolean
    flashLight?: boolean
    fcImageBlurred?: boolean
    bcImageBlurred?: boolean
    vibrator?: boolean
    battery?: boolean
    speaker?: boolean
    microphone?: boolean
    fingerprint?: boolean
    proximity?: boolean
    chargingPort?: boolean
    powerButton?: boolean
    faceLock?: boolean
    copyScreen?: boolean
    sim?: boolean
    physicalScratch?: boolean
    physicalDent?: boolean
    physicalPanel?: boolean
    physicalBent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ManualDiagnosticsResultOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "diagnoseId" | "employeeId" | "smc" | "variant" | "imei1" | "imei2" | "screenTouch" | "screenSpot" | "screenLines" | "screenPhysical" | "screenDiscolor" | "screenBubble" | "frontCamera" | "backCamera" | "audioJack" | "wifi" | "gps" | "bluetooth" | "volumeButton" | "flashLight" | "fcImageBlurred" | "bcImageBlurred" | "vibrator" | "battery" | "speaker" | "microphone" | "fingerprint" | "proximity" | "chargingPort" | "powerButton" | "faceLock" | "copyScreen" | "sim" | "physicalScratch" | "physicalDent" | "physicalPanel" | "physicalBent" | "createdAt" | "updatedAt", ExtArgs["result"]["manualDiagnosticsResult"]>

  export type $ManualDiagnosticsResultPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ManualDiagnosticsResult"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      diagnoseId: string
      employeeId: string | null
      smc: string
      variant: string
      imei1: string | null
      imei2: string | null
      screenTouch: string
      screenSpot: string
      screenLines: string
      screenPhysical: string
      screenDiscolor: string
      screenBubble: string
      frontCamera: string
      backCamera: string
      audioJack: string
      wifi: string
      gps: string
      bluetooth: string
      volumeButton: string
      flashLight: string
      fcImageBlurred: string
      bcImageBlurred: string
      vibrator: string
      battery: string
      speaker: string
      microphone: string
      fingerprint: string
      proximity: string
      chargingPort: string
      powerButton: string
      faceLock: string
      copyScreen: string
      sim: string
      physicalScratch: string
      physicalDent: string
      physicalPanel: string
      physicalBent: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["manualDiagnosticsResult"]>
    composites: {}
  }

  type ManualDiagnosticsResultGetPayload<S extends boolean | null | undefined | ManualDiagnosticsResultDefaultArgs> = $Result.GetResult<Prisma.$ManualDiagnosticsResultPayload, S>

  type ManualDiagnosticsResultCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ManualDiagnosticsResultFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ManualDiagnosticsResultCountAggregateInputType | true
    }

  export interface ManualDiagnosticsResultDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ManualDiagnosticsResult'], meta: { name: 'ManualDiagnosticsResult' } }
    /**
     * Find zero or one ManualDiagnosticsResult that matches the filter.
     * @param {ManualDiagnosticsResultFindUniqueArgs} args - Arguments to find a ManualDiagnosticsResult
     * @example
     * // Get one ManualDiagnosticsResult
     * const manualDiagnosticsResult = await prisma.manualDiagnosticsResult.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ManualDiagnosticsResultFindUniqueArgs>(args: SelectSubset<T, ManualDiagnosticsResultFindUniqueArgs<ExtArgs>>): Prisma__ManualDiagnosticsResultClient<$Result.GetResult<Prisma.$ManualDiagnosticsResultPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ManualDiagnosticsResult that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ManualDiagnosticsResultFindUniqueOrThrowArgs} args - Arguments to find a ManualDiagnosticsResult
     * @example
     * // Get one ManualDiagnosticsResult
     * const manualDiagnosticsResult = await prisma.manualDiagnosticsResult.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ManualDiagnosticsResultFindUniqueOrThrowArgs>(args: SelectSubset<T, ManualDiagnosticsResultFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ManualDiagnosticsResultClient<$Result.GetResult<Prisma.$ManualDiagnosticsResultPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ManualDiagnosticsResult that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManualDiagnosticsResultFindFirstArgs} args - Arguments to find a ManualDiagnosticsResult
     * @example
     * // Get one ManualDiagnosticsResult
     * const manualDiagnosticsResult = await prisma.manualDiagnosticsResult.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ManualDiagnosticsResultFindFirstArgs>(args?: SelectSubset<T, ManualDiagnosticsResultFindFirstArgs<ExtArgs>>): Prisma__ManualDiagnosticsResultClient<$Result.GetResult<Prisma.$ManualDiagnosticsResultPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ManualDiagnosticsResult that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManualDiagnosticsResultFindFirstOrThrowArgs} args - Arguments to find a ManualDiagnosticsResult
     * @example
     * // Get one ManualDiagnosticsResult
     * const manualDiagnosticsResult = await prisma.manualDiagnosticsResult.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ManualDiagnosticsResultFindFirstOrThrowArgs>(args?: SelectSubset<T, ManualDiagnosticsResultFindFirstOrThrowArgs<ExtArgs>>): Prisma__ManualDiagnosticsResultClient<$Result.GetResult<Prisma.$ManualDiagnosticsResultPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ManualDiagnosticsResults that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManualDiagnosticsResultFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ManualDiagnosticsResults
     * const manualDiagnosticsResults = await prisma.manualDiagnosticsResult.findMany()
     * 
     * // Get first 10 ManualDiagnosticsResults
     * const manualDiagnosticsResults = await prisma.manualDiagnosticsResult.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const manualDiagnosticsResultWithIdOnly = await prisma.manualDiagnosticsResult.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ManualDiagnosticsResultFindManyArgs>(args?: SelectSubset<T, ManualDiagnosticsResultFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ManualDiagnosticsResultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ManualDiagnosticsResult.
     * @param {ManualDiagnosticsResultCreateArgs} args - Arguments to create a ManualDiagnosticsResult.
     * @example
     * // Create one ManualDiagnosticsResult
     * const ManualDiagnosticsResult = await prisma.manualDiagnosticsResult.create({
     *   data: {
     *     // ... data to create a ManualDiagnosticsResult
     *   }
     * })
     * 
     */
    create<T extends ManualDiagnosticsResultCreateArgs>(args: SelectSubset<T, ManualDiagnosticsResultCreateArgs<ExtArgs>>): Prisma__ManualDiagnosticsResultClient<$Result.GetResult<Prisma.$ManualDiagnosticsResultPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ManualDiagnosticsResults.
     * @param {ManualDiagnosticsResultCreateManyArgs} args - Arguments to create many ManualDiagnosticsResults.
     * @example
     * // Create many ManualDiagnosticsResults
     * const manualDiagnosticsResult = await prisma.manualDiagnosticsResult.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ManualDiagnosticsResultCreateManyArgs>(args?: SelectSubset<T, ManualDiagnosticsResultCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ManualDiagnosticsResults and returns the data saved in the database.
     * @param {ManualDiagnosticsResultCreateManyAndReturnArgs} args - Arguments to create many ManualDiagnosticsResults.
     * @example
     * // Create many ManualDiagnosticsResults
     * const manualDiagnosticsResult = await prisma.manualDiagnosticsResult.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ManualDiagnosticsResults and only return the `id`
     * const manualDiagnosticsResultWithIdOnly = await prisma.manualDiagnosticsResult.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ManualDiagnosticsResultCreateManyAndReturnArgs>(args?: SelectSubset<T, ManualDiagnosticsResultCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ManualDiagnosticsResultPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ManualDiagnosticsResult.
     * @param {ManualDiagnosticsResultDeleteArgs} args - Arguments to delete one ManualDiagnosticsResult.
     * @example
     * // Delete one ManualDiagnosticsResult
     * const ManualDiagnosticsResult = await prisma.manualDiagnosticsResult.delete({
     *   where: {
     *     // ... filter to delete one ManualDiagnosticsResult
     *   }
     * })
     * 
     */
    delete<T extends ManualDiagnosticsResultDeleteArgs>(args: SelectSubset<T, ManualDiagnosticsResultDeleteArgs<ExtArgs>>): Prisma__ManualDiagnosticsResultClient<$Result.GetResult<Prisma.$ManualDiagnosticsResultPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ManualDiagnosticsResult.
     * @param {ManualDiagnosticsResultUpdateArgs} args - Arguments to update one ManualDiagnosticsResult.
     * @example
     * // Update one ManualDiagnosticsResult
     * const manualDiagnosticsResult = await prisma.manualDiagnosticsResult.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ManualDiagnosticsResultUpdateArgs>(args: SelectSubset<T, ManualDiagnosticsResultUpdateArgs<ExtArgs>>): Prisma__ManualDiagnosticsResultClient<$Result.GetResult<Prisma.$ManualDiagnosticsResultPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ManualDiagnosticsResults.
     * @param {ManualDiagnosticsResultDeleteManyArgs} args - Arguments to filter ManualDiagnosticsResults to delete.
     * @example
     * // Delete a few ManualDiagnosticsResults
     * const { count } = await prisma.manualDiagnosticsResult.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ManualDiagnosticsResultDeleteManyArgs>(args?: SelectSubset<T, ManualDiagnosticsResultDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ManualDiagnosticsResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManualDiagnosticsResultUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ManualDiagnosticsResults
     * const manualDiagnosticsResult = await prisma.manualDiagnosticsResult.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ManualDiagnosticsResultUpdateManyArgs>(args: SelectSubset<T, ManualDiagnosticsResultUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ManualDiagnosticsResults and returns the data updated in the database.
     * @param {ManualDiagnosticsResultUpdateManyAndReturnArgs} args - Arguments to update many ManualDiagnosticsResults.
     * @example
     * // Update many ManualDiagnosticsResults
     * const manualDiagnosticsResult = await prisma.manualDiagnosticsResult.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ManualDiagnosticsResults and only return the `id`
     * const manualDiagnosticsResultWithIdOnly = await prisma.manualDiagnosticsResult.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ManualDiagnosticsResultUpdateManyAndReturnArgs>(args: SelectSubset<T, ManualDiagnosticsResultUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ManualDiagnosticsResultPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ManualDiagnosticsResult.
     * @param {ManualDiagnosticsResultUpsertArgs} args - Arguments to update or create a ManualDiagnosticsResult.
     * @example
     * // Update or create a ManualDiagnosticsResult
     * const manualDiagnosticsResult = await prisma.manualDiagnosticsResult.upsert({
     *   create: {
     *     // ... data to create a ManualDiagnosticsResult
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ManualDiagnosticsResult we want to update
     *   }
     * })
     */
    upsert<T extends ManualDiagnosticsResultUpsertArgs>(args: SelectSubset<T, ManualDiagnosticsResultUpsertArgs<ExtArgs>>): Prisma__ManualDiagnosticsResultClient<$Result.GetResult<Prisma.$ManualDiagnosticsResultPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ManualDiagnosticsResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManualDiagnosticsResultCountArgs} args - Arguments to filter ManualDiagnosticsResults to count.
     * @example
     * // Count the number of ManualDiagnosticsResults
     * const count = await prisma.manualDiagnosticsResult.count({
     *   where: {
     *     // ... the filter for the ManualDiagnosticsResults we want to count
     *   }
     * })
    **/
    count<T extends ManualDiagnosticsResultCountArgs>(
      args?: Subset<T, ManualDiagnosticsResultCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ManualDiagnosticsResultCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ManualDiagnosticsResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManualDiagnosticsResultAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ManualDiagnosticsResultAggregateArgs>(args: Subset<T, ManualDiagnosticsResultAggregateArgs>): Prisma.PrismaPromise<GetManualDiagnosticsResultAggregateType<T>>

    /**
     * Group by ManualDiagnosticsResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManualDiagnosticsResultGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ManualDiagnosticsResultGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ManualDiagnosticsResultGroupByArgs['orderBy'] }
        : { orderBy?: ManualDiagnosticsResultGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ManualDiagnosticsResultGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetManualDiagnosticsResultGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ManualDiagnosticsResult model
   */
  readonly fields: ManualDiagnosticsResultFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ManualDiagnosticsResult.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ManualDiagnosticsResultClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ManualDiagnosticsResult model
   */
  interface ManualDiagnosticsResultFieldRefs {
    readonly id: FieldRef<"ManualDiagnosticsResult", 'String'>
    readonly diagnoseId: FieldRef<"ManualDiagnosticsResult", 'String'>
    readonly employeeId: FieldRef<"ManualDiagnosticsResult", 'String'>
    readonly smc: FieldRef<"ManualDiagnosticsResult", 'String'>
    readonly variant: FieldRef<"ManualDiagnosticsResult", 'String'>
    readonly imei1: FieldRef<"ManualDiagnosticsResult", 'String'>
    readonly imei2: FieldRef<"ManualDiagnosticsResult", 'String'>
    readonly screenTouch: FieldRef<"ManualDiagnosticsResult", 'String'>
    readonly screenSpot: FieldRef<"ManualDiagnosticsResult", 'String'>
    readonly screenLines: FieldRef<"ManualDiagnosticsResult", 'String'>
    readonly screenPhysical: FieldRef<"ManualDiagnosticsResult", 'String'>
    readonly screenDiscolor: FieldRef<"ManualDiagnosticsResult", 'String'>
    readonly screenBubble: FieldRef<"ManualDiagnosticsResult", 'String'>
    readonly frontCamera: FieldRef<"ManualDiagnosticsResult", 'String'>
    readonly backCamera: FieldRef<"ManualDiagnosticsResult", 'String'>
    readonly audioJack: FieldRef<"ManualDiagnosticsResult", 'String'>
    readonly wifi: FieldRef<"ManualDiagnosticsResult", 'String'>
    readonly gps: FieldRef<"ManualDiagnosticsResult", 'String'>
    readonly bluetooth: FieldRef<"ManualDiagnosticsResult", 'String'>
    readonly volumeButton: FieldRef<"ManualDiagnosticsResult", 'String'>
    readonly flashLight: FieldRef<"ManualDiagnosticsResult", 'String'>
    readonly fcImageBlurred: FieldRef<"ManualDiagnosticsResult", 'String'>
    readonly bcImageBlurred: FieldRef<"ManualDiagnosticsResult", 'String'>
    readonly vibrator: FieldRef<"ManualDiagnosticsResult", 'String'>
    readonly battery: FieldRef<"ManualDiagnosticsResult", 'String'>
    readonly speaker: FieldRef<"ManualDiagnosticsResult", 'String'>
    readonly microphone: FieldRef<"ManualDiagnosticsResult", 'String'>
    readonly fingerprint: FieldRef<"ManualDiagnosticsResult", 'String'>
    readonly proximity: FieldRef<"ManualDiagnosticsResult", 'String'>
    readonly chargingPort: FieldRef<"ManualDiagnosticsResult", 'String'>
    readonly powerButton: FieldRef<"ManualDiagnosticsResult", 'String'>
    readonly faceLock: FieldRef<"ManualDiagnosticsResult", 'String'>
    readonly copyScreen: FieldRef<"ManualDiagnosticsResult", 'String'>
    readonly sim: FieldRef<"ManualDiagnosticsResult", 'String'>
    readonly physicalScratch: FieldRef<"ManualDiagnosticsResult", 'String'>
    readonly physicalDent: FieldRef<"ManualDiagnosticsResult", 'String'>
    readonly physicalPanel: FieldRef<"ManualDiagnosticsResult", 'String'>
    readonly physicalBent: FieldRef<"ManualDiagnosticsResult", 'String'>
    readonly createdAt: FieldRef<"ManualDiagnosticsResult", 'DateTime'>
    readonly updatedAt: FieldRef<"ManualDiagnosticsResult", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ManualDiagnosticsResult findUnique
   */
  export type ManualDiagnosticsResultFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManualDiagnosticsResult
     */
    select?: ManualDiagnosticsResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ManualDiagnosticsResult
     */
    omit?: ManualDiagnosticsResultOmit<ExtArgs> | null
    /**
     * Filter, which ManualDiagnosticsResult to fetch.
     */
    where: ManualDiagnosticsResultWhereUniqueInput
  }

  /**
   * ManualDiagnosticsResult findUniqueOrThrow
   */
  export type ManualDiagnosticsResultFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManualDiagnosticsResult
     */
    select?: ManualDiagnosticsResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ManualDiagnosticsResult
     */
    omit?: ManualDiagnosticsResultOmit<ExtArgs> | null
    /**
     * Filter, which ManualDiagnosticsResult to fetch.
     */
    where: ManualDiagnosticsResultWhereUniqueInput
  }

  /**
   * ManualDiagnosticsResult findFirst
   */
  export type ManualDiagnosticsResultFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManualDiagnosticsResult
     */
    select?: ManualDiagnosticsResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ManualDiagnosticsResult
     */
    omit?: ManualDiagnosticsResultOmit<ExtArgs> | null
    /**
     * Filter, which ManualDiagnosticsResult to fetch.
     */
    where?: ManualDiagnosticsResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ManualDiagnosticsResults to fetch.
     */
    orderBy?: ManualDiagnosticsResultOrderByWithRelationInput | ManualDiagnosticsResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ManualDiagnosticsResults.
     */
    cursor?: ManualDiagnosticsResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ManualDiagnosticsResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ManualDiagnosticsResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ManualDiagnosticsResults.
     */
    distinct?: ManualDiagnosticsResultScalarFieldEnum | ManualDiagnosticsResultScalarFieldEnum[]
  }

  /**
   * ManualDiagnosticsResult findFirstOrThrow
   */
  export type ManualDiagnosticsResultFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManualDiagnosticsResult
     */
    select?: ManualDiagnosticsResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ManualDiagnosticsResult
     */
    omit?: ManualDiagnosticsResultOmit<ExtArgs> | null
    /**
     * Filter, which ManualDiagnosticsResult to fetch.
     */
    where?: ManualDiagnosticsResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ManualDiagnosticsResults to fetch.
     */
    orderBy?: ManualDiagnosticsResultOrderByWithRelationInput | ManualDiagnosticsResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ManualDiagnosticsResults.
     */
    cursor?: ManualDiagnosticsResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ManualDiagnosticsResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ManualDiagnosticsResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ManualDiagnosticsResults.
     */
    distinct?: ManualDiagnosticsResultScalarFieldEnum | ManualDiagnosticsResultScalarFieldEnum[]
  }

  /**
   * ManualDiagnosticsResult findMany
   */
  export type ManualDiagnosticsResultFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManualDiagnosticsResult
     */
    select?: ManualDiagnosticsResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ManualDiagnosticsResult
     */
    omit?: ManualDiagnosticsResultOmit<ExtArgs> | null
    /**
     * Filter, which ManualDiagnosticsResults to fetch.
     */
    where?: ManualDiagnosticsResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ManualDiagnosticsResults to fetch.
     */
    orderBy?: ManualDiagnosticsResultOrderByWithRelationInput | ManualDiagnosticsResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ManualDiagnosticsResults.
     */
    cursor?: ManualDiagnosticsResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ManualDiagnosticsResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ManualDiagnosticsResults.
     */
    skip?: number
    distinct?: ManualDiagnosticsResultScalarFieldEnum | ManualDiagnosticsResultScalarFieldEnum[]
  }

  /**
   * ManualDiagnosticsResult create
   */
  export type ManualDiagnosticsResultCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManualDiagnosticsResult
     */
    select?: ManualDiagnosticsResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ManualDiagnosticsResult
     */
    omit?: ManualDiagnosticsResultOmit<ExtArgs> | null
    /**
     * The data needed to create a ManualDiagnosticsResult.
     */
    data: XOR<ManualDiagnosticsResultCreateInput, ManualDiagnosticsResultUncheckedCreateInput>
  }

  /**
   * ManualDiagnosticsResult createMany
   */
  export type ManualDiagnosticsResultCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ManualDiagnosticsResults.
     */
    data: ManualDiagnosticsResultCreateManyInput | ManualDiagnosticsResultCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ManualDiagnosticsResult createManyAndReturn
   */
  export type ManualDiagnosticsResultCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManualDiagnosticsResult
     */
    select?: ManualDiagnosticsResultSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ManualDiagnosticsResult
     */
    omit?: ManualDiagnosticsResultOmit<ExtArgs> | null
    /**
     * The data used to create many ManualDiagnosticsResults.
     */
    data: ManualDiagnosticsResultCreateManyInput | ManualDiagnosticsResultCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ManualDiagnosticsResult update
   */
  export type ManualDiagnosticsResultUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManualDiagnosticsResult
     */
    select?: ManualDiagnosticsResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ManualDiagnosticsResult
     */
    omit?: ManualDiagnosticsResultOmit<ExtArgs> | null
    /**
     * The data needed to update a ManualDiagnosticsResult.
     */
    data: XOR<ManualDiagnosticsResultUpdateInput, ManualDiagnosticsResultUncheckedUpdateInput>
    /**
     * Choose, which ManualDiagnosticsResult to update.
     */
    where: ManualDiagnosticsResultWhereUniqueInput
  }

  /**
   * ManualDiagnosticsResult updateMany
   */
  export type ManualDiagnosticsResultUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ManualDiagnosticsResults.
     */
    data: XOR<ManualDiagnosticsResultUpdateManyMutationInput, ManualDiagnosticsResultUncheckedUpdateManyInput>
    /**
     * Filter which ManualDiagnosticsResults to update
     */
    where?: ManualDiagnosticsResultWhereInput
    /**
     * Limit how many ManualDiagnosticsResults to update.
     */
    limit?: number
  }

  /**
   * ManualDiagnosticsResult updateManyAndReturn
   */
  export type ManualDiagnosticsResultUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManualDiagnosticsResult
     */
    select?: ManualDiagnosticsResultSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ManualDiagnosticsResult
     */
    omit?: ManualDiagnosticsResultOmit<ExtArgs> | null
    /**
     * The data used to update ManualDiagnosticsResults.
     */
    data: XOR<ManualDiagnosticsResultUpdateManyMutationInput, ManualDiagnosticsResultUncheckedUpdateManyInput>
    /**
     * Filter which ManualDiagnosticsResults to update
     */
    where?: ManualDiagnosticsResultWhereInput
    /**
     * Limit how many ManualDiagnosticsResults to update.
     */
    limit?: number
  }

  /**
   * ManualDiagnosticsResult upsert
   */
  export type ManualDiagnosticsResultUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManualDiagnosticsResult
     */
    select?: ManualDiagnosticsResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ManualDiagnosticsResult
     */
    omit?: ManualDiagnosticsResultOmit<ExtArgs> | null
    /**
     * The filter to search for the ManualDiagnosticsResult to update in case it exists.
     */
    where: ManualDiagnosticsResultWhereUniqueInput
    /**
     * In case the ManualDiagnosticsResult found by the `where` argument doesn't exist, create a new ManualDiagnosticsResult with this data.
     */
    create: XOR<ManualDiagnosticsResultCreateInput, ManualDiagnosticsResultUncheckedCreateInput>
    /**
     * In case the ManualDiagnosticsResult was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ManualDiagnosticsResultUpdateInput, ManualDiagnosticsResultUncheckedUpdateInput>
  }

  /**
   * ManualDiagnosticsResult delete
   */
  export type ManualDiagnosticsResultDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManualDiagnosticsResult
     */
    select?: ManualDiagnosticsResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ManualDiagnosticsResult
     */
    omit?: ManualDiagnosticsResultOmit<ExtArgs> | null
    /**
     * Filter which ManualDiagnosticsResult to delete.
     */
    where: ManualDiagnosticsResultWhereUniqueInput
  }

  /**
   * ManualDiagnosticsResult deleteMany
   */
  export type ManualDiagnosticsResultDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ManualDiagnosticsResults to delete
     */
    where?: ManualDiagnosticsResultWhereInput
    /**
     * Limit how many ManualDiagnosticsResults to delete.
     */
    limit?: number
  }

  /**
   * ManualDiagnosticsResult without action
   */
  export type ManualDiagnosticsResultDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManualDiagnosticsResult
     */
    select?: ManualDiagnosticsResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ManualDiagnosticsResult
     */
    omit?: ManualDiagnosticsResultOmit<ExtArgs> | null
  }


  /**
   * Model Declaration
   */

  export type AggregateDeclaration = {
    _count: DeclarationCountAggregateOutputType | null
    _min: DeclarationMinAggregateOutputType | null
    _max: DeclarationMaxAggregateOutputType | null
  }

  export type DeclarationMinAggregateOutputType = {
    id: string | null
    orderId: string | null
    brand: string | null
    model: string | null
    smc: string | null
    variant: string | null
    imei1: string | null
    imei2: string | null
    bluetooth: string | null
    gps: string | null
    wifi: string | null
    proximity: string | null
    multiTouch: string | null
    screenCalibration: string | null
    speaker: string | null
    earReceiver: string | null
    microphone: string | null
    frontCamera: string | null
    backCamera: string | null
    sim: string | null
    fingerprint: string | null
    chargingPort: string | null
    audioJack: string | null
    isAccepted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DeclarationMaxAggregateOutputType = {
    id: string | null
    orderId: string | null
    brand: string | null
    model: string | null
    smc: string | null
    variant: string | null
    imei1: string | null
    imei2: string | null
    bluetooth: string | null
    gps: string | null
    wifi: string | null
    proximity: string | null
    multiTouch: string | null
    screenCalibration: string | null
    speaker: string | null
    earReceiver: string | null
    microphone: string | null
    frontCamera: string | null
    backCamera: string | null
    sim: string | null
    fingerprint: string | null
    chargingPort: string | null
    audioJack: string | null
    isAccepted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DeclarationCountAggregateOutputType = {
    id: number
    orderId: number
    brand: number
    model: number
    smc: number
    variant: number
    imei1: number
    imei2: number
    bluetooth: number
    gps: number
    wifi: number
    proximity: number
    multiTouch: number
    screenCalibration: number
    speaker: number
    earReceiver: number
    microphone: number
    frontCamera: number
    backCamera: number
    sim: number
    fingerprint: number
    chargingPort: number
    audioJack: number
    isAccepted: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DeclarationMinAggregateInputType = {
    id?: true
    orderId?: true
    brand?: true
    model?: true
    smc?: true
    variant?: true
    imei1?: true
    imei2?: true
    bluetooth?: true
    gps?: true
    wifi?: true
    proximity?: true
    multiTouch?: true
    screenCalibration?: true
    speaker?: true
    earReceiver?: true
    microphone?: true
    frontCamera?: true
    backCamera?: true
    sim?: true
    fingerprint?: true
    chargingPort?: true
    audioJack?: true
    isAccepted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DeclarationMaxAggregateInputType = {
    id?: true
    orderId?: true
    brand?: true
    model?: true
    smc?: true
    variant?: true
    imei1?: true
    imei2?: true
    bluetooth?: true
    gps?: true
    wifi?: true
    proximity?: true
    multiTouch?: true
    screenCalibration?: true
    speaker?: true
    earReceiver?: true
    microphone?: true
    frontCamera?: true
    backCamera?: true
    sim?: true
    fingerprint?: true
    chargingPort?: true
    audioJack?: true
    isAccepted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DeclarationCountAggregateInputType = {
    id?: true
    orderId?: true
    brand?: true
    model?: true
    smc?: true
    variant?: true
    imei1?: true
    imei2?: true
    bluetooth?: true
    gps?: true
    wifi?: true
    proximity?: true
    multiTouch?: true
    screenCalibration?: true
    speaker?: true
    earReceiver?: true
    microphone?: true
    frontCamera?: true
    backCamera?: true
    sim?: true
    fingerprint?: true
    chargingPort?: true
    audioJack?: true
    isAccepted?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DeclarationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Declaration to aggregate.
     */
    where?: DeclarationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Declarations to fetch.
     */
    orderBy?: DeclarationOrderByWithRelationInput | DeclarationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeclarationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Declarations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Declarations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Declarations
    **/
    _count?: true | DeclarationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeclarationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeclarationMaxAggregateInputType
  }

  export type GetDeclarationAggregateType<T extends DeclarationAggregateArgs> = {
        [P in keyof T & keyof AggregateDeclaration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeclaration[P]>
      : GetScalarType<T[P], AggregateDeclaration[P]>
  }




  export type DeclarationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeclarationWhereInput
    orderBy?: DeclarationOrderByWithAggregationInput | DeclarationOrderByWithAggregationInput[]
    by: DeclarationScalarFieldEnum[] | DeclarationScalarFieldEnum
    having?: DeclarationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeclarationCountAggregateInputType | true
    _min?: DeclarationMinAggregateInputType
    _max?: DeclarationMaxAggregateInputType
  }

  export type DeclarationGroupByOutputType = {
    id: string
    orderId: string
    brand: string
    model: string
    smc: string
    variant: string
    imei1: string | null
    imei2: string | null
    bluetooth: string | null
    gps: string | null
    wifi: string | null
    proximity: string | null
    multiTouch: string | null
    screenCalibration: string | null
    speaker: string | null
    earReceiver: string | null
    microphone: string | null
    frontCamera: string | null
    backCamera: string | null
    sim: string | null
    fingerprint: string | null
    chargingPort: string | null
    audioJack: string | null
    isAccepted: boolean
    createdAt: Date
    updatedAt: Date
    _count: DeclarationCountAggregateOutputType | null
    _min: DeclarationMinAggregateOutputType | null
    _max: DeclarationMaxAggregateOutputType | null
  }

  type GetDeclarationGroupByPayload<T extends DeclarationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeclarationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeclarationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeclarationGroupByOutputType[P]>
            : GetScalarType<T[P], DeclarationGroupByOutputType[P]>
        }
      >
    >


  export type DeclarationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    brand?: boolean
    model?: boolean
    smc?: boolean
    variant?: boolean
    imei1?: boolean
    imei2?: boolean
    bluetooth?: boolean
    gps?: boolean
    wifi?: boolean
    proximity?: boolean
    multiTouch?: boolean
    screenCalibration?: boolean
    speaker?: boolean
    earReceiver?: boolean
    microphone?: boolean
    frontCamera?: boolean
    backCamera?: boolean
    sim?: boolean
    fingerprint?: boolean
    chargingPort?: boolean
    audioJack?: boolean
    isAccepted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["declaration"]>

  export type DeclarationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    brand?: boolean
    model?: boolean
    smc?: boolean
    variant?: boolean
    imei1?: boolean
    imei2?: boolean
    bluetooth?: boolean
    gps?: boolean
    wifi?: boolean
    proximity?: boolean
    multiTouch?: boolean
    screenCalibration?: boolean
    speaker?: boolean
    earReceiver?: boolean
    microphone?: boolean
    frontCamera?: boolean
    backCamera?: boolean
    sim?: boolean
    fingerprint?: boolean
    chargingPort?: boolean
    audioJack?: boolean
    isAccepted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["declaration"]>

  export type DeclarationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    brand?: boolean
    model?: boolean
    smc?: boolean
    variant?: boolean
    imei1?: boolean
    imei2?: boolean
    bluetooth?: boolean
    gps?: boolean
    wifi?: boolean
    proximity?: boolean
    multiTouch?: boolean
    screenCalibration?: boolean
    speaker?: boolean
    earReceiver?: boolean
    microphone?: boolean
    frontCamera?: boolean
    backCamera?: boolean
    sim?: boolean
    fingerprint?: boolean
    chargingPort?: boolean
    audioJack?: boolean
    isAccepted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["declaration"]>

  export type DeclarationSelectScalar = {
    id?: boolean
    orderId?: boolean
    brand?: boolean
    model?: boolean
    smc?: boolean
    variant?: boolean
    imei1?: boolean
    imei2?: boolean
    bluetooth?: boolean
    gps?: boolean
    wifi?: boolean
    proximity?: boolean
    multiTouch?: boolean
    screenCalibration?: boolean
    speaker?: boolean
    earReceiver?: boolean
    microphone?: boolean
    frontCamera?: boolean
    backCamera?: boolean
    sim?: boolean
    fingerprint?: boolean
    chargingPort?: boolean
    audioJack?: boolean
    isAccepted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DeclarationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "brand" | "model" | "smc" | "variant" | "imei1" | "imei2" | "bluetooth" | "gps" | "wifi" | "proximity" | "multiTouch" | "screenCalibration" | "speaker" | "earReceiver" | "microphone" | "frontCamera" | "backCamera" | "sim" | "fingerprint" | "chargingPort" | "audioJack" | "isAccepted" | "createdAt" | "updatedAt", ExtArgs["result"]["declaration"]>

  export type $DeclarationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Declaration"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderId: string
      brand: string
      model: string
      smc: string
      variant: string
      imei1: string | null
      imei2: string | null
      bluetooth: string | null
      gps: string | null
      wifi: string | null
      proximity: string | null
      multiTouch: string | null
      screenCalibration: string | null
      speaker: string | null
      earReceiver: string | null
      microphone: string | null
      frontCamera: string | null
      backCamera: string | null
      sim: string | null
      fingerprint: string | null
      chargingPort: string | null
      audioJack: string | null
      isAccepted: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["declaration"]>
    composites: {}
  }

  type DeclarationGetPayload<S extends boolean | null | undefined | DeclarationDefaultArgs> = $Result.GetResult<Prisma.$DeclarationPayload, S>

  type DeclarationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeclarationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeclarationCountAggregateInputType | true
    }

  export interface DeclarationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Declaration'], meta: { name: 'Declaration' } }
    /**
     * Find zero or one Declaration that matches the filter.
     * @param {DeclarationFindUniqueArgs} args - Arguments to find a Declaration
     * @example
     * // Get one Declaration
     * const declaration = await prisma.declaration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeclarationFindUniqueArgs>(args: SelectSubset<T, DeclarationFindUniqueArgs<ExtArgs>>): Prisma__DeclarationClient<$Result.GetResult<Prisma.$DeclarationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Declaration that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeclarationFindUniqueOrThrowArgs} args - Arguments to find a Declaration
     * @example
     * // Get one Declaration
     * const declaration = await prisma.declaration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeclarationFindUniqueOrThrowArgs>(args: SelectSubset<T, DeclarationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeclarationClient<$Result.GetResult<Prisma.$DeclarationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Declaration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeclarationFindFirstArgs} args - Arguments to find a Declaration
     * @example
     * // Get one Declaration
     * const declaration = await prisma.declaration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeclarationFindFirstArgs>(args?: SelectSubset<T, DeclarationFindFirstArgs<ExtArgs>>): Prisma__DeclarationClient<$Result.GetResult<Prisma.$DeclarationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Declaration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeclarationFindFirstOrThrowArgs} args - Arguments to find a Declaration
     * @example
     * // Get one Declaration
     * const declaration = await prisma.declaration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeclarationFindFirstOrThrowArgs>(args?: SelectSubset<T, DeclarationFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeclarationClient<$Result.GetResult<Prisma.$DeclarationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Declarations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeclarationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Declarations
     * const declarations = await prisma.declaration.findMany()
     * 
     * // Get first 10 Declarations
     * const declarations = await prisma.declaration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const declarationWithIdOnly = await prisma.declaration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeclarationFindManyArgs>(args?: SelectSubset<T, DeclarationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeclarationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Declaration.
     * @param {DeclarationCreateArgs} args - Arguments to create a Declaration.
     * @example
     * // Create one Declaration
     * const Declaration = await prisma.declaration.create({
     *   data: {
     *     // ... data to create a Declaration
     *   }
     * })
     * 
     */
    create<T extends DeclarationCreateArgs>(args: SelectSubset<T, DeclarationCreateArgs<ExtArgs>>): Prisma__DeclarationClient<$Result.GetResult<Prisma.$DeclarationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Declarations.
     * @param {DeclarationCreateManyArgs} args - Arguments to create many Declarations.
     * @example
     * // Create many Declarations
     * const declaration = await prisma.declaration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeclarationCreateManyArgs>(args?: SelectSubset<T, DeclarationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Declarations and returns the data saved in the database.
     * @param {DeclarationCreateManyAndReturnArgs} args - Arguments to create many Declarations.
     * @example
     * // Create many Declarations
     * const declaration = await prisma.declaration.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Declarations and only return the `id`
     * const declarationWithIdOnly = await prisma.declaration.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeclarationCreateManyAndReturnArgs>(args?: SelectSubset<T, DeclarationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeclarationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Declaration.
     * @param {DeclarationDeleteArgs} args - Arguments to delete one Declaration.
     * @example
     * // Delete one Declaration
     * const Declaration = await prisma.declaration.delete({
     *   where: {
     *     // ... filter to delete one Declaration
     *   }
     * })
     * 
     */
    delete<T extends DeclarationDeleteArgs>(args: SelectSubset<T, DeclarationDeleteArgs<ExtArgs>>): Prisma__DeclarationClient<$Result.GetResult<Prisma.$DeclarationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Declaration.
     * @param {DeclarationUpdateArgs} args - Arguments to update one Declaration.
     * @example
     * // Update one Declaration
     * const declaration = await prisma.declaration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeclarationUpdateArgs>(args: SelectSubset<T, DeclarationUpdateArgs<ExtArgs>>): Prisma__DeclarationClient<$Result.GetResult<Prisma.$DeclarationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Declarations.
     * @param {DeclarationDeleteManyArgs} args - Arguments to filter Declarations to delete.
     * @example
     * // Delete a few Declarations
     * const { count } = await prisma.declaration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeclarationDeleteManyArgs>(args?: SelectSubset<T, DeclarationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Declarations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeclarationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Declarations
     * const declaration = await prisma.declaration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeclarationUpdateManyArgs>(args: SelectSubset<T, DeclarationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Declarations and returns the data updated in the database.
     * @param {DeclarationUpdateManyAndReturnArgs} args - Arguments to update many Declarations.
     * @example
     * // Update many Declarations
     * const declaration = await prisma.declaration.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Declarations and only return the `id`
     * const declarationWithIdOnly = await prisma.declaration.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DeclarationUpdateManyAndReturnArgs>(args: SelectSubset<T, DeclarationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeclarationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Declaration.
     * @param {DeclarationUpsertArgs} args - Arguments to update or create a Declaration.
     * @example
     * // Update or create a Declaration
     * const declaration = await prisma.declaration.upsert({
     *   create: {
     *     // ... data to create a Declaration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Declaration we want to update
     *   }
     * })
     */
    upsert<T extends DeclarationUpsertArgs>(args: SelectSubset<T, DeclarationUpsertArgs<ExtArgs>>): Prisma__DeclarationClient<$Result.GetResult<Prisma.$DeclarationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Declarations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeclarationCountArgs} args - Arguments to filter Declarations to count.
     * @example
     * // Count the number of Declarations
     * const count = await prisma.declaration.count({
     *   where: {
     *     // ... the filter for the Declarations we want to count
     *   }
     * })
    **/
    count<T extends DeclarationCountArgs>(
      args?: Subset<T, DeclarationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeclarationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Declaration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeclarationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeclarationAggregateArgs>(args: Subset<T, DeclarationAggregateArgs>): Prisma.PrismaPromise<GetDeclarationAggregateType<T>>

    /**
     * Group by Declaration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeclarationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeclarationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeclarationGroupByArgs['orderBy'] }
        : { orderBy?: DeclarationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeclarationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeclarationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Declaration model
   */
  readonly fields: DeclarationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Declaration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeclarationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Declaration model
   */
  interface DeclarationFieldRefs {
    readonly id: FieldRef<"Declaration", 'String'>
    readonly orderId: FieldRef<"Declaration", 'String'>
    readonly brand: FieldRef<"Declaration", 'String'>
    readonly model: FieldRef<"Declaration", 'String'>
    readonly smc: FieldRef<"Declaration", 'String'>
    readonly variant: FieldRef<"Declaration", 'String'>
    readonly imei1: FieldRef<"Declaration", 'String'>
    readonly imei2: FieldRef<"Declaration", 'String'>
    readonly bluetooth: FieldRef<"Declaration", 'String'>
    readonly gps: FieldRef<"Declaration", 'String'>
    readonly wifi: FieldRef<"Declaration", 'String'>
    readonly proximity: FieldRef<"Declaration", 'String'>
    readonly multiTouch: FieldRef<"Declaration", 'String'>
    readonly screenCalibration: FieldRef<"Declaration", 'String'>
    readonly speaker: FieldRef<"Declaration", 'String'>
    readonly earReceiver: FieldRef<"Declaration", 'String'>
    readonly microphone: FieldRef<"Declaration", 'String'>
    readonly frontCamera: FieldRef<"Declaration", 'String'>
    readonly backCamera: FieldRef<"Declaration", 'String'>
    readonly sim: FieldRef<"Declaration", 'String'>
    readonly fingerprint: FieldRef<"Declaration", 'String'>
    readonly chargingPort: FieldRef<"Declaration", 'String'>
    readonly audioJack: FieldRef<"Declaration", 'String'>
    readonly isAccepted: FieldRef<"Declaration", 'Boolean'>
    readonly createdAt: FieldRef<"Declaration", 'DateTime'>
    readonly updatedAt: FieldRef<"Declaration", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Declaration findUnique
   */
  export type DeclarationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Declaration
     */
    select?: DeclarationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Declaration
     */
    omit?: DeclarationOmit<ExtArgs> | null
    /**
     * Filter, which Declaration to fetch.
     */
    where: DeclarationWhereUniqueInput
  }

  /**
   * Declaration findUniqueOrThrow
   */
  export type DeclarationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Declaration
     */
    select?: DeclarationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Declaration
     */
    omit?: DeclarationOmit<ExtArgs> | null
    /**
     * Filter, which Declaration to fetch.
     */
    where: DeclarationWhereUniqueInput
  }

  /**
   * Declaration findFirst
   */
  export type DeclarationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Declaration
     */
    select?: DeclarationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Declaration
     */
    omit?: DeclarationOmit<ExtArgs> | null
    /**
     * Filter, which Declaration to fetch.
     */
    where?: DeclarationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Declarations to fetch.
     */
    orderBy?: DeclarationOrderByWithRelationInput | DeclarationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Declarations.
     */
    cursor?: DeclarationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Declarations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Declarations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Declarations.
     */
    distinct?: DeclarationScalarFieldEnum | DeclarationScalarFieldEnum[]
  }

  /**
   * Declaration findFirstOrThrow
   */
  export type DeclarationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Declaration
     */
    select?: DeclarationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Declaration
     */
    omit?: DeclarationOmit<ExtArgs> | null
    /**
     * Filter, which Declaration to fetch.
     */
    where?: DeclarationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Declarations to fetch.
     */
    orderBy?: DeclarationOrderByWithRelationInput | DeclarationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Declarations.
     */
    cursor?: DeclarationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Declarations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Declarations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Declarations.
     */
    distinct?: DeclarationScalarFieldEnum | DeclarationScalarFieldEnum[]
  }

  /**
   * Declaration findMany
   */
  export type DeclarationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Declaration
     */
    select?: DeclarationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Declaration
     */
    omit?: DeclarationOmit<ExtArgs> | null
    /**
     * Filter, which Declarations to fetch.
     */
    where?: DeclarationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Declarations to fetch.
     */
    orderBy?: DeclarationOrderByWithRelationInput | DeclarationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Declarations.
     */
    cursor?: DeclarationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Declarations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Declarations.
     */
    skip?: number
    distinct?: DeclarationScalarFieldEnum | DeclarationScalarFieldEnum[]
  }

  /**
   * Declaration create
   */
  export type DeclarationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Declaration
     */
    select?: DeclarationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Declaration
     */
    omit?: DeclarationOmit<ExtArgs> | null
    /**
     * The data needed to create a Declaration.
     */
    data: XOR<DeclarationCreateInput, DeclarationUncheckedCreateInput>
  }

  /**
   * Declaration createMany
   */
  export type DeclarationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Declarations.
     */
    data: DeclarationCreateManyInput | DeclarationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Declaration createManyAndReturn
   */
  export type DeclarationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Declaration
     */
    select?: DeclarationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Declaration
     */
    omit?: DeclarationOmit<ExtArgs> | null
    /**
     * The data used to create many Declarations.
     */
    data: DeclarationCreateManyInput | DeclarationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Declaration update
   */
  export type DeclarationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Declaration
     */
    select?: DeclarationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Declaration
     */
    omit?: DeclarationOmit<ExtArgs> | null
    /**
     * The data needed to update a Declaration.
     */
    data: XOR<DeclarationUpdateInput, DeclarationUncheckedUpdateInput>
    /**
     * Choose, which Declaration to update.
     */
    where: DeclarationWhereUniqueInput
  }

  /**
   * Declaration updateMany
   */
  export type DeclarationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Declarations.
     */
    data: XOR<DeclarationUpdateManyMutationInput, DeclarationUncheckedUpdateManyInput>
    /**
     * Filter which Declarations to update
     */
    where?: DeclarationWhereInput
    /**
     * Limit how many Declarations to update.
     */
    limit?: number
  }

  /**
   * Declaration updateManyAndReturn
   */
  export type DeclarationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Declaration
     */
    select?: DeclarationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Declaration
     */
    omit?: DeclarationOmit<ExtArgs> | null
    /**
     * The data used to update Declarations.
     */
    data: XOR<DeclarationUpdateManyMutationInput, DeclarationUncheckedUpdateManyInput>
    /**
     * Filter which Declarations to update
     */
    where?: DeclarationWhereInput
    /**
     * Limit how many Declarations to update.
     */
    limit?: number
  }

  /**
   * Declaration upsert
   */
  export type DeclarationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Declaration
     */
    select?: DeclarationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Declaration
     */
    omit?: DeclarationOmit<ExtArgs> | null
    /**
     * The filter to search for the Declaration to update in case it exists.
     */
    where: DeclarationWhereUniqueInput
    /**
     * In case the Declaration found by the `where` argument doesn't exist, create a new Declaration with this data.
     */
    create: XOR<DeclarationCreateInput, DeclarationUncheckedCreateInput>
    /**
     * In case the Declaration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeclarationUpdateInput, DeclarationUncheckedUpdateInput>
  }

  /**
   * Declaration delete
   */
  export type DeclarationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Declaration
     */
    select?: DeclarationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Declaration
     */
    omit?: DeclarationOmit<ExtArgs> | null
    /**
     * Filter which Declaration to delete.
     */
    where: DeclarationWhereUniqueInput
  }

  /**
   * Declaration deleteMany
   */
  export type DeclarationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Declarations to delete
     */
    where?: DeclarationWhereInput
    /**
     * Limit how many Declarations to delete.
     */
    limit?: number
  }

  /**
   * Declaration without action
   */
  export type DeclarationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Declaration
     */
    select?: DeclarationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Declaration
     */
    omit?: DeclarationOmit<ExtArgs> | null
  }


  /**
   * Model Address
   */

  export type AggregateAddress = {
    _count: AddressCountAggregateOutputType | null
    _min: AddressMinAggregateOutputType | null
    _max: AddressMaxAggregateOutputType | null
  }

  export type AddressMinAggregateOutputType = {
    id: string | null
    streetAddress: string | null
    city: string | null
    state: string | null
    country: string | null
    pinCode: string | null
    storeId: string | null
  }

  export type AddressMaxAggregateOutputType = {
    id: string | null
    streetAddress: string | null
    city: string | null
    state: string | null
    country: string | null
    pinCode: string | null
    storeId: string | null
  }

  export type AddressCountAggregateOutputType = {
    id: number
    streetAddress: number
    city: number
    state: number
    country: number
    pinCode: number
    storeId: number
    _all: number
  }


  export type AddressMinAggregateInputType = {
    id?: true
    streetAddress?: true
    city?: true
    state?: true
    country?: true
    pinCode?: true
    storeId?: true
  }

  export type AddressMaxAggregateInputType = {
    id?: true
    streetAddress?: true
    city?: true
    state?: true
    country?: true
    pinCode?: true
    storeId?: true
  }

  export type AddressCountAggregateInputType = {
    id?: true
    streetAddress?: true
    city?: true
    state?: true
    country?: true
    pinCode?: true
    storeId?: true
    _all?: true
  }

  export type AddressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Address to aggregate.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Addresses
    **/
    _count?: true | AddressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AddressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AddressMaxAggregateInputType
  }

  export type GetAddressAggregateType<T extends AddressAggregateArgs> = {
        [P in keyof T & keyof AggregateAddress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAddress[P]>
      : GetScalarType<T[P], AggregateAddress[P]>
  }




  export type AddressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddressWhereInput
    orderBy?: AddressOrderByWithAggregationInput | AddressOrderByWithAggregationInput[]
    by: AddressScalarFieldEnum[] | AddressScalarFieldEnum
    having?: AddressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AddressCountAggregateInputType | true
    _min?: AddressMinAggregateInputType
    _max?: AddressMaxAggregateInputType
  }

  export type AddressGroupByOutputType = {
    id: string
    streetAddress: string
    city: string
    state: string
    country: string
    pinCode: string
    storeId: string
    _count: AddressCountAggregateOutputType | null
    _min: AddressMinAggregateOutputType | null
    _max: AddressMaxAggregateOutputType | null
  }

  type GetAddressGroupByPayload<T extends AddressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AddressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AddressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AddressGroupByOutputType[P]>
            : GetScalarType<T[P], AddressGroupByOutputType[P]>
        }
      >
    >


  export type AddressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    streetAddress?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    pinCode?: boolean
    storeId?: boolean
    store?: boolean | StoreDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["address"]>

  export type AddressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    streetAddress?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    pinCode?: boolean
    storeId?: boolean
    store?: boolean | StoreDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["address"]>

  export type AddressSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    streetAddress?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    pinCode?: boolean
    storeId?: boolean
    store?: boolean | StoreDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["address"]>

  export type AddressSelectScalar = {
    id?: boolean
    streetAddress?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    pinCode?: boolean
    storeId?: boolean
  }

  export type AddressOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "streetAddress" | "city" | "state" | "country" | "pinCode" | "storeId", ExtArgs["result"]["address"]>
  export type AddressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | StoreDefaultArgs<ExtArgs>
  }
  export type AddressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | StoreDefaultArgs<ExtArgs>
  }
  export type AddressIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | StoreDefaultArgs<ExtArgs>
  }

  export type $AddressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Address"
    objects: {
      store: Prisma.$StorePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      streetAddress: string
      city: string
      state: string
      country: string
      pinCode: string
      storeId: string
    }, ExtArgs["result"]["address"]>
    composites: {}
  }

  type AddressGetPayload<S extends boolean | null | undefined | AddressDefaultArgs> = $Result.GetResult<Prisma.$AddressPayload, S>

  type AddressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AddressFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AddressCountAggregateInputType | true
    }

  export interface AddressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Address'], meta: { name: 'Address' } }
    /**
     * Find zero or one Address that matches the filter.
     * @param {AddressFindUniqueArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AddressFindUniqueArgs>(args: SelectSubset<T, AddressFindUniqueArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Address that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AddressFindUniqueOrThrowArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AddressFindUniqueOrThrowArgs>(args: SelectSubset<T, AddressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Address that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindFirstArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AddressFindFirstArgs>(args?: SelectSubset<T, AddressFindFirstArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Address that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindFirstOrThrowArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AddressFindFirstOrThrowArgs>(args?: SelectSubset<T, AddressFindFirstOrThrowArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Addresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Addresses
     * const addresses = await prisma.address.findMany()
     * 
     * // Get first 10 Addresses
     * const addresses = await prisma.address.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const addressWithIdOnly = await prisma.address.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AddressFindManyArgs>(args?: SelectSubset<T, AddressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Address.
     * @param {AddressCreateArgs} args - Arguments to create a Address.
     * @example
     * // Create one Address
     * const Address = await prisma.address.create({
     *   data: {
     *     // ... data to create a Address
     *   }
     * })
     * 
     */
    create<T extends AddressCreateArgs>(args: SelectSubset<T, AddressCreateArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Addresses.
     * @param {AddressCreateManyArgs} args - Arguments to create many Addresses.
     * @example
     * // Create many Addresses
     * const address = await prisma.address.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AddressCreateManyArgs>(args?: SelectSubset<T, AddressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Addresses and returns the data saved in the database.
     * @param {AddressCreateManyAndReturnArgs} args - Arguments to create many Addresses.
     * @example
     * // Create many Addresses
     * const address = await prisma.address.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Addresses and only return the `id`
     * const addressWithIdOnly = await prisma.address.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AddressCreateManyAndReturnArgs>(args?: SelectSubset<T, AddressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Address.
     * @param {AddressDeleteArgs} args - Arguments to delete one Address.
     * @example
     * // Delete one Address
     * const Address = await prisma.address.delete({
     *   where: {
     *     // ... filter to delete one Address
     *   }
     * })
     * 
     */
    delete<T extends AddressDeleteArgs>(args: SelectSubset<T, AddressDeleteArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Address.
     * @param {AddressUpdateArgs} args - Arguments to update one Address.
     * @example
     * // Update one Address
     * const address = await prisma.address.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AddressUpdateArgs>(args: SelectSubset<T, AddressUpdateArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Addresses.
     * @param {AddressDeleteManyArgs} args - Arguments to filter Addresses to delete.
     * @example
     * // Delete a few Addresses
     * const { count } = await prisma.address.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AddressDeleteManyArgs>(args?: SelectSubset<T, AddressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Addresses
     * const address = await prisma.address.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AddressUpdateManyArgs>(args: SelectSubset<T, AddressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Addresses and returns the data updated in the database.
     * @param {AddressUpdateManyAndReturnArgs} args - Arguments to update many Addresses.
     * @example
     * // Update many Addresses
     * const address = await prisma.address.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Addresses and only return the `id`
     * const addressWithIdOnly = await prisma.address.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AddressUpdateManyAndReturnArgs>(args: SelectSubset<T, AddressUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Address.
     * @param {AddressUpsertArgs} args - Arguments to update or create a Address.
     * @example
     * // Update or create a Address
     * const address = await prisma.address.upsert({
     *   create: {
     *     // ... data to create a Address
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Address we want to update
     *   }
     * })
     */
    upsert<T extends AddressUpsertArgs>(args: SelectSubset<T, AddressUpsertArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressCountArgs} args - Arguments to filter Addresses to count.
     * @example
     * // Count the number of Addresses
     * const count = await prisma.address.count({
     *   where: {
     *     // ... the filter for the Addresses we want to count
     *   }
     * })
    **/
    count<T extends AddressCountArgs>(
      args?: Subset<T, AddressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AddressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AddressAggregateArgs>(args: Subset<T, AddressAggregateArgs>): Prisma.PrismaPromise<GetAddressAggregateType<T>>

    /**
     * Group by Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AddressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AddressGroupByArgs['orderBy'] }
        : { orderBy?: AddressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AddressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAddressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Address model
   */
  readonly fields: AddressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Address.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AddressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    store<T extends StoreDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoreDefaultArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Address model
   */
  interface AddressFieldRefs {
    readonly id: FieldRef<"Address", 'String'>
    readonly streetAddress: FieldRef<"Address", 'String'>
    readonly city: FieldRef<"Address", 'String'>
    readonly state: FieldRef<"Address", 'String'>
    readonly country: FieldRef<"Address", 'String'>
    readonly pinCode: FieldRef<"Address", 'String'>
    readonly storeId: FieldRef<"Address", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Address findUnique
   */
  export type AddressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address findUniqueOrThrow
   */
  export type AddressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address findFirst
   */
  export type AddressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Addresses.
     */
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Address findFirstOrThrow
   */
  export type AddressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Addresses.
     */
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Address findMany
   */
  export type AddressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Addresses to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Address create
   */
  export type AddressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * The data needed to create a Address.
     */
    data: XOR<AddressCreateInput, AddressUncheckedCreateInput>
  }

  /**
   * Address createMany
   */
  export type AddressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Addresses.
     */
    data: AddressCreateManyInput | AddressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Address createManyAndReturn
   */
  export type AddressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * The data used to create many Addresses.
     */
    data: AddressCreateManyInput | AddressCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Address update
   */
  export type AddressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * The data needed to update a Address.
     */
    data: XOR<AddressUpdateInput, AddressUncheckedUpdateInput>
    /**
     * Choose, which Address to update.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address updateMany
   */
  export type AddressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Addresses.
     */
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyInput>
    /**
     * Filter which Addresses to update
     */
    where?: AddressWhereInput
    /**
     * Limit how many Addresses to update.
     */
    limit?: number
  }

  /**
   * Address updateManyAndReturn
   */
  export type AddressUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * The data used to update Addresses.
     */
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyInput>
    /**
     * Filter which Addresses to update
     */
    where?: AddressWhereInput
    /**
     * Limit how many Addresses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Address upsert
   */
  export type AddressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * The filter to search for the Address to update in case it exists.
     */
    where: AddressWhereUniqueInput
    /**
     * In case the Address found by the `where` argument doesn't exist, create a new Address with this data.
     */
    create: XOR<AddressCreateInput, AddressUncheckedCreateInput>
    /**
     * In case the Address was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AddressUpdateInput, AddressUncheckedUpdateInput>
  }

  /**
   * Address delete
   */
  export type AddressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter which Address to delete.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address deleteMany
   */
  export type AddressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Addresses to delete
     */
    where?: AddressWhereInput
    /**
     * Limit how many Addresses to delete.
     */
    limit?: number
  }

  /**
   * Address without action
   */
  export type AddressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
  }


  /**
   * Model Otp
   */

  export type AggregateOtp = {
    _count: OtpCountAggregateOutputType | null
    _avg: OtpAvgAggregateOutputType | null
    _sum: OtpSumAggregateOutputType | null
    _min: OtpMinAggregateOutputType | null
    _max: OtpMaxAggregateOutputType | null
  }

  export type OtpAvgAggregateOutputType = {
    attempts: number | null
  }

  export type OtpSumAggregateOutputType = {
    attempts: number | null
  }

  export type OtpMinAggregateOutputType = {
    id: string | null
    identifier: string | null
    otp: string | null
    expiresAt: Date | null
    used: boolean | null
    createdAt: Date | null
    attempts: number | null
  }

  export type OtpMaxAggregateOutputType = {
    id: string | null
    identifier: string | null
    otp: string | null
    expiresAt: Date | null
    used: boolean | null
    createdAt: Date | null
    attempts: number | null
  }

  export type OtpCountAggregateOutputType = {
    id: number
    identifier: number
    otp: number
    expiresAt: number
    used: number
    createdAt: number
    attempts: number
    _all: number
  }


  export type OtpAvgAggregateInputType = {
    attempts?: true
  }

  export type OtpSumAggregateInputType = {
    attempts?: true
  }

  export type OtpMinAggregateInputType = {
    id?: true
    identifier?: true
    otp?: true
    expiresAt?: true
    used?: true
    createdAt?: true
    attempts?: true
  }

  export type OtpMaxAggregateInputType = {
    id?: true
    identifier?: true
    otp?: true
    expiresAt?: true
    used?: true
    createdAt?: true
    attempts?: true
  }

  export type OtpCountAggregateInputType = {
    id?: true
    identifier?: true
    otp?: true
    expiresAt?: true
    used?: true
    createdAt?: true
    attempts?: true
    _all?: true
  }

  export type OtpAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Otp to aggregate.
     */
    where?: OtpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Otps to fetch.
     */
    orderBy?: OtpOrderByWithRelationInput | OtpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OtpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Otps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Otps
    **/
    _count?: true | OtpCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OtpAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OtpSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OtpMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OtpMaxAggregateInputType
  }

  export type GetOtpAggregateType<T extends OtpAggregateArgs> = {
        [P in keyof T & keyof AggregateOtp]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOtp[P]>
      : GetScalarType<T[P], AggregateOtp[P]>
  }




  export type OtpGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OtpWhereInput
    orderBy?: OtpOrderByWithAggregationInput | OtpOrderByWithAggregationInput[]
    by: OtpScalarFieldEnum[] | OtpScalarFieldEnum
    having?: OtpScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OtpCountAggregateInputType | true
    _avg?: OtpAvgAggregateInputType
    _sum?: OtpSumAggregateInputType
    _min?: OtpMinAggregateInputType
    _max?: OtpMaxAggregateInputType
  }

  export type OtpGroupByOutputType = {
    id: string
    identifier: string
    otp: string
    expiresAt: Date
    used: boolean
    createdAt: Date
    attempts: number
    _count: OtpCountAggregateOutputType | null
    _avg: OtpAvgAggregateOutputType | null
    _sum: OtpSumAggregateOutputType | null
    _min: OtpMinAggregateOutputType | null
    _max: OtpMaxAggregateOutputType | null
  }

  type GetOtpGroupByPayload<T extends OtpGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OtpGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OtpGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OtpGroupByOutputType[P]>
            : GetScalarType<T[P], OtpGroupByOutputType[P]>
        }
      >
    >


  export type OtpSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    otp?: boolean
    expiresAt?: boolean
    used?: boolean
    createdAt?: boolean
    attempts?: boolean
  }, ExtArgs["result"]["otp"]>

  export type OtpSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    otp?: boolean
    expiresAt?: boolean
    used?: boolean
    createdAt?: boolean
    attempts?: boolean
  }, ExtArgs["result"]["otp"]>

  export type OtpSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    otp?: boolean
    expiresAt?: boolean
    used?: boolean
    createdAt?: boolean
    attempts?: boolean
  }, ExtArgs["result"]["otp"]>

  export type OtpSelectScalar = {
    id?: boolean
    identifier?: boolean
    otp?: boolean
    expiresAt?: boolean
    used?: boolean
    createdAt?: boolean
    attempts?: boolean
  }

  export type OtpOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "identifier" | "otp" | "expiresAt" | "used" | "createdAt" | "attempts", ExtArgs["result"]["otp"]>

  export type $OtpPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Otp"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      identifier: string
      otp: string
      expiresAt: Date
      used: boolean
      createdAt: Date
      attempts: number
    }, ExtArgs["result"]["otp"]>
    composites: {}
  }

  type OtpGetPayload<S extends boolean | null | undefined | OtpDefaultArgs> = $Result.GetResult<Prisma.$OtpPayload, S>

  type OtpCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OtpFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OtpCountAggregateInputType | true
    }

  export interface OtpDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Otp'], meta: { name: 'Otp' } }
    /**
     * Find zero or one Otp that matches the filter.
     * @param {OtpFindUniqueArgs} args - Arguments to find a Otp
     * @example
     * // Get one Otp
     * const otp = await prisma.otp.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OtpFindUniqueArgs>(args: SelectSubset<T, OtpFindUniqueArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Otp that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OtpFindUniqueOrThrowArgs} args - Arguments to find a Otp
     * @example
     * // Get one Otp
     * const otp = await prisma.otp.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OtpFindUniqueOrThrowArgs>(args: SelectSubset<T, OtpFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Otp that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpFindFirstArgs} args - Arguments to find a Otp
     * @example
     * // Get one Otp
     * const otp = await prisma.otp.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OtpFindFirstArgs>(args?: SelectSubset<T, OtpFindFirstArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Otp that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpFindFirstOrThrowArgs} args - Arguments to find a Otp
     * @example
     * // Get one Otp
     * const otp = await prisma.otp.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OtpFindFirstOrThrowArgs>(args?: SelectSubset<T, OtpFindFirstOrThrowArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Otps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Otps
     * const otps = await prisma.otp.findMany()
     * 
     * // Get first 10 Otps
     * const otps = await prisma.otp.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const otpWithIdOnly = await prisma.otp.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OtpFindManyArgs>(args?: SelectSubset<T, OtpFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Otp.
     * @param {OtpCreateArgs} args - Arguments to create a Otp.
     * @example
     * // Create one Otp
     * const Otp = await prisma.otp.create({
     *   data: {
     *     // ... data to create a Otp
     *   }
     * })
     * 
     */
    create<T extends OtpCreateArgs>(args: SelectSubset<T, OtpCreateArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Otps.
     * @param {OtpCreateManyArgs} args - Arguments to create many Otps.
     * @example
     * // Create many Otps
     * const otp = await prisma.otp.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OtpCreateManyArgs>(args?: SelectSubset<T, OtpCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Otps and returns the data saved in the database.
     * @param {OtpCreateManyAndReturnArgs} args - Arguments to create many Otps.
     * @example
     * // Create many Otps
     * const otp = await prisma.otp.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Otps and only return the `id`
     * const otpWithIdOnly = await prisma.otp.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OtpCreateManyAndReturnArgs>(args?: SelectSubset<T, OtpCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Otp.
     * @param {OtpDeleteArgs} args - Arguments to delete one Otp.
     * @example
     * // Delete one Otp
     * const Otp = await prisma.otp.delete({
     *   where: {
     *     // ... filter to delete one Otp
     *   }
     * })
     * 
     */
    delete<T extends OtpDeleteArgs>(args: SelectSubset<T, OtpDeleteArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Otp.
     * @param {OtpUpdateArgs} args - Arguments to update one Otp.
     * @example
     * // Update one Otp
     * const otp = await prisma.otp.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OtpUpdateArgs>(args: SelectSubset<T, OtpUpdateArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Otps.
     * @param {OtpDeleteManyArgs} args - Arguments to filter Otps to delete.
     * @example
     * // Delete a few Otps
     * const { count } = await prisma.otp.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OtpDeleteManyArgs>(args?: SelectSubset<T, OtpDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Otps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Otps
     * const otp = await prisma.otp.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OtpUpdateManyArgs>(args: SelectSubset<T, OtpUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Otps and returns the data updated in the database.
     * @param {OtpUpdateManyAndReturnArgs} args - Arguments to update many Otps.
     * @example
     * // Update many Otps
     * const otp = await prisma.otp.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Otps and only return the `id`
     * const otpWithIdOnly = await prisma.otp.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OtpUpdateManyAndReturnArgs>(args: SelectSubset<T, OtpUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Otp.
     * @param {OtpUpsertArgs} args - Arguments to update or create a Otp.
     * @example
     * // Update or create a Otp
     * const otp = await prisma.otp.upsert({
     *   create: {
     *     // ... data to create a Otp
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Otp we want to update
     *   }
     * })
     */
    upsert<T extends OtpUpsertArgs>(args: SelectSubset<T, OtpUpsertArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Otps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpCountArgs} args - Arguments to filter Otps to count.
     * @example
     * // Count the number of Otps
     * const count = await prisma.otp.count({
     *   where: {
     *     // ... the filter for the Otps we want to count
     *   }
     * })
    **/
    count<T extends OtpCountArgs>(
      args?: Subset<T, OtpCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OtpCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Otp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OtpAggregateArgs>(args: Subset<T, OtpAggregateArgs>): Prisma.PrismaPromise<GetOtpAggregateType<T>>

    /**
     * Group by Otp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OtpGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OtpGroupByArgs['orderBy'] }
        : { orderBy?: OtpGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OtpGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOtpGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Otp model
   */
  readonly fields: OtpFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Otp.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OtpClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Otp model
   */
  interface OtpFieldRefs {
    readonly id: FieldRef<"Otp", 'String'>
    readonly identifier: FieldRef<"Otp", 'String'>
    readonly otp: FieldRef<"Otp", 'String'>
    readonly expiresAt: FieldRef<"Otp", 'DateTime'>
    readonly used: FieldRef<"Otp", 'Boolean'>
    readonly createdAt: FieldRef<"Otp", 'DateTime'>
    readonly attempts: FieldRef<"Otp", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Otp findUnique
   */
  export type OtpFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Filter, which Otp to fetch.
     */
    where: OtpWhereUniqueInput
  }

  /**
   * Otp findUniqueOrThrow
   */
  export type OtpFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Filter, which Otp to fetch.
     */
    where: OtpWhereUniqueInput
  }

  /**
   * Otp findFirst
   */
  export type OtpFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Filter, which Otp to fetch.
     */
    where?: OtpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Otps to fetch.
     */
    orderBy?: OtpOrderByWithRelationInput | OtpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Otps.
     */
    cursor?: OtpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Otps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Otps.
     */
    distinct?: OtpScalarFieldEnum | OtpScalarFieldEnum[]
  }

  /**
   * Otp findFirstOrThrow
   */
  export type OtpFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Filter, which Otp to fetch.
     */
    where?: OtpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Otps to fetch.
     */
    orderBy?: OtpOrderByWithRelationInput | OtpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Otps.
     */
    cursor?: OtpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Otps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Otps.
     */
    distinct?: OtpScalarFieldEnum | OtpScalarFieldEnum[]
  }

  /**
   * Otp findMany
   */
  export type OtpFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Filter, which Otps to fetch.
     */
    where?: OtpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Otps to fetch.
     */
    orderBy?: OtpOrderByWithRelationInput | OtpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Otps.
     */
    cursor?: OtpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Otps.
     */
    skip?: number
    distinct?: OtpScalarFieldEnum | OtpScalarFieldEnum[]
  }

  /**
   * Otp create
   */
  export type OtpCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * The data needed to create a Otp.
     */
    data: XOR<OtpCreateInput, OtpUncheckedCreateInput>
  }

  /**
   * Otp createMany
   */
  export type OtpCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Otps.
     */
    data: OtpCreateManyInput | OtpCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Otp createManyAndReturn
   */
  export type OtpCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * The data used to create many Otps.
     */
    data: OtpCreateManyInput | OtpCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Otp update
   */
  export type OtpUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * The data needed to update a Otp.
     */
    data: XOR<OtpUpdateInput, OtpUncheckedUpdateInput>
    /**
     * Choose, which Otp to update.
     */
    where: OtpWhereUniqueInput
  }

  /**
   * Otp updateMany
   */
  export type OtpUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Otps.
     */
    data: XOR<OtpUpdateManyMutationInput, OtpUncheckedUpdateManyInput>
    /**
     * Filter which Otps to update
     */
    where?: OtpWhereInput
    /**
     * Limit how many Otps to update.
     */
    limit?: number
  }

  /**
   * Otp updateManyAndReturn
   */
  export type OtpUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * The data used to update Otps.
     */
    data: XOR<OtpUpdateManyMutationInput, OtpUncheckedUpdateManyInput>
    /**
     * Filter which Otps to update
     */
    where?: OtpWhereInput
    /**
     * Limit how many Otps to update.
     */
    limit?: number
  }

  /**
   * Otp upsert
   */
  export type OtpUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * The filter to search for the Otp to update in case it exists.
     */
    where: OtpWhereUniqueInput
    /**
     * In case the Otp found by the `where` argument doesn't exist, create a new Otp with this data.
     */
    create: XOR<OtpCreateInput, OtpUncheckedCreateInput>
    /**
     * In case the Otp was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OtpUpdateInput, OtpUncheckedUpdateInput>
  }

  /**
   * Otp delete
   */
  export type OtpDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Filter which Otp to delete.
     */
    where: OtpWhereUniqueInput
  }

  /**
   * Otp deleteMany
   */
  export type OtpDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Otps to delete
     */
    where?: OtpWhereInput
    /**
     * Limit how many Otps to delete.
     */
    limit?: number
  }

  /**
   * Otp without action
   */
  export type OtpDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
  }


  /**
   * Model CustomModelBrand
   */

  export type AggregateCustomModelBrand = {
    _count: CustomModelBrandCountAggregateOutputType | null
    _min: CustomModelBrandMinAggregateOutputType | null
    _max: CustomModelBrandMaxAggregateOutputType | null
  }

  export type CustomModelBrandMinAggregateOutputType = {
    id: string | null
    name: string | null
    logo: string | null
    apiEndpoint: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomModelBrandMaxAggregateOutputType = {
    id: string | null
    name: string | null
    logo: string | null
    apiEndpoint: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomModelBrandCountAggregateOutputType = {
    id: number
    name: number
    logo: number
    apiEndpoint: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CustomModelBrandMinAggregateInputType = {
    id?: true
    name?: true
    logo?: true
    apiEndpoint?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomModelBrandMaxAggregateInputType = {
    id?: true
    name?: true
    logo?: true
    apiEndpoint?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomModelBrandCountAggregateInputType = {
    id?: true
    name?: true
    logo?: true
    apiEndpoint?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CustomModelBrandAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomModelBrand to aggregate.
     */
    where?: CustomModelBrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomModelBrands to fetch.
     */
    orderBy?: CustomModelBrandOrderByWithRelationInput | CustomModelBrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomModelBrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomModelBrands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomModelBrands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomModelBrands
    **/
    _count?: true | CustomModelBrandCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomModelBrandMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomModelBrandMaxAggregateInputType
  }

  export type GetCustomModelBrandAggregateType<T extends CustomModelBrandAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomModelBrand]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomModelBrand[P]>
      : GetScalarType<T[P], AggregateCustomModelBrand[P]>
  }




  export type CustomModelBrandGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomModelBrandWhereInput
    orderBy?: CustomModelBrandOrderByWithAggregationInput | CustomModelBrandOrderByWithAggregationInput[]
    by: CustomModelBrandScalarFieldEnum[] | CustomModelBrandScalarFieldEnum
    having?: CustomModelBrandScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomModelBrandCountAggregateInputType | true
    _min?: CustomModelBrandMinAggregateInputType
    _max?: CustomModelBrandMaxAggregateInputType
  }

  export type CustomModelBrandGroupByOutputType = {
    id: string
    name: string
    logo: string | null
    apiEndpoint: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: CustomModelBrandCountAggregateOutputType | null
    _min: CustomModelBrandMinAggregateOutputType | null
    _max: CustomModelBrandMaxAggregateOutputType | null
  }

  type GetCustomModelBrandGroupByPayload<T extends CustomModelBrandGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomModelBrandGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomModelBrandGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomModelBrandGroupByOutputType[P]>
            : GetScalarType<T[P], CustomModelBrandGroupByOutputType[P]>
        }
      >
    >


  export type CustomModelBrandSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    logo?: boolean
    apiEndpoint?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    models?: boolean | CustomModelBrand$modelsArgs<ExtArgs>
    _count?: boolean | CustomModelBrandCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customModelBrand"]>

  export type CustomModelBrandSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    logo?: boolean
    apiEndpoint?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["customModelBrand"]>

  export type CustomModelBrandSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    logo?: boolean
    apiEndpoint?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["customModelBrand"]>

  export type CustomModelBrandSelectScalar = {
    id?: boolean
    name?: boolean
    logo?: boolean
    apiEndpoint?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CustomModelBrandOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "logo" | "apiEndpoint" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["customModelBrand"]>
  export type CustomModelBrandInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    models?: boolean | CustomModelBrand$modelsArgs<ExtArgs>
    _count?: boolean | CustomModelBrandCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CustomModelBrandIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CustomModelBrandIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CustomModelBrandPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomModelBrand"
    objects: {
      models: Prisma.$CustomModelPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      logo: string | null
      apiEndpoint: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["customModelBrand"]>
    composites: {}
  }

  type CustomModelBrandGetPayload<S extends boolean | null | undefined | CustomModelBrandDefaultArgs> = $Result.GetResult<Prisma.$CustomModelBrandPayload, S>

  type CustomModelBrandCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomModelBrandFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomModelBrandCountAggregateInputType | true
    }

  export interface CustomModelBrandDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomModelBrand'], meta: { name: 'CustomModelBrand' } }
    /**
     * Find zero or one CustomModelBrand that matches the filter.
     * @param {CustomModelBrandFindUniqueArgs} args - Arguments to find a CustomModelBrand
     * @example
     * // Get one CustomModelBrand
     * const customModelBrand = await prisma.customModelBrand.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomModelBrandFindUniqueArgs>(args: SelectSubset<T, CustomModelBrandFindUniqueArgs<ExtArgs>>): Prisma__CustomModelBrandClient<$Result.GetResult<Prisma.$CustomModelBrandPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CustomModelBrand that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomModelBrandFindUniqueOrThrowArgs} args - Arguments to find a CustomModelBrand
     * @example
     * // Get one CustomModelBrand
     * const customModelBrand = await prisma.customModelBrand.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomModelBrandFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomModelBrandFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomModelBrandClient<$Result.GetResult<Prisma.$CustomModelBrandPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomModelBrand that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomModelBrandFindFirstArgs} args - Arguments to find a CustomModelBrand
     * @example
     * // Get one CustomModelBrand
     * const customModelBrand = await prisma.customModelBrand.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomModelBrandFindFirstArgs>(args?: SelectSubset<T, CustomModelBrandFindFirstArgs<ExtArgs>>): Prisma__CustomModelBrandClient<$Result.GetResult<Prisma.$CustomModelBrandPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomModelBrand that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomModelBrandFindFirstOrThrowArgs} args - Arguments to find a CustomModelBrand
     * @example
     * // Get one CustomModelBrand
     * const customModelBrand = await prisma.customModelBrand.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomModelBrandFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomModelBrandFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomModelBrandClient<$Result.GetResult<Prisma.$CustomModelBrandPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CustomModelBrands that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomModelBrandFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomModelBrands
     * const customModelBrands = await prisma.customModelBrand.findMany()
     * 
     * // Get first 10 CustomModelBrands
     * const customModelBrands = await prisma.customModelBrand.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customModelBrandWithIdOnly = await prisma.customModelBrand.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomModelBrandFindManyArgs>(args?: SelectSubset<T, CustomModelBrandFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomModelBrandPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CustomModelBrand.
     * @param {CustomModelBrandCreateArgs} args - Arguments to create a CustomModelBrand.
     * @example
     * // Create one CustomModelBrand
     * const CustomModelBrand = await prisma.customModelBrand.create({
     *   data: {
     *     // ... data to create a CustomModelBrand
     *   }
     * })
     * 
     */
    create<T extends CustomModelBrandCreateArgs>(args: SelectSubset<T, CustomModelBrandCreateArgs<ExtArgs>>): Prisma__CustomModelBrandClient<$Result.GetResult<Prisma.$CustomModelBrandPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CustomModelBrands.
     * @param {CustomModelBrandCreateManyArgs} args - Arguments to create many CustomModelBrands.
     * @example
     * // Create many CustomModelBrands
     * const customModelBrand = await prisma.customModelBrand.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomModelBrandCreateManyArgs>(args?: SelectSubset<T, CustomModelBrandCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CustomModelBrands and returns the data saved in the database.
     * @param {CustomModelBrandCreateManyAndReturnArgs} args - Arguments to create many CustomModelBrands.
     * @example
     * // Create many CustomModelBrands
     * const customModelBrand = await prisma.customModelBrand.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CustomModelBrands and only return the `id`
     * const customModelBrandWithIdOnly = await prisma.customModelBrand.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomModelBrandCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomModelBrandCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomModelBrandPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CustomModelBrand.
     * @param {CustomModelBrandDeleteArgs} args - Arguments to delete one CustomModelBrand.
     * @example
     * // Delete one CustomModelBrand
     * const CustomModelBrand = await prisma.customModelBrand.delete({
     *   where: {
     *     // ... filter to delete one CustomModelBrand
     *   }
     * })
     * 
     */
    delete<T extends CustomModelBrandDeleteArgs>(args: SelectSubset<T, CustomModelBrandDeleteArgs<ExtArgs>>): Prisma__CustomModelBrandClient<$Result.GetResult<Prisma.$CustomModelBrandPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CustomModelBrand.
     * @param {CustomModelBrandUpdateArgs} args - Arguments to update one CustomModelBrand.
     * @example
     * // Update one CustomModelBrand
     * const customModelBrand = await prisma.customModelBrand.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomModelBrandUpdateArgs>(args: SelectSubset<T, CustomModelBrandUpdateArgs<ExtArgs>>): Prisma__CustomModelBrandClient<$Result.GetResult<Prisma.$CustomModelBrandPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CustomModelBrands.
     * @param {CustomModelBrandDeleteManyArgs} args - Arguments to filter CustomModelBrands to delete.
     * @example
     * // Delete a few CustomModelBrands
     * const { count } = await prisma.customModelBrand.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomModelBrandDeleteManyArgs>(args?: SelectSubset<T, CustomModelBrandDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomModelBrands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomModelBrandUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomModelBrands
     * const customModelBrand = await prisma.customModelBrand.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomModelBrandUpdateManyArgs>(args: SelectSubset<T, CustomModelBrandUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomModelBrands and returns the data updated in the database.
     * @param {CustomModelBrandUpdateManyAndReturnArgs} args - Arguments to update many CustomModelBrands.
     * @example
     * // Update many CustomModelBrands
     * const customModelBrand = await prisma.customModelBrand.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CustomModelBrands and only return the `id`
     * const customModelBrandWithIdOnly = await prisma.customModelBrand.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomModelBrandUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomModelBrandUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomModelBrandPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CustomModelBrand.
     * @param {CustomModelBrandUpsertArgs} args - Arguments to update or create a CustomModelBrand.
     * @example
     * // Update or create a CustomModelBrand
     * const customModelBrand = await prisma.customModelBrand.upsert({
     *   create: {
     *     // ... data to create a CustomModelBrand
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomModelBrand we want to update
     *   }
     * })
     */
    upsert<T extends CustomModelBrandUpsertArgs>(args: SelectSubset<T, CustomModelBrandUpsertArgs<ExtArgs>>): Prisma__CustomModelBrandClient<$Result.GetResult<Prisma.$CustomModelBrandPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CustomModelBrands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomModelBrandCountArgs} args - Arguments to filter CustomModelBrands to count.
     * @example
     * // Count the number of CustomModelBrands
     * const count = await prisma.customModelBrand.count({
     *   where: {
     *     // ... the filter for the CustomModelBrands we want to count
     *   }
     * })
    **/
    count<T extends CustomModelBrandCountArgs>(
      args?: Subset<T, CustomModelBrandCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomModelBrandCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomModelBrand.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomModelBrandAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomModelBrandAggregateArgs>(args: Subset<T, CustomModelBrandAggregateArgs>): Prisma.PrismaPromise<GetCustomModelBrandAggregateType<T>>

    /**
     * Group by CustomModelBrand.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomModelBrandGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomModelBrandGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomModelBrandGroupByArgs['orderBy'] }
        : { orderBy?: CustomModelBrandGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomModelBrandGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomModelBrandGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomModelBrand model
   */
  readonly fields: CustomModelBrandFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomModelBrand.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomModelBrandClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    models<T extends CustomModelBrand$modelsArgs<ExtArgs> = {}>(args?: Subset<T, CustomModelBrand$modelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomModelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CustomModelBrand model
   */
  interface CustomModelBrandFieldRefs {
    readonly id: FieldRef<"CustomModelBrand", 'String'>
    readonly name: FieldRef<"CustomModelBrand", 'String'>
    readonly logo: FieldRef<"CustomModelBrand", 'String'>
    readonly apiEndpoint: FieldRef<"CustomModelBrand", 'String'>
    readonly isActive: FieldRef<"CustomModelBrand", 'Boolean'>
    readonly createdAt: FieldRef<"CustomModelBrand", 'DateTime'>
    readonly updatedAt: FieldRef<"CustomModelBrand", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CustomModelBrand findUnique
   */
  export type CustomModelBrandFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomModelBrand
     */
    select?: CustomModelBrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomModelBrand
     */
    omit?: CustomModelBrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomModelBrandInclude<ExtArgs> | null
    /**
     * Filter, which CustomModelBrand to fetch.
     */
    where: CustomModelBrandWhereUniqueInput
  }

  /**
   * CustomModelBrand findUniqueOrThrow
   */
  export type CustomModelBrandFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomModelBrand
     */
    select?: CustomModelBrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomModelBrand
     */
    omit?: CustomModelBrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomModelBrandInclude<ExtArgs> | null
    /**
     * Filter, which CustomModelBrand to fetch.
     */
    where: CustomModelBrandWhereUniqueInput
  }

  /**
   * CustomModelBrand findFirst
   */
  export type CustomModelBrandFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomModelBrand
     */
    select?: CustomModelBrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomModelBrand
     */
    omit?: CustomModelBrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomModelBrandInclude<ExtArgs> | null
    /**
     * Filter, which CustomModelBrand to fetch.
     */
    where?: CustomModelBrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomModelBrands to fetch.
     */
    orderBy?: CustomModelBrandOrderByWithRelationInput | CustomModelBrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomModelBrands.
     */
    cursor?: CustomModelBrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomModelBrands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomModelBrands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomModelBrands.
     */
    distinct?: CustomModelBrandScalarFieldEnum | CustomModelBrandScalarFieldEnum[]
  }

  /**
   * CustomModelBrand findFirstOrThrow
   */
  export type CustomModelBrandFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomModelBrand
     */
    select?: CustomModelBrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomModelBrand
     */
    omit?: CustomModelBrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomModelBrandInclude<ExtArgs> | null
    /**
     * Filter, which CustomModelBrand to fetch.
     */
    where?: CustomModelBrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomModelBrands to fetch.
     */
    orderBy?: CustomModelBrandOrderByWithRelationInput | CustomModelBrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomModelBrands.
     */
    cursor?: CustomModelBrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomModelBrands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomModelBrands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomModelBrands.
     */
    distinct?: CustomModelBrandScalarFieldEnum | CustomModelBrandScalarFieldEnum[]
  }

  /**
   * CustomModelBrand findMany
   */
  export type CustomModelBrandFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomModelBrand
     */
    select?: CustomModelBrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomModelBrand
     */
    omit?: CustomModelBrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomModelBrandInclude<ExtArgs> | null
    /**
     * Filter, which CustomModelBrands to fetch.
     */
    where?: CustomModelBrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomModelBrands to fetch.
     */
    orderBy?: CustomModelBrandOrderByWithRelationInput | CustomModelBrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomModelBrands.
     */
    cursor?: CustomModelBrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomModelBrands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomModelBrands.
     */
    skip?: number
    distinct?: CustomModelBrandScalarFieldEnum | CustomModelBrandScalarFieldEnum[]
  }

  /**
   * CustomModelBrand create
   */
  export type CustomModelBrandCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomModelBrand
     */
    select?: CustomModelBrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomModelBrand
     */
    omit?: CustomModelBrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomModelBrandInclude<ExtArgs> | null
    /**
     * The data needed to create a CustomModelBrand.
     */
    data: XOR<CustomModelBrandCreateInput, CustomModelBrandUncheckedCreateInput>
  }

  /**
   * CustomModelBrand createMany
   */
  export type CustomModelBrandCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomModelBrands.
     */
    data: CustomModelBrandCreateManyInput | CustomModelBrandCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CustomModelBrand createManyAndReturn
   */
  export type CustomModelBrandCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomModelBrand
     */
    select?: CustomModelBrandSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomModelBrand
     */
    omit?: CustomModelBrandOmit<ExtArgs> | null
    /**
     * The data used to create many CustomModelBrands.
     */
    data: CustomModelBrandCreateManyInput | CustomModelBrandCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CustomModelBrand update
   */
  export type CustomModelBrandUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomModelBrand
     */
    select?: CustomModelBrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomModelBrand
     */
    omit?: CustomModelBrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomModelBrandInclude<ExtArgs> | null
    /**
     * The data needed to update a CustomModelBrand.
     */
    data: XOR<CustomModelBrandUpdateInput, CustomModelBrandUncheckedUpdateInput>
    /**
     * Choose, which CustomModelBrand to update.
     */
    where: CustomModelBrandWhereUniqueInput
  }

  /**
   * CustomModelBrand updateMany
   */
  export type CustomModelBrandUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomModelBrands.
     */
    data: XOR<CustomModelBrandUpdateManyMutationInput, CustomModelBrandUncheckedUpdateManyInput>
    /**
     * Filter which CustomModelBrands to update
     */
    where?: CustomModelBrandWhereInput
    /**
     * Limit how many CustomModelBrands to update.
     */
    limit?: number
  }

  /**
   * CustomModelBrand updateManyAndReturn
   */
  export type CustomModelBrandUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomModelBrand
     */
    select?: CustomModelBrandSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomModelBrand
     */
    omit?: CustomModelBrandOmit<ExtArgs> | null
    /**
     * The data used to update CustomModelBrands.
     */
    data: XOR<CustomModelBrandUpdateManyMutationInput, CustomModelBrandUncheckedUpdateManyInput>
    /**
     * Filter which CustomModelBrands to update
     */
    where?: CustomModelBrandWhereInput
    /**
     * Limit how many CustomModelBrands to update.
     */
    limit?: number
  }

  /**
   * CustomModelBrand upsert
   */
  export type CustomModelBrandUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomModelBrand
     */
    select?: CustomModelBrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomModelBrand
     */
    omit?: CustomModelBrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomModelBrandInclude<ExtArgs> | null
    /**
     * The filter to search for the CustomModelBrand to update in case it exists.
     */
    where: CustomModelBrandWhereUniqueInput
    /**
     * In case the CustomModelBrand found by the `where` argument doesn't exist, create a new CustomModelBrand with this data.
     */
    create: XOR<CustomModelBrandCreateInput, CustomModelBrandUncheckedCreateInput>
    /**
     * In case the CustomModelBrand was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomModelBrandUpdateInput, CustomModelBrandUncheckedUpdateInput>
  }

  /**
   * CustomModelBrand delete
   */
  export type CustomModelBrandDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomModelBrand
     */
    select?: CustomModelBrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomModelBrand
     */
    omit?: CustomModelBrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomModelBrandInclude<ExtArgs> | null
    /**
     * Filter which CustomModelBrand to delete.
     */
    where: CustomModelBrandWhereUniqueInput
  }

  /**
   * CustomModelBrand deleteMany
   */
  export type CustomModelBrandDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomModelBrands to delete
     */
    where?: CustomModelBrandWhereInput
    /**
     * Limit how many CustomModelBrands to delete.
     */
    limit?: number
  }

  /**
   * CustomModelBrand.models
   */
  export type CustomModelBrand$modelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomModel
     */
    select?: CustomModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomModel
     */
    omit?: CustomModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomModelInclude<ExtArgs> | null
    where?: CustomModelWhereInput
    orderBy?: CustomModelOrderByWithRelationInput | CustomModelOrderByWithRelationInput[]
    cursor?: CustomModelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomModelScalarFieldEnum | CustomModelScalarFieldEnum[]
  }

  /**
   * CustomModelBrand without action
   */
  export type CustomModelBrandDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomModelBrand
     */
    select?: CustomModelBrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomModelBrand
     */
    omit?: CustomModelBrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomModelBrandInclude<ExtArgs> | null
  }


  /**
   * Model CustomModel
   */

  export type AggregateCustomModel = {
    _count: CustomModelCountAggregateOutputType | null
    _min: CustomModelMinAggregateOutputType | null
    _max: CustomModelMaxAggregateOutputType | null
  }

  export type CustomModelMinAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    brandId: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomModelMaxAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    brandId: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomModelCountAggregateOutputType = {
    id: number
    name: number
    code: number
    brandId: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CustomModelMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    brandId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomModelMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    brandId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomModelCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    brandId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CustomModelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomModel to aggregate.
     */
    where?: CustomModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomModels to fetch.
     */
    orderBy?: CustomModelOrderByWithRelationInput | CustomModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomModels
    **/
    _count?: true | CustomModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomModelMaxAggregateInputType
  }

  export type GetCustomModelAggregateType<T extends CustomModelAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomModel[P]>
      : GetScalarType<T[P], AggregateCustomModel[P]>
  }




  export type CustomModelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomModelWhereInput
    orderBy?: CustomModelOrderByWithAggregationInput | CustomModelOrderByWithAggregationInput[]
    by: CustomModelScalarFieldEnum[] | CustomModelScalarFieldEnum
    having?: CustomModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomModelCountAggregateInputType | true
    _min?: CustomModelMinAggregateInputType
    _max?: CustomModelMaxAggregateInputType
  }

  export type CustomModelGroupByOutputType = {
    id: string
    name: string
    code: string
    brandId: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: CustomModelCountAggregateOutputType | null
    _min: CustomModelMinAggregateOutputType | null
    _max: CustomModelMaxAggregateOutputType | null
  }

  type GetCustomModelGroupByPayload<T extends CustomModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomModelGroupByOutputType[P]>
            : GetScalarType<T[P], CustomModelGroupByOutputType[P]>
        }
      >
    >


  export type CustomModelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    brandId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    brand?: boolean | CustomModelBrandDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customModel"]>

  export type CustomModelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    brandId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    brand?: boolean | CustomModelBrandDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customModel"]>

  export type CustomModelSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    brandId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    brand?: boolean | CustomModelBrandDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customModel"]>

  export type CustomModelSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    brandId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CustomModelOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "code" | "brandId" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["customModel"]>
  export type CustomModelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brand?: boolean | CustomModelBrandDefaultArgs<ExtArgs>
  }
  export type CustomModelIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brand?: boolean | CustomModelBrandDefaultArgs<ExtArgs>
  }
  export type CustomModelIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brand?: boolean | CustomModelBrandDefaultArgs<ExtArgs>
  }

  export type $CustomModelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomModel"
    objects: {
      brand: Prisma.$CustomModelBrandPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      code: string
      brandId: string
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["customModel"]>
    composites: {}
  }

  type CustomModelGetPayload<S extends boolean | null | undefined | CustomModelDefaultArgs> = $Result.GetResult<Prisma.$CustomModelPayload, S>

  type CustomModelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomModelFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomModelCountAggregateInputType | true
    }

  export interface CustomModelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomModel'], meta: { name: 'CustomModel' } }
    /**
     * Find zero or one CustomModel that matches the filter.
     * @param {CustomModelFindUniqueArgs} args - Arguments to find a CustomModel
     * @example
     * // Get one CustomModel
     * const customModel = await prisma.customModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomModelFindUniqueArgs>(args: SelectSubset<T, CustomModelFindUniqueArgs<ExtArgs>>): Prisma__CustomModelClient<$Result.GetResult<Prisma.$CustomModelPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CustomModel that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomModelFindUniqueOrThrowArgs} args - Arguments to find a CustomModel
     * @example
     * // Get one CustomModel
     * const customModel = await prisma.customModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomModelFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomModelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomModelClient<$Result.GetResult<Prisma.$CustomModelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomModelFindFirstArgs} args - Arguments to find a CustomModel
     * @example
     * // Get one CustomModel
     * const customModel = await prisma.customModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomModelFindFirstArgs>(args?: SelectSubset<T, CustomModelFindFirstArgs<ExtArgs>>): Prisma__CustomModelClient<$Result.GetResult<Prisma.$CustomModelPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomModel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomModelFindFirstOrThrowArgs} args - Arguments to find a CustomModel
     * @example
     * // Get one CustomModel
     * const customModel = await prisma.customModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomModelFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomModelFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomModelClient<$Result.GetResult<Prisma.$CustomModelPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CustomModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomModelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomModels
     * const customModels = await prisma.customModel.findMany()
     * 
     * // Get first 10 CustomModels
     * const customModels = await prisma.customModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customModelWithIdOnly = await prisma.customModel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomModelFindManyArgs>(args?: SelectSubset<T, CustomModelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomModelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CustomModel.
     * @param {CustomModelCreateArgs} args - Arguments to create a CustomModel.
     * @example
     * // Create one CustomModel
     * const CustomModel = await prisma.customModel.create({
     *   data: {
     *     // ... data to create a CustomModel
     *   }
     * })
     * 
     */
    create<T extends CustomModelCreateArgs>(args: SelectSubset<T, CustomModelCreateArgs<ExtArgs>>): Prisma__CustomModelClient<$Result.GetResult<Prisma.$CustomModelPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CustomModels.
     * @param {CustomModelCreateManyArgs} args - Arguments to create many CustomModels.
     * @example
     * // Create many CustomModels
     * const customModel = await prisma.customModel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomModelCreateManyArgs>(args?: SelectSubset<T, CustomModelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CustomModels and returns the data saved in the database.
     * @param {CustomModelCreateManyAndReturnArgs} args - Arguments to create many CustomModels.
     * @example
     * // Create many CustomModels
     * const customModel = await prisma.customModel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CustomModels and only return the `id`
     * const customModelWithIdOnly = await prisma.customModel.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomModelCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomModelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomModelPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CustomModel.
     * @param {CustomModelDeleteArgs} args - Arguments to delete one CustomModel.
     * @example
     * // Delete one CustomModel
     * const CustomModel = await prisma.customModel.delete({
     *   where: {
     *     // ... filter to delete one CustomModel
     *   }
     * })
     * 
     */
    delete<T extends CustomModelDeleteArgs>(args: SelectSubset<T, CustomModelDeleteArgs<ExtArgs>>): Prisma__CustomModelClient<$Result.GetResult<Prisma.$CustomModelPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CustomModel.
     * @param {CustomModelUpdateArgs} args - Arguments to update one CustomModel.
     * @example
     * // Update one CustomModel
     * const customModel = await prisma.customModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomModelUpdateArgs>(args: SelectSubset<T, CustomModelUpdateArgs<ExtArgs>>): Prisma__CustomModelClient<$Result.GetResult<Prisma.$CustomModelPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CustomModels.
     * @param {CustomModelDeleteManyArgs} args - Arguments to filter CustomModels to delete.
     * @example
     * // Delete a few CustomModels
     * const { count } = await prisma.customModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomModelDeleteManyArgs>(args?: SelectSubset<T, CustomModelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomModels
     * const customModel = await prisma.customModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomModelUpdateManyArgs>(args: SelectSubset<T, CustomModelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomModels and returns the data updated in the database.
     * @param {CustomModelUpdateManyAndReturnArgs} args - Arguments to update many CustomModels.
     * @example
     * // Update many CustomModels
     * const customModel = await prisma.customModel.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CustomModels and only return the `id`
     * const customModelWithIdOnly = await prisma.customModel.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomModelUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomModelUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomModelPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CustomModel.
     * @param {CustomModelUpsertArgs} args - Arguments to update or create a CustomModel.
     * @example
     * // Update or create a CustomModel
     * const customModel = await prisma.customModel.upsert({
     *   create: {
     *     // ... data to create a CustomModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomModel we want to update
     *   }
     * })
     */
    upsert<T extends CustomModelUpsertArgs>(args: SelectSubset<T, CustomModelUpsertArgs<ExtArgs>>): Prisma__CustomModelClient<$Result.GetResult<Prisma.$CustomModelPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CustomModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomModelCountArgs} args - Arguments to filter CustomModels to count.
     * @example
     * // Count the number of CustomModels
     * const count = await prisma.customModel.count({
     *   where: {
     *     // ... the filter for the CustomModels we want to count
     *   }
     * })
    **/
    count<T extends CustomModelCountArgs>(
      args?: Subset<T, CustomModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomModelAggregateArgs>(args: Subset<T, CustomModelAggregateArgs>): Prisma.PrismaPromise<GetCustomModelAggregateType<T>>

    /**
     * Group by CustomModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomModelGroupByArgs['orderBy'] }
        : { orderBy?: CustomModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomModel model
   */
  readonly fields: CustomModelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomModelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    brand<T extends CustomModelBrandDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomModelBrandDefaultArgs<ExtArgs>>): Prisma__CustomModelBrandClient<$Result.GetResult<Prisma.$CustomModelBrandPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CustomModel model
   */
  interface CustomModelFieldRefs {
    readonly id: FieldRef<"CustomModel", 'String'>
    readonly name: FieldRef<"CustomModel", 'String'>
    readonly code: FieldRef<"CustomModel", 'String'>
    readonly brandId: FieldRef<"CustomModel", 'String'>
    readonly isActive: FieldRef<"CustomModel", 'Boolean'>
    readonly createdAt: FieldRef<"CustomModel", 'DateTime'>
    readonly updatedAt: FieldRef<"CustomModel", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CustomModel findUnique
   */
  export type CustomModelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomModel
     */
    select?: CustomModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomModel
     */
    omit?: CustomModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomModelInclude<ExtArgs> | null
    /**
     * Filter, which CustomModel to fetch.
     */
    where: CustomModelWhereUniqueInput
  }

  /**
   * CustomModel findUniqueOrThrow
   */
  export type CustomModelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomModel
     */
    select?: CustomModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomModel
     */
    omit?: CustomModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomModelInclude<ExtArgs> | null
    /**
     * Filter, which CustomModel to fetch.
     */
    where: CustomModelWhereUniqueInput
  }

  /**
   * CustomModel findFirst
   */
  export type CustomModelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomModel
     */
    select?: CustomModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomModel
     */
    omit?: CustomModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomModelInclude<ExtArgs> | null
    /**
     * Filter, which CustomModel to fetch.
     */
    where?: CustomModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomModels to fetch.
     */
    orderBy?: CustomModelOrderByWithRelationInput | CustomModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomModels.
     */
    cursor?: CustomModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomModels.
     */
    distinct?: CustomModelScalarFieldEnum | CustomModelScalarFieldEnum[]
  }

  /**
   * CustomModel findFirstOrThrow
   */
  export type CustomModelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomModel
     */
    select?: CustomModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomModel
     */
    omit?: CustomModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomModelInclude<ExtArgs> | null
    /**
     * Filter, which CustomModel to fetch.
     */
    where?: CustomModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomModels to fetch.
     */
    orderBy?: CustomModelOrderByWithRelationInput | CustomModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomModels.
     */
    cursor?: CustomModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomModels.
     */
    distinct?: CustomModelScalarFieldEnum | CustomModelScalarFieldEnum[]
  }

  /**
   * CustomModel findMany
   */
  export type CustomModelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomModel
     */
    select?: CustomModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomModel
     */
    omit?: CustomModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomModelInclude<ExtArgs> | null
    /**
     * Filter, which CustomModels to fetch.
     */
    where?: CustomModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomModels to fetch.
     */
    orderBy?: CustomModelOrderByWithRelationInput | CustomModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomModels.
     */
    cursor?: CustomModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomModels.
     */
    skip?: number
    distinct?: CustomModelScalarFieldEnum | CustomModelScalarFieldEnum[]
  }

  /**
   * CustomModel create
   */
  export type CustomModelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomModel
     */
    select?: CustomModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomModel
     */
    omit?: CustomModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomModelInclude<ExtArgs> | null
    /**
     * The data needed to create a CustomModel.
     */
    data: XOR<CustomModelCreateInput, CustomModelUncheckedCreateInput>
  }

  /**
   * CustomModel createMany
   */
  export type CustomModelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomModels.
     */
    data: CustomModelCreateManyInput | CustomModelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CustomModel createManyAndReturn
   */
  export type CustomModelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomModel
     */
    select?: CustomModelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomModel
     */
    omit?: CustomModelOmit<ExtArgs> | null
    /**
     * The data used to create many CustomModels.
     */
    data: CustomModelCreateManyInput | CustomModelCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomModelIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomModel update
   */
  export type CustomModelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomModel
     */
    select?: CustomModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomModel
     */
    omit?: CustomModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomModelInclude<ExtArgs> | null
    /**
     * The data needed to update a CustomModel.
     */
    data: XOR<CustomModelUpdateInput, CustomModelUncheckedUpdateInput>
    /**
     * Choose, which CustomModel to update.
     */
    where: CustomModelWhereUniqueInput
  }

  /**
   * CustomModel updateMany
   */
  export type CustomModelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomModels.
     */
    data: XOR<CustomModelUpdateManyMutationInput, CustomModelUncheckedUpdateManyInput>
    /**
     * Filter which CustomModels to update
     */
    where?: CustomModelWhereInput
    /**
     * Limit how many CustomModels to update.
     */
    limit?: number
  }

  /**
   * CustomModel updateManyAndReturn
   */
  export type CustomModelUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomModel
     */
    select?: CustomModelSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomModel
     */
    omit?: CustomModelOmit<ExtArgs> | null
    /**
     * The data used to update CustomModels.
     */
    data: XOR<CustomModelUpdateManyMutationInput, CustomModelUncheckedUpdateManyInput>
    /**
     * Filter which CustomModels to update
     */
    where?: CustomModelWhereInput
    /**
     * Limit how many CustomModels to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomModelIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomModel upsert
   */
  export type CustomModelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomModel
     */
    select?: CustomModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomModel
     */
    omit?: CustomModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomModelInclude<ExtArgs> | null
    /**
     * The filter to search for the CustomModel to update in case it exists.
     */
    where: CustomModelWhereUniqueInput
    /**
     * In case the CustomModel found by the `where` argument doesn't exist, create a new CustomModel with this data.
     */
    create: XOR<CustomModelCreateInput, CustomModelUncheckedCreateInput>
    /**
     * In case the CustomModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomModelUpdateInput, CustomModelUncheckedUpdateInput>
  }

  /**
   * CustomModel delete
   */
  export type CustomModelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomModel
     */
    select?: CustomModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomModel
     */
    omit?: CustomModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomModelInclude<ExtArgs> | null
    /**
     * Filter which CustomModel to delete.
     */
    where: CustomModelWhereUniqueInput
  }

  /**
   * CustomModel deleteMany
   */
  export type CustomModelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomModels to delete
     */
    where?: CustomModelWhereInput
    /**
     * Limit how many CustomModels to delete.
     */
    limit?: number
  }

  /**
   * CustomModel without action
   */
  export type CustomModelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomModel
     */
    select?: CustomModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomModel
     */
    omit?: CustomModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomModelInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    phone: 'phone',
    phoneVerified: 'phoneVerified',
    salary: 'salary',
    payoutDate: 'payoutDate',
    password: 'password',
    email: 'email',
    dateOfJoining: 'dateOfJoining',
    dateOfTermination: 'dateOfTermination',
    profileImage: 'profileImage',
    aadharFrontImage: 'aadharFrontImage',
    aadharBackImage: 'aadharBackImage',
    qualificationImage: 'qualificationImage',
    VehicleFrontImage: 'VehicleFrontImage',
    VehicleBackImage: 'VehicleBackImage',
    role: 'role',
    storeId: 'storeId',
    mfaEnabled: 'mfaEnabled',
    mfaSecret: 'mfaSecret',
    mfaVerified: 'mfaVerified',
    createdBy: 'createdBy',
    isAdmin: 'isAdmin',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AdminScalarFieldEnum: {
    userId: 'userId',
    employeeId: 'employeeId',
    firstName: 'firstName',
    lastName: 'lastName'
  };

  export type AdminScalarFieldEnum = (typeof AdminScalarFieldEnum)[keyof typeof AdminScalarFieldEnum]


  export const ManagerScalarFieldEnum: {
    userId: 'userId',
    firstName: 'firstName',
    lastName: 'lastName',
    employeeId: 'employeeId',
    aadharId: 'aadharId'
  };

  export type ManagerScalarFieldEnum = (typeof ManagerScalarFieldEnum)[keyof typeof ManagerScalarFieldEnum]


  export const TechnicianScalarFieldEnum: {
    userId: 'userId',
    firstName: 'firstName',
    lastName: 'lastName',
    employeeId: 'employeeId',
    aadharId: 'aadharId'
  };

  export type TechnicianScalarFieldEnum = (typeof TechnicianScalarFieldEnum)[keyof typeof TechnicianScalarFieldEnum]


  export const FieldExecutiveScalarFieldEnum: {
    userId: 'userId',
    firstName: 'firstName',
    lastName: 'lastName',
    employeeId: 'employeeId',
    aadharId: 'aadharId'
  };

  export type FieldExecutiveScalarFieldEnum = (typeof FieldExecutiveScalarFieldEnum)[keyof typeof FieldExecutiveScalarFieldEnum]


  export const SalesExecutiveScalarFieldEnum: {
    userId: 'userId',
    firstName: 'firstName',
    lastName: 'lastName',
    employeeId: 'employeeId',
    aadharId: 'aadharId'
  };

  export type SalesExecutiveScalarFieldEnum = (typeof SalesExecutiveScalarFieldEnum)[keyof typeof SalesExecutiveScalarFieldEnum]


  export const StoreScalarFieldEnum: {
    userId: 'userId',
    storeId: 'storeId',
    storeName: 'storeName',
    ownerName: 'ownerName',
    ownerPhone: 'ownerPhone',
    ownerEmail: 'ownerEmail',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StoreScalarFieldEnum = (typeof StoreScalarFieldEnum)[keyof typeof StoreScalarFieldEnum]


  export const BankDetailsScalarFieldEnum: {
    id: 'id',
    accountNumber: 'accountNumber',
    ifsc: 'ifsc',
    bankName: 'bankName',
    beneficiaryName: 'beneficiaryName',
    upiId: 'upiId',
    managerId: 'managerId',
    technicianId: 'technicianId',
    fieldExecId: 'fieldExecId',
    salesExecId: 'salesExecId',
    storeId: 'storeId'
  };

  export type BankDetailsScalarFieldEnum = (typeof BankDetailsScalarFieldEnum)[keyof typeof BankDetailsScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    device: 'device',
    browser: 'browser',
    os: 'os',
    location: 'location',
    latitude: 'latitude',
    longitude: 'longitude'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    body: 'body',
    read: 'read',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const DeviceTestScalarFieldEnum: {
    id: 'id',
    testId: 'testId',
    employeeId: 'employeeId',
    imageUrl: 'imageUrl',
    expiresAt: 'expiresAt',
    device: 'device',
    imei1: 'imei1',
    imei2: 'imei2',
    createdAt: 'createdAt'
  };

  export type DeviceTestScalarFieldEnum = (typeof DeviceTestScalarFieldEnum)[keyof typeof DeviceTestScalarFieldEnum]


  export const ConnectivityTestResultScalarFieldEnum: {
    id: 'id',
    name: 'name',
    status: 'status',
    message: 'message',
    timestamp: 'timestamp',
    deviceTestId: 'deviceTestId'
  };

  export type ConnectivityTestResultScalarFieldEnum = (typeof ConnectivityTestResultScalarFieldEnum)[keyof typeof ConnectivityTestResultScalarFieldEnum]


  export const DeviceTestResultScalarFieldEnum: {
    id: 'id',
    name: 'name',
    status: 'status',
    message: 'message',
    timestamp: 'timestamp',
    deviceTestId: 'deviceTestId'
  };

  export type DeviceTestResultScalarFieldEnum = (typeof DeviceTestResultScalarFieldEnum)[keyof typeof DeviceTestResultScalarFieldEnum]


  export const SimTestResultScalarFieldEnum: {
    id: 'id',
    name: 'name',
    status: 'status',
    timestamp: 'timestamp',
    deviceTestId: 'deviceTestId'
  };

  export type SimTestResultScalarFieldEnum = (typeof SimTestResultScalarFieldEnum)[keyof typeof SimTestResultScalarFieldEnum]


  export const ScreenTestScalarFieldEnum: {
    id: 'id',
    multiTouch: 'multiTouch',
    dotCoverage: 'dotCoverage',
    completed: 'completed',
    timestamp: 'timestamp',
    deviceTestId: 'deviceTestId'
  };

  export type ScreenTestScalarFieldEnum = (typeof ScreenTestScalarFieldEnum)[keyof typeof ScreenTestScalarFieldEnum]


  export const AudioTestScalarFieldEnum: {
    id: 'id',
    speaker: 'speaker',
    earReceiver: 'earReceiver',
    microphone: 'microphone',
    timestamp: 'timestamp',
    deviceTestId: 'deviceTestId'
  };

  export type AudioTestScalarFieldEnum = (typeof AudioTestScalarFieldEnum)[keyof typeof AudioTestScalarFieldEnum]


  export const ProximitySensorTestScalarFieldEnum: {
    id: 'id',
    status: 'status',
    message: 'message',
    timestamp: 'timestamp',
    deviceTestId: 'deviceTestId'
  };

  export type ProximitySensorTestScalarFieldEnum = (typeof ProximitySensorTestScalarFieldEnum)[keyof typeof ProximitySensorTestScalarFieldEnum]


  export const CameraTestScalarFieldEnum: {
    id: 'id',
    frontCamera: 'frontCamera',
    backCamera: 'backCamera',
    timestamp: 'timestamp',
    deviceTestId: 'deviceTestId'
  };

  export type CameraTestScalarFieldEnum = (typeof CameraTestScalarFieldEnum)[keyof typeof CameraTestScalarFieldEnum]


  export const FingerprintTestScalarFieldEnum: {
    id: 'id',
    status: 'status',
    message: 'message',
    timestamp: 'timestamp',
    deviceTestId: 'deviceTestId'
  };

  export type FingerprintTestScalarFieldEnum = (typeof FingerprintTestScalarFieldEnum)[keyof typeof FingerprintTestScalarFieldEnum]


  export const UsbTestScalarFieldEnum: {
    id: 'id',
    status: 'status',
    message: 'message',
    timestamp: 'timestamp',
    deviceTestId: 'deviceTestId'
  };

  export type UsbTestScalarFieldEnum = (typeof UsbTestScalarFieldEnum)[keyof typeof UsbTestScalarFieldEnum]


  export const AudioJackTestScalarFieldEnum: {
    id: 'id',
    status: 'status',
    message: 'message',
    timestamp: 'timestamp',
    deviceTestId: 'deviceTestId'
  };

  export type AudioJackTestScalarFieldEnum = (typeof AudioJackTestScalarFieldEnum)[keyof typeof AudioJackTestScalarFieldEnum]


  export const ManualDiagnosticsResultScalarFieldEnum: {
    id: 'id',
    diagnoseId: 'diagnoseId',
    employeeId: 'employeeId',
    smc: 'smc',
    variant: 'variant',
    imei1: 'imei1',
    imei2: 'imei2',
    screenTouch: 'screenTouch',
    screenSpot: 'screenSpot',
    screenLines: 'screenLines',
    screenPhysical: 'screenPhysical',
    screenDiscolor: 'screenDiscolor',
    screenBubble: 'screenBubble',
    frontCamera: 'frontCamera',
    backCamera: 'backCamera',
    audioJack: 'audioJack',
    wifi: 'wifi',
    gps: 'gps',
    bluetooth: 'bluetooth',
    volumeButton: 'volumeButton',
    flashLight: 'flashLight',
    fcImageBlurred: 'fcImageBlurred',
    bcImageBlurred: 'bcImageBlurred',
    vibrator: 'vibrator',
    battery: 'battery',
    speaker: 'speaker',
    microphone: 'microphone',
    fingerprint: 'fingerprint',
    proximity: 'proximity',
    chargingPort: 'chargingPort',
    powerButton: 'powerButton',
    faceLock: 'faceLock',
    copyScreen: 'copyScreen',
    sim: 'sim',
    physicalScratch: 'physicalScratch',
    physicalDent: 'physicalDent',
    physicalPanel: 'physicalPanel',
    physicalBent: 'physicalBent',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ManualDiagnosticsResultScalarFieldEnum = (typeof ManualDiagnosticsResultScalarFieldEnum)[keyof typeof ManualDiagnosticsResultScalarFieldEnum]


  export const DeclarationScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    brand: 'brand',
    model: 'model',
    smc: 'smc',
    variant: 'variant',
    imei1: 'imei1',
    imei2: 'imei2',
    bluetooth: 'bluetooth',
    gps: 'gps',
    wifi: 'wifi',
    proximity: 'proximity',
    multiTouch: 'multiTouch',
    screenCalibration: 'screenCalibration',
    speaker: 'speaker',
    earReceiver: 'earReceiver',
    microphone: 'microphone',
    frontCamera: 'frontCamera',
    backCamera: 'backCamera',
    sim: 'sim',
    fingerprint: 'fingerprint',
    chargingPort: 'chargingPort',
    audioJack: 'audioJack',
    isAccepted: 'isAccepted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DeclarationScalarFieldEnum = (typeof DeclarationScalarFieldEnum)[keyof typeof DeclarationScalarFieldEnum]


  export const AddressScalarFieldEnum: {
    id: 'id',
    streetAddress: 'streetAddress',
    city: 'city',
    state: 'state',
    country: 'country',
    pinCode: 'pinCode',
    storeId: 'storeId'
  };

  export type AddressScalarFieldEnum = (typeof AddressScalarFieldEnum)[keyof typeof AddressScalarFieldEnum]


  export const OtpScalarFieldEnum: {
    id: 'id',
    identifier: 'identifier',
    otp: 'otp',
    expiresAt: 'expiresAt',
    used: 'used',
    createdAt: 'createdAt',
    attempts: 'attempts'
  };

  export type OtpScalarFieldEnum = (typeof OtpScalarFieldEnum)[keyof typeof OtpScalarFieldEnum]


  export const CustomModelBrandScalarFieldEnum: {
    id: 'id',
    name: 'name',
    logo: 'logo',
    apiEndpoint: 'apiEndpoint',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CustomModelBrandScalarFieldEnum = (typeof CustomModelBrandScalarFieldEnum)[keyof typeof CustomModelBrandScalarFieldEnum]


  export const CustomModelScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    brandId: 'brandId',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CustomModelScalarFieldEnum = (typeof CustomModelScalarFieldEnum)[keyof typeof CustomModelScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'UserStatus'
   */
  export type EnumUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserStatus'>
    


  /**
   * Reference to a field of type 'UserStatus[]'
   */
  export type ListEnumUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    phone?: StringFilter<"User"> | string
    phoneVerified?: BoolNullableFilter<"User"> | boolean | null
    salary?: DecimalNullableFilter<"User"> | Decimal | DecimalJsLike | number | string | null
    payoutDate?: IntNullableFilter<"User"> | number | null
    password?: StringFilter<"User"> | string
    email?: StringNullableFilter<"User"> | string | null
    dateOfJoining?: DateTimeNullableFilter<"User"> | Date | string | null
    dateOfTermination?: DateTimeNullableFilter<"User"> | Date | string | null
    profileImage?: StringNullableFilter<"User"> | string | null
    aadharFrontImage?: StringNullableFilter<"User"> | string | null
    aadharBackImage?: StringNullableFilter<"User"> | string | null
    qualificationImage?: StringNullableFilter<"User"> | string | null
    VehicleFrontImage?: StringNullableFilter<"User"> | string | null
    VehicleBackImage?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleNullableFilter<"User"> | $Enums.Role | null
    storeId?: StringNullableFilter<"User"> | string | null
    mfaEnabled?: BoolFilter<"User"> | boolean
    mfaSecret?: StringNullableFilter<"User"> | string | null
    mfaVerified?: BoolFilter<"User"> | boolean
    createdBy?: StringNullableFilter<"User"> | string | null
    isAdmin?: BoolFilter<"User"> | boolean
    status?: EnumUserStatusFilter<"User"> | $Enums.UserStatus
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    sessions?: SessionListRelationFilter
    manager?: XOR<ManagerNullableScalarRelationFilter, ManagerWhereInput> | null
    technician?: XOR<TechnicianNullableScalarRelationFilter, TechnicianWhereInput> | null
    fieldExecutive?: XOR<FieldExecutiveNullableScalarRelationFilter, FieldExecutiveWhereInput> | null
    salesExecutive?: XOR<SalesExecutiveNullableScalarRelationFilter, SalesExecutiveWhereInput> | null
    store?: XOR<StoreNullableScalarRelationFilter, StoreWhereInput> | null
    admin?: XOR<AdminNullableScalarRelationFilter, AdminWhereInput> | null
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    phone?: SortOrder
    phoneVerified?: SortOrderInput | SortOrder
    salary?: SortOrderInput | SortOrder
    payoutDate?: SortOrderInput | SortOrder
    password?: SortOrder
    email?: SortOrderInput | SortOrder
    dateOfJoining?: SortOrderInput | SortOrder
    dateOfTermination?: SortOrderInput | SortOrder
    profileImage?: SortOrderInput | SortOrder
    aadharFrontImage?: SortOrderInput | SortOrder
    aadharBackImage?: SortOrderInput | SortOrder
    qualificationImage?: SortOrderInput | SortOrder
    VehicleFrontImage?: SortOrderInput | SortOrder
    VehicleBackImage?: SortOrderInput | SortOrder
    role?: SortOrderInput | SortOrder
    storeId?: SortOrderInput | SortOrder
    mfaEnabled?: SortOrder
    mfaSecret?: SortOrderInput | SortOrder
    mfaVerified?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    isAdmin?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sessions?: SessionOrderByRelationAggregateInput
    manager?: ManagerOrderByWithRelationInput
    technician?: TechnicianOrderByWithRelationInput
    fieldExecutive?: FieldExecutiveOrderByWithRelationInput
    salesExecutive?: SalesExecutiveOrderByWithRelationInput
    store?: StoreOrderByWithRelationInput
    admin?: AdminOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    phone?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    phoneVerified?: BoolNullableFilter<"User"> | boolean | null
    salary?: DecimalNullableFilter<"User"> | Decimal | DecimalJsLike | number | string | null
    payoutDate?: IntNullableFilter<"User"> | number | null
    password?: StringFilter<"User"> | string
    email?: StringNullableFilter<"User"> | string | null
    dateOfJoining?: DateTimeNullableFilter<"User"> | Date | string | null
    dateOfTermination?: DateTimeNullableFilter<"User"> | Date | string | null
    profileImage?: StringNullableFilter<"User"> | string | null
    aadharFrontImage?: StringNullableFilter<"User"> | string | null
    aadharBackImage?: StringNullableFilter<"User"> | string | null
    qualificationImage?: StringNullableFilter<"User"> | string | null
    VehicleFrontImage?: StringNullableFilter<"User"> | string | null
    VehicleBackImage?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleNullableFilter<"User"> | $Enums.Role | null
    storeId?: StringNullableFilter<"User"> | string | null
    mfaEnabled?: BoolFilter<"User"> | boolean
    mfaSecret?: StringNullableFilter<"User"> | string | null
    mfaVerified?: BoolFilter<"User"> | boolean
    createdBy?: StringNullableFilter<"User"> | string | null
    isAdmin?: BoolFilter<"User"> | boolean
    status?: EnumUserStatusFilter<"User"> | $Enums.UserStatus
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    sessions?: SessionListRelationFilter
    manager?: XOR<ManagerNullableScalarRelationFilter, ManagerWhereInput> | null
    technician?: XOR<TechnicianNullableScalarRelationFilter, TechnicianWhereInput> | null
    fieldExecutive?: XOR<FieldExecutiveNullableScalarRelationFilter, FieldExecutiveWhereInput> | null
    salesExecutive?: XOR<SalesExecutiveNullableScalarRelationFilter, SalesExecutiveWhereInput> | null
    store?: XOR<StoreNullableScalarRelationFilter, StoreWhereInput> | null
    admin?: XOR<AdminNullableScalarRelationFilter, AdminWhereInput> | null
  }, "id" | "phone">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    phone?: SortOrder
    phoneVerified?: SortOrderInput | SortOrder
    salary?: SortOrderInput | SortOrder
    payoutDate?: SortOrderInput | SortOrder
    password?: SortOrder
    email?: SortOrderInput | SortOrder
    dateOfJoining?: SortOrderInput | SortOrder
    dateOfTermination?: SortOrderInput | SortOrder
    profileImage?: SortOrderInput | SortOrder
    aadharFrontImage?: SortOrderInput | SortOrder
    aadharBackImage?: SortOrderInput | SortOrder
    qualificationImage?: SortOrderInput | SortOrder
    VehicleFrontImage?: SortOrderInput | SortOrder
    VehicleBackImage?: SortOrderInput | SortOrder
    role?: SortOrderInput | SortOrder
    storeId?: SortOrderInput | SortOrder
    mfaEnabled?: SortOrder
    mfaSecret?: SortOrderInput | SortOrder
    mfaVerified?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    isAdmin?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    phone?: StringWithAggregatesFilter<"User"> | string
    phoneVerified?: BoolNullableWithAggregatesFilter<"User"> | boolean | null
    salary?: DecimalNullableWithAggregatesFilter<"User"> | Decimal | DecimalJsLike | number | string | null
    payoutDate?: IntNullableWithAggregatesFilter<"User"> | number | null
    password?: StringWithAggregatesFilter<"User"> | string
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    dateOfJoining?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    dateOfTermination?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    profileImage?: StringNullableWithAggregatesFilter<"User"> | string | null
    aadharFrontImage?: StringNullableWithAggregatesFilter<"User"> | string | null
    aadharBackImage?: StringNullableWithAggregatesFilter<"User"> | string | null
    qualificationImage?: StringNullableWithAggregatesFilter<"User"> | string | null
    VehicleFrontImage?: StringNullableWithAggregatesFilter<"User"> | string | null
    VehicleBackImage?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumRoleNullableWithAggregatesFilter<"User"> | $Enums.Role | null
    storeId?: StringNullableWithAggregatesFilter<"User"> | string | null
    mfaEnabled?: BoolWithAggregatesFilter<"User"> | boolean
    mfaSecret?: StringNullableWithAggregatesFilter<"User"> | string | null
    mfaVerified?: BoolWithAggregatesFilter<"User"> | boolean
    createdBy?: StringNullableWithAggregatesFilter<"User"> | string | null
    isAdmin?: BoolWithAggregatesFilter<"User"> | boolean
    status?: EnumUserStatusWithAggregatesFilter<"User"> | $Enums.UserStatus
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type AdminWhereInput = {
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    userId?: StringFilter<"Admin"> | string
    employeeId?: StringFilter<"Admin"> | string
    firstName?: StringNullableFilter<"Admin"> | string | null
    lastName?: StringNullableFilter<"Admin"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AdminOrderByWithRelationInput = {
    userId?: SortOrder
    employeeId?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AdminWhereUniqueInput = Prisma.AtLeast<{
    userId?: string
    employeeId?: string
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    firstName?: StringNullableFilter<"Admin"> | string | null
    lastName?: StringNullableFilter<"Admin"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "userId" | "employeeId">

  export type AdminOrderByWithAggregationInput = {
    userId?: SortOrder
    employeeId?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    _count?: AdminCountOrderByAggregateInput
    _max?: AdminMaxOrderByAggregateInput
    _min?: AdminMinOrderByAggregateInput
  }

  export type AdminScalarWhereWithAggregatesInput = {
    AND?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    OR?: AdminScalarWhereWithAggregatesInput[]
    NOT?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"Admin"> | string
    employeeId?: StringWithAggregatesFilter<"Admin"> | string
    firstName?: StringNullableWithAggregatesFilter<"Admin"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"Admin"> | string | null
  }

  export type ManagerWhereInput = {
    AND?: ManagerWhereInput | ManagerWhereInput[]
    OR?: ManagerWhereInput[]
    NOT?: ManagerWhereInput | ManagerWhereInput[]
    userId?: StringFilter<"Manager"> | string
    firstName?: StringFilter<"Manager"> | string
    lastName?: StringFilter<"Manager"> | string
    employeeId?: StringFilter<"Manager"> | string
    aadharId?: StringFilter<"Manager"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    bankDetails?: XOR<BankDetailsNullableScalarRelationFilter, BankDetailsWhereInput> | null
  }

  export type ManagerOrderByWithRelationInput = {
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    employeeId?: SortOrder
    aadharId?: SortOrder
    user?: UserOrderByWithRelationInput
    bankDetails?: BankDetailsOrderByWithRelationInput
  }

  export type ManagerWhereUniqueInput = Prisma.AtLeast<{
    userId?: string
    employeeId?: string
    aadharId?: string
    AND?: ManagerWhereInput | ManagerWhereInput[]
    OR?: ManagerWhereInput[]
    NOT?: ManagerWhereInput | ManagerWhereInput[]
    firstName?: StringFilter<"Manager"> | string
    lastName?: StringFilter<"Manager"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    bankDetails?: XOR<BankDetailsNullableScalarRelationFilter, BankDetailsWhereInput> | null
  }, "userId" | "employeeId" | "aadharId">

  export type ManagerOrderByWithAggregationInput = {
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    employeeId?: SortOrder
    aadharId?: SortOrder
    _count?: ManagerCountOrderByAggregateInput
    _max?: ManagerMaxOrderByAggregateInput
    _min?: ManagerMinOrderByAggregateInput
  }

  export type ManagerScalarWhereWithAggregatesInput = {
    AND?: ManagerScalarWhereWithAggregatesInput | ManagerScalarWhereWithAggregatesInput[]
    OR?: ManagerScalarWhereWithAggregatesInput[]
    NOT?: ManagerScalarWhereWithAggregatesInput | ManagerScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"Manager"> | string
    firstName?: StringWithAggregatesFilter<"Manager"> | string
    lastName?: StringWithAggregatesFilter<"Manager"> | string
    employeeId?: StringWithAggregatesFilter<"Manager"> | string
    aadharId?: StringWithAggregatesFilter<"Manager"> | string
  }

  export type TechnicianWhereInput = {
    AND?: TechnicianWhereInput | TechnicianWhereInput[]
    OR?: TechnicianWhereInput[]
    NOT?: TechnicianWhereInput | TechnicianWhereInput[]
    userId?: StringFilter<"Technician"> | string
    firstName?: StringFilter<"Technician"> | string
    lastName?: StringFilter<"Technician"> | string
    employeeId?: StringFilter<"Technician"> | string
    aadharId?: StringFilter<"Technician"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    bankDetails?: XOR<BankDetailsNullableScalarRelationFilter, BankDetailsWhereInput> | null
  }

  export type TechnicianOrderByWithRelationInput = {
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    employeeId?: SortOrder
    aadharId?: SortOrder
    user?: UserOrderByWithRelationInput
    bankDetails?: BankDetailsOrderByWithRelationInput
  }

  export type TechnicianWhereUniqueInput = Prisma.AtLeast<{
    userId?: string
    employeeId?: string
    aadharId?: string
    AND?: TechnicianWhereInput | TechnicianWhereInput[]
    OR?: TechnicianWhereInput[]
    NOT?: TechnicianWhereInput | TechnicianWhereInput[]
    firstName?: StringFilter<"Technician"> | string
    lastName?: StringFilter<"Technician"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    bankDetails?: XOR<BankDetailsNullableScalarRelationFilter, BankDetailsWhereInput> | null
  }, "userId" | "employeeId" | "aadharId">

  export type TechnicianOrderByWithAggregationInput = {
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    employeeId?: SortOrder
    aadharId?: SortOrder
    _count?: TechnicianCountOrderByAggregateInput
    _max?: TechnicianMaxOrderByAggregateInput
    _min?: TechnicianMinOrderByAggregateInput
  }

  export type TechnicianScalarWhereWithAggregatesInput = {
    AND?: TechnicianScalarWhereWithAggregatesInput | TechnicianScalarWhereWithAggregatesInput[]
    OR?: TechnicianScalarWhereWithAggregatesInput[]
    NOT?: TechnicianScalarWhereWithAggregatesInput | TechnicianScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"Technician"> | string
    firstName?: StringWithAggregatesFilter<"Technician"> | string
    lastName?: StringWithAggregatesFilter<"Technician"> | string
    employeeId?: StringWithAggregatesFilter<"Technician"> | string
    aadharId?: StringWithAggregatesFilter<"Technician"> | string
  }

  export type FieldExecutiveWhereInput = {
    AND?: FieldExecutiveWhereInput | FieldExecutiveWhereInput[]
    OR?: FieldExecutiveWhereInput[]
    NOT?: FieldExecutiveWhereInput | FieldExecutiveWhereInput[]
    userId?: StringFilter<"FieldExecutive"> | string
    firstName?: StringFilter<"FieldExecutive"> | string
    lastName?: StringFilter<"FieldExecutive"> | string
    employeeId?: StringFilter<"FieldExecutive"> | string
    aadharId?: StringFilter<"FieldExecutive"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    bankDetails?: XOR<BankDetailsNullableScalarRelationFilter, BankDetailsWhereInput> | null
  }

  export type FieldExecutiveOrderByWithRelationInput = {
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    employeeId?: SortOrder
    aadharId?: SortOrder
    user?: UserOrderByWithRelationInput
    bankDetails?: BankDetailsOrderByWithRelationInput
  }

  export type FieldExecutiveWhereUniqueInput = Prisma.AtLeast<{
    userId?: string
    employeeId?: string
    aadharId?: string
    AND?: FieldExecutiveWhereInput | FieldExecutiveWhereInput[]
    OR?: FieldExecutiveWhereInput[]
    NOT?: FieldExecutiveWhereInput | FieldExecutiveWhereInput[]
    firstName?: StringFilter<"FieldExecutive"> | string
    lastName?: StringFilter<"FieldExecutive"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    bankDetails?: XOR<BankDetailsNullableScalarRelationFilter, BankDetailsWhereInput> | null
  }, "userId" | "employeeId" | "aadharId">

  export type FieldExecutiveOrderByWithAggregationInput = {
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    employeeId?: SortOrder
    aadharId?: SortOrder
    _count?: FieldExecutiveCountOrderByAggregateInput
    _max?: FieldExecutiveMaxOrderByAggregateInput
    _min?: FieldExecutiveMinOrderByAggregateInput
  }

  export type FieldExecutiveScalarWhereWithAggregatesInput = {
    AND?: FieldExecutiveScalarWhereWithAggregatesInput | FieldExecutiveScalarWhereWithAggregatesInput[]
    OR?: FieldExecutiveScalarWhereWithAggregatesInput[]
    NOT?: FieldExecutiveScalarWhereWithAggregatesInput | FieldExecutiveScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"FieldExecutive"> | string
    firstName?: StringWithAggregatesFilter<"FieldExecutive"> | string
    lastName?: StringWithAggregatesFilter<"FieldExecutive"> | string
    employeeId?: StringWithAggregatesFilter<"FieldExecutive"> | string
    aadharId?: StringWithAggregatesFilter<"FieldExecutive"> | string
  }

  export type SalesExecutiveWhereInput = {
    AND?: SalesExecutiveWhereInput | SalesExecutiveWhereInput[]
    OR?: SalesExecutiveWhereInput[]
    NOT?: SalesExecutiveWhereInput | SalesExecutiveWhereInput[]
    userId?: StringFilter<"SalesExecutive"> | string
    firstName?: StringFilter<"SalesExecutive"> | string
    lastName?: StringFilter<"SalesExecutive"> | string
    employeeId?: StringFilter<"SalesExecutive"> | string
    aadharId?: StringFilter<"SalesExecutive"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    bankDetails?: XOR<BankDetailsNullableScalarRelationFilter, BankDetailsWhereInput> | null
  }

  export type SalesExecutiveOrderByWithRelationInput = {
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    employeeId?: SortOrder
    aadharId?: SortOrder
    user?: UserOrderByWithRelationInput
    bankDetails?: BankDetailsOrderByWithRelationInput
  }

  export type SalesExecutiveWhereUniqueInput = Prisma.AtLeast<{
    userId?: string
    employeeId?: string
    aadharId?: string
    AND?: SalesExecutiveWhereInput | SalesExecutiveWhereInput[]
    OR?: SalesExecutiveWhereInput[]
    NOT?: SalesExecutiveWhereInput | SalesExecutiveWhereInput[]
    firstName?: StringFilter<"SalesExecutive"> | string
    lastName?: StringFilter<"SalesExecutive"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    bankDetails?: XOR<BankDetailsNullableScalarRelationFilter, BankDetailsWhereInput> | null
  }, "userId" | "employeeId" | "aadharId">

  export type SalesExecutiveOrderByWithAggregationInput = {
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    employeeId?: SortOrder
    aadharId?: SortOrder
    _count?: SalesExecutiveCountOrderByAggregateInput
    _max?: SalesExecutiveMaxOrderByAggregateInput
    _min?: SalesExecutiveMinOrderByAggregateInput
  }

  export type SalesExecutiveScalarWhereWithAggregatesInput = {
    AND?: SalesExecutiveScalarWhereWithAggregatesInput | SalesExecutiveScalarWhereWithAggregatesInput[]
    OR?: SalesExecutiveScalarWhereWithAggregatesInput[]
    NOT?: SalesExecutiveScalarWhereWithAggregatesInput | SalesExecutiveScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"SalesExecutive"> | string
    firstName?: StringWithAggregatesFilter<"SalesExecutive"> | string
    lastName?: StringWithAggregatesFilter<"SalesExecutive"> | string
    employeeId?: StringWithAggregatesFilter<"SalesExecutive"> | string
    aadharId?: StringWithAggregatesFilter<"SalesExecutive"> | string
  }

  export type StoreWhereInput = {
    AND?: StoreWhereInput | StoreWhereInput[]
    OR?: StoreWhereInput[]
    NOT?: StoreWhereInput | StoreWhereInput[]
    userId?: StringFilter<"Store"> | string
    storeId?: StringFilter<"Store"> | string
    storeName?: StringFilter<"Store"> | string
    ownerName?: StringFilter<"Store"> | string
    ownerPhone?: StringFilter<"Store"> | string
    ownerEmail?: StringFilter<"Store"> | string
    createdAt?: DateTimeFilter<"Store"> | Date | string
    updatedAt?: DateTimeFilter<"Store"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    address?: XOR<AddressNullableScalarRelationFilter, AddressWhereInput> | null
    bankDetails?: XOR<BankDetailsNullableScalarRelationFilter, BankDetailsWhereInput> | null
  }

  export type StoreOrderByWithRelationInput = {
    userId?: SortOrder
    storeId?: SortOrder
    storeName?: SortOrder
    ownerName?: SortOrder
    ownerPhone?: SortOrder
    ownerEmail?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    address?: AddressOrderByWithRelationInput
    bankDetails?: BankDetailsOrderByWithRelationInput
  }

  export type StoreWhereUniqueInput = Prisma.AtLeast<{
    userId?: string
    storeId?: string
    AND?: StoreWhereInput | StoreWhereInput[]
    OR?: StoreWhereInput[]
    NOT?: StoreWhereInput | StoreWhereInput[]
    storeName?: StringFilter<"Store"> | string
    ownerName?: StringFilter<"Store"> | string
    ownerPhone?: StringFilter<"Store"> | string
    ownerEmail?: StringFilter<"Store"> | string
    createdAt?: DateTimeFilter<"Store"> | Date | string
    updatedAt?: DateTimeFilter<"Store"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    address?: XOR<AddressNullableScalarRelationFilter, AddressWhereInput> | null
    bankDetails?: XOR<BankDetailsNullableScalarRelationFilter, BankDetailsWhereInput> | null
  }, "userId" | "storeId">

  export type StoreOrderByWithAggregationInput = {
    userId?: SortOrder
    storeId?: SortOrder
    storeName?: SortOrder
    ownerName?: SortOrder
    ownerPhone?: SortOrder
    ownerEmail?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StoreCountOrderByAggregateInput
    _max?: StoreMaxOrderByAggregateInput
    _min?: StoreMinOrderByAggregateInput
  }

  export type StoreScalarWhereWithAggregatesInput = {
    AND?: StoreScalarWhereWithAggregatesInput | StoreScalarWhereWithAggregatesInput[]
    OR?: StoreScalarWhereWithAggregatesInput[]
    NOT?: StoreScalarWhereWithAggregatesInput | StoreScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"Store"> | string
    storeId?: StringWithAggregatesFilter<"Store"> | string
    storeName?: StringWithAggregatesFilter<"Store"> | string
    ownerName?: StringWithAggregatesFilter<"Store"> | string
    ownerPhone?: StringWithAggregatesFilter<"Store"> | string
    ownerEmail?: StringWithAggregatesFilter<"Store"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Store"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Store"> | Date | string
  }

  export type BankDetailsWhereInput = {
    AND?: BankDetailsWhereInput | BankDetailsWhereInput[]
    OR?: BankDetailsWhereInput[]
    NOT?: BankDetailsWhereInput | BankDetailsWhereInput[]
    id?: StringFilter<"BankDetails"> | string
    accountNumber?: StringNullableFilter<"BankDetails"> | string | null
    ifsc?: StringNullableFilter<"BankDetails"> | string | null
    bankName?: StringNullableFilter<"BankDetails"> | string | null
    beneficiaryName?: StringNullableFilter<"BankDetails"> | string | null
    upiId?: StringNullableFilter<"BankDetails"> | string | null
    managerId?: StringNullableFilter<"BankDetails"> | string | null
    technicianId?: StringNullableFilter<"BankDetails"> | string | null
    fieldExecId?: StringNullableFilter<"BankDetails"> | string | null
    salesExecId?: StringNullableFilter<"BankDetails"> | string | null
    storeId?: StringNullableFilter<"BankDetails"> | string | null
    manager?: XOR<ManagerNullableScalarRelationFilter, ManagerWhereInput> | null
    technician?: XOR<TechnicianNullableScalarRelationFilter, TechnicianWhereInput> | null
    fieldExecutive?: XOR<FieldExecutiveNullableScalarRelationFilter, FieldExecutiveWhereInput> | null
    salesExecutive?: XOR<SalesExecutiveNullableScalarRelationFilter, SalesExecutiveWhereInput> | null
    store?: XOR<StoreNullableScalarRelationFilter, StoreWhereInput> | null
  }

  export type BankDetailsOrderByWithRelationInput = {
    id?: SortOrder
    accountNumber?: SortOrderInput | SortOrder
    ifsc?: SortOrderInput | SortOrder
    bankName?: SortOrderInput | SortOrder
    beneficiaryName?: SortOrderInput | SortOrder
    upiId?: SortOrderInput | SortOrder
    managerId?: SortOrderInput | SortOrder
    technicianId?: SortOrderInput | SortOrder
    fieldExecId?: SortOrderInput | SortOrder
    salesExecId?: SortOrderInput | SortOrder
    storeId?: SortOrderInput | SortOrder
    manager?: ManagerOrderByWithRelationInput
    technician?: TechnicianOrderByWithRelationInput
    fieldExecutive?: FieldExecutiveOrderByWithRelationInput
    salesExecutive?: SalesExecutiveOrderByWithRelationInput
    store?: StoreOrderByWithRelationInput
  }

  export type BankDetailsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    managerId?: string
    technicianId?: string
    fieldExecId?: string
    salesExecId?: string
    storeId?: string
    AND?: BankDetailsWhereInput | BankDetailsWhereInput[]
    OR?: BankDetailsWhereInput[]
    NOT?: BankDetailsWhereInput | BankDetailsWhereInput[]
    accountNumber?: StringNullableFilter<"BankDetails"> | string | null
    ifsc?: StringNullableFilter<"BankDetails"> | string | null
    bankName?: StringNullableFilter<"BankDetails"> | string | null
    beneficiaryName?: StringNullableFilter<"BankDetails"> | string | null
    upiId?: StringNullableFilter<"BankDetails"> | string | null
    manager?: XOR<ManagerNullableScalarRelationFilter, ManagerWhereInput> | null
    technician?: XOR<TechnicianNullableScalarRelationFilter, TechnicianWhereInput> | null
    fieldExecutive?: XOR<FieldExecutiveNullableScalarRelationFilter, FieldExecutiveWhereInput> | null
    salesExecutive?: XOR<SalesExecutiveNullableScalarRelationFilter, SalesExecutiveWhereInput> | null
    store?: XOR<StoreNullableScalarRelationFilter, StoreWhereInput> | null
  }, "id" | "managerId" | "technicianId" | "fieldExecId" | "salesExecId" | "storeId">

  export type BankDetailsOrderByWithAggregationInput = {
    id?: SortOrder
    accountNumber?: SortOrderInput | SortOrder
    ifsc?: SortOrderInput | SortOrder
    bankName?: SortOrderInput | SortOrder
    beneficiaryName?: SortOrderInput | SortOrder
    upiId?: SortOrderInput | SortOrder
    managerId?: SortOrderInput | SortOrder
    technicianId?: SortOrderInput | SortOrder
    fieldExecId?: SortOrderInput | SortOrder
    salesExecId?: SortOrderInput | SortOrder
    storeId?: SortOrderInput | SortOrder
    _count?: BankDetailsCountOrderByAggregateInput
    _max?: BankDetailsMaxOrderByAggregateInput
    _min?: BankDetailsMinOrderByAggregateInput
  }

  export type BankDetailsScalarWhereWithAggregatesInput = {
    AND?: BankDetailsScalarWhereWithAggregatesInput | BankDetailsScalarWhereWithAggregatesInput[]
    OR?: BankDetailsScalarWhereWithAggregatesInput[]
    NOT?: BankDetailsScalarWhereWithAggregatesInput | BankDetailsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BankDetails"> | string
    accountNumber?: StringNullableWithAggregatesFilter<"BankDetails"> | string | null
    ifsc?: StringNullableWithAggregatesFilter<"BankDetails"> | string | null
    bankName?: StringNullableWithAggregatesFilter<"BankDetails"> | string | null
    beneficiaryName?: StringNullableWithAggregatesFilter<"BankDetails"> | string | null
    upiId?: StringNullableWithAggregatesFilter<"BankDetails"> | string | null
    managerId?: StringNullableWithAggregatesFilter<"BankDetails"> | string | null
    technicianId?: StringNullableWithAggregatesFilter<"BankDetails"> | string | null
    fieldExecId?: StringNullableWithAggregatesFilter<"BankDetails"> | string | null
    salesExecId?: StringNullableWithAggregatesFilter<"BankDetails"> | string | null
    storeId?: StringNullableWithAggregatesFilter<"BankDetails"> | string | null
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    device?: StringNullableFilter<"Session"> | string | null
    browser?: StringNullableFilter<"Session"> | string | null
    os?: StringNullableFilter<"Session"> | string | null
    location?: StringNullableFilter<"Session"> | string | null
    latitude?: FloatNullableFilter<"Session"> | number | null
    longitude?: FloatNullableFilter<"Session"> | number | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    device?: SortOrderInput | SortOrder
    browser?: SortOrderInput | SortOrder
    os?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    device?: StringNullableFilter<"Session"> | string | null
    browser?: StringNullableFilter<"Session"> | string | null
    os?: StringNullableFilter<"Session"> | string | null
    location?: StringNullableFilter<"Session"> | string | null
    latitude?: FloatNullableFilter<"Session"> | number | null
    longitude?: FloatNullableFilter<"Session"> | number | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    device?: SortOrderInput | SortOrder
    browser?: SortOrderInput | SortOrder
    os?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    _count?: SessionCountOrderByAggregateInput
    _avg?: SessionAvgOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
    _sum?: SessionSumOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    ipAddress?: StringNullableWithAggregatesFilter<"Session"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"Session"> | string | null
    device?: StringNullableWithAggregatesFilter<"Session"> | string | null
    browser?: StringNullableWithAggregatesFilter<"Session"> | string | null
    os?: StringNullableWithAggregatesFilter<"Session"> | string | null
    location?: StringNullableWithAggregatesFilter<"Session"> | string | null
    latitude?: FloatNullableWithAggregatesFilter<"Session"> | number | null
    longitude?: FloatNullableWithAggregatesFilter<"Session"> | number | null
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    body?: StringFilter<"Notification"> | string
    read?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    body?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    body?: StringFilter<"Notification"> | string
    read?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    body?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    userId?: StringWithAggregatesFilter<"Notification"> | string
    title?: StringWithAggregatesFilter<"Notification"> | string
    body?: StringWithAggregatesFilter<"Notification"> | string
    read?: BoolWithAggregatesFilter<"Notification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type DeviceTestWhereInput = {
    AND?: DeviceTestWhereInput | DeviceTestWhereInput[]
    OR?: DeviceTestWhereInput[]
    NOT?: DeviceTestWhereInput | DeviceTestWhereInput[]
    id?: StringFilter<"DeviceTest"> | string
    testId?: StringFilter<"DeviceTest"> | string
    employeeId?: StringNullableFilter<"DeviceTest"> | string | null
    imageUrl?: StringNullableFilter<"DeviceTest"> | string | null
    expiresAt?: DateTimeFilter<"DeviceTest"> | Date | string
    device?: JsonFilter<"DeviceTest">
    imei1?: StringNullableFilter<"DeviceTest"> | string | null
    imei2?: StringNullableFilter<"DeviceTest"> | string | null
    createdAt?: DateTimeFilter<"DeviceTest"> | Date | string
    connectivityTestResults?: ConnectivityTestResultListRelationFilter
    simTestResults?: SimTestResultListRelationFilter
    deviceTestResults?: DeviceTestResultListRelationFilter
    screenTest?: XOR<ScreenTestNullableScalarRelationFilter, ScreenTestWhereInput> | null
    audioTest?: XOR<AudioTestNullableScalarRelationFilter, AudioTestWhereInput> | null
    proximitySensorTest?: XOR<ProximitySensorTestNullableScalarRelationFilter, ProximitySensorTestWhereInput> | null
    cameraTest?: XOR<CameraTestNullableScalarRelationFilter, CameraTestWhereInput> | null
    fingerprintTest?: XOR<FingerprintTestNullableScalarRelationFilter, FingerprintTestWhereInput> | null
    usbTest?: XOR<UsbTestNullableScalarRelationFilter, UsbTestWhereInput> | null
    audioJackTest?: XOR<AudioJackTestNullableScalarRelationFilter, AudioJackTestWhereInput> | null
  }

  export type DeviceTestOrderByWithRelationInput = {
    id?: SortOrder
    testId?: SortOrder
    employeeId?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    expiresAt?: SortOrder
    device?: SortOrder
    imei1?: SortOrderInput | SortOrder
    imei2?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    connectivityTestResults?: ConnectivityTestResultOrderByRelationAggregateInput
    simTestResults?: SimTestResultOrderByRelationAggregateInput
    deviceTestResults?: DeviceTestResultOrderByRelationAggregateInput
    screenTest?: ScreenTestOrderByWithRelationInput
    audioTest?: AudioTestOrderByWithRelationInput
    proximitySensorTest?: ProximitySensorTestOrderByWithRelationInput
    cameraTest?: CameraTestOrderByWithRelationInput
    fingerprintTest?: FingerprintTestOrderByWithRelationInput
    usbTest?: UsbTestOrderByWithRelationInput
    audioJackTest?: AudioJackTestOrderByWithRelationInput
  }

  export type DeviceTestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    testId?: string
    AND?: DeviceTestWhereInput | DeviceTestWhereInput[]
    OR?: DeviceTestWhereInput[]
    NOT?: DeviceTestWhereInput | DeviceTestWhereInput[]
    employeeId?: StringNullableFilter<"DeviceTest"> | string | null
    imageUrl?: StringNullableFilter<"DeviceTest"> | string | null
    expiresAt?: DateTimeFilter<"DeviceTest"> | Date | string
    device?: JsonFilter<"DeviceTest">
    imei1?: StringNullableFilter<"DeviceTest"> | string | null
    imei2?: StringNullableFilter<"DeviceTest"> | string | null
    createdAt?: DateTimeFilter<"DeviceTest"> | Date | string
    connectivityTestResults?: ConnectivityTestResultListRelationFilter
    simTestResults?: SimTestResultListRelationFilter
    deviceTestResults?: DeviceTestResultListRelationFilter
    screenTest?: XOR<ScreenTestNullableScalarRelationFilter, ScreenTestWhereInput> | null
    audioTest?: XOR<AudioTestNullableScalarRelationFilter, AudioTestWhereInput> | null
    proximitySensorTest?: XOR<ProximitySensorTestNullableScalarRelationFilter, ProximitySensorTestWhereInput> | null
    cameraTest?: XOR<CameraTestNullableScalarRelationFilter, CameraTestWhereInput> | null
    fingerprintTest?: XOR<FingerprintTestNullableScalarRelationFilter, FingerprintTestWhereInput> | null
    usbTest?: XOR<UsbTestNullableScalarRelationFilter, UsbTestWhereInput> | null
    audioJackTest?: XOR<AudioJackTestNullableScalarRelationFilter, AudioJackTestWhereInput> | null
  }, "id" | "testId">

  export type DeviceTestOrderByWithAggregationInput = {
    id?: SortOrder
    testId?: SortOrder
    employeeId?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    expiresAt?: SortOrder
    device?: SortOrder
    imei1?: SortOrderInput | SortOrder
    imei2?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: DeviceTestCountOrderByAggregateInput
    _max?: DeviceTestMaxOrderByAggregateInput
    _min?: DeviceTestMinOrderByAggregateInput
  }

  export type DeviceTestScalarWhereWithAggregatesInput = {
    AND?: DeviceTestScalarWhereWithAggregatesInput | DeviceTestScalarWhereWithAggregatesInput[]
    OR?: DeviceTestScalarWhereWithAggregatesInput[]
    NOT?: DeviceTestScalarWhereWithAggregatesInput | DeviceTestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DeviceTest"> | string
    testId?: StringWithAggregatesFilter<"DeviceTest"> | string
    employeeId?: StringNullableWithAggregatesFilter<"DeviceTest"> | string | null
    imageUrl?: StringNullableWithAggregatesFilter<"DeviceTest"> | string | null
    expiresAt?: DateTimeWithAggregatesFilter<"DeviceTest"> | Date | string
    device?: JsonWithAggregatesFilter<"DeviceTest">
    imei1?: StringNullableWithAggregatesFilter<"DeviceTest"> | string | null
    imei2?: StringNullableWithAggregatesFilter<"DeviceTest"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DeviceTest"> | Date | string
  }

  export type ConnectivityTestResultWhereInput = {
    AND?: ConnectivityTestResultWhereInput | ConnectivityTestResultWhereInput[]
    OR?: ConnectivityTestResultWhereInput[]
    NOT?: ConnectivityTestResultWhereInput | ConnectivityTestResultWhereInput[]
    id?: StringFilter<"ConnectivityTestResult"> | string
    name?: StringFilter<"ConnectivityTestResult"> | string
    status?: BoolFilter<"ConnectivityTestResult"> | boolean
    message?: StringNullableFilter<"ConnectivityTestResult"> | string | null
    timestamp?: DateTimeNullableFilter<"ConnectivityTestResult"> | Date | string | null
    deviceTestId?: StringFilter<"ConnectivityTestResult"> | string
    deviceTest?: XOR<DeviceTestScalarRelationFilter, DeviceTestWhereInput>
  }

  export type ConnectivityTestResultOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    message?: SortOrderInput | SortOrder
    timestamp?: SortOrderInput | SortOrder
    deviceTestId?: SortOrder
    deviceTest?: DeviceTestOrderByWithRelationInput
  }

  export type ConnectivityTestResultWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ConnectivityTestResultWhereInput | ConnectivityTestResultWhereInput[]
    OR?: ConnectivityTestResultWhereInput[]
    NOT?: ConnectivityTestResultWhereInput | ConnectivityTestResultWhereInput[]
    name?: StringFilter<"ConnectivityTestResult"> | string
    status?: BoolFilter<"ConnectivityTestResult"> | boolean
    message?: StringNullableFilter<"ConnectivityTestResult"> | string | null
    timestamp?: DateTimeNullableFilter<"ConnectivityTestResult"> | Date | string | null
    deviceTestId?: StringFilter<"ConnectivityTestResult"> | string
    deviceTest?: XOR<DeviceTestScalarRelationFilter, DeviceTestWhereInput>
  }, "id">

  export type ConnectivityTestResultOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    message?: SortOrderInput | SortOrder
    timestamp?: SortOrderInput | SortOrder
    deviceTestId?: SortOrder
    _count?: ConnectivityTestResultCountOrderByAggregateInput
    _max?: ConnectivityTestResultMaxOrderByAggregateInput
    _min?: ConnectivityTestResultMinOrderByAggregateInput
  }

  export type ConnectivityTestResultScalarWhereWithAggregatesInput = {
    AND?: ConnectivityTestResultScalarWhereWithAggregatesInput | ConnectivityTestResultScalarWhereWithAggregatesInput[]
    OR?: ConnectivityTestResultScalarWhereWithAggregatesInput[]
    NOT?: ConnectivityTestResultScalarWhereWithAggregatesInput | ConnectivityTestResultScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ConnectivityTestResult"> | string
    name?: StringWithAggregatesFilter<"ConnectivityTestResult"> | string
    status?: BoolWithAggregatesFilter<"ConnectivityTestResult"> | boolean
    message?: StringNullableWithAggregatesFilter<"ConnectivityTestResult"> | string | null
    timestamp?: DateTimeNullableWithAggregatesFilter<"ConnectivityTestResult"> | Date | string | null
    deviceTestId?: StringWithAggregatesFilter<"ConnectivityTestResult"> | string
  }

  export type DeviceTestResultWhereInput = {
    AND?: DeviceTestResultWhereInput | DeviceTestResultWhereInput[]
    OR?: DeviceTestResultWhereInput[]
    NOT?: DeviceTestResultWhereInput | DeviceTestResultWhereInput[]
    id?: StringFilter<"DeviceTestResult"> | string
    name?: StringFilter<"DeviceTestResult"> | string
    status?: BoolFilter<"DeviceTestResult"> | boolean
    message?: StringNullableFilter<"DeviceTestResult"> | string | null
    timestamp?: DateTimeNullableFilter<"DeviceTestResult"> | Date | string | null
    deviceTestId?: StringFilter<"DeviceTestResult"> | string
    deviceTest?: XOR<DeviceTestScalarRelationFilter, DeviceTestWhereInput>
  }

  export type DeviceTestResultOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    message?: SortOrderInput | SortOrder
    timestamp?: SortOrderInput | SortOrder
    deviceTestId?: SortOrder
    deviceTest?: DeviceTestOrderByWithRelationInput
  }

  export type DeviceTestResultWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DeviceTestResultWhereInput | DeviceTestResultWhereInput[]
    OR?: DeviceTestResultWhereInput[]
    NOT?: DeviceTestResultWhereInput | DeviceTestResultWhereInput[]
    name?: StringFilter<"DeviceTestResult"> | string
    status?: BoolFilter<"DeviceTestResult"> | boolean
    message?: StringNullableFilter<"DeviceTestResult"> | string | null
    timestamp?: DateTimeNullableFilter<"DeviceTestResult"> | Date | string | null
    deviceTestId?: StringFilter<"DeviceTestResult"> | string
    deviceTest?: XOR<DeviceTestScalarRelationFilter, DeviceTestWhereInput>
  }, "id">

  export type DeviceTestResultOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    message?: SortOrderInput | SortOrder
    timestamp?: SortOrderInput | SortOrder
    deviceTestId?: SortOrder
    _count?: DeviceTestResultCountOrderByAggregateInput
    _max?: DeviceTestResultMaxOrderByAggregateInput
    _min?: DeviceTestResultMinOrderByAggregateInput
  }

  export type DeviceTestResultScalarWhereWithAggregatesInput = {
    AND?: DeviceTestResultScalarWhereWithAggregatesInput | DeviceTestResultScalarWhereWithAggregatesInput[]
    OR?: DeviceTestResultScalarWhereWithAggregatesInput[]
    NOT?: DeviceTestResultScalarWhereWithAggregatesInput | DeviceTestResultScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DeviceTestResult"> | string
    name?: StringWithAggregatesFilter<"DeviceTestResult"> | string
    status?: BoolWithAggregatesFilter<"DeviceTestResult"> | boolean
    message?: StringNullableWithAggregatesFilter<"DeviceTestResult"> | string | null
    timestamp?: DateTimeNullableWithAggregatesFilter<"DeviceTestResult"> | Date | string | null
    deviceTestId?: StringWithAggregatesFilter<"DeviceTestResult"> | string
  }

  export type SimTestResultWhereInput = {
    AND?: SimTestResultWhereInput | SimTestResultWhereInput[]
    OR?: SimTestResultWhereInput[]
    NOT?: SimTestResultWhereInput | SimTestResultWhereInput[]
    id?: StringFilter<"SimTestResult"> | string
    name?: StringFilter<"SimTestResult"> | string
    status?: BoolFilter<"SimTestResult"> | boolean
    timestamp?: DateTimeNullableFilter<"SimTestResult"> | Date | string | null
    deviceTestId?: StringFilter<"SimTestResult"> | string
    deviceTest?: XOR<DeviceTestScalarRelationFilter, DeviceTestWhereInput>
  }

  export type SimTestResultOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    timestamp?: SortOrderInput | SortOrder
    deviceTestId?: SortOrder
    deviceTest?: DeviceTestOrderByWithRelationInput
  }

  export type SimTestResultWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SimTestResultWhereInput | SimTestResultWhereInput[]
    OR?: SimTestResultWhereInput[]
    NOT?: SimTestResultWhereInput | SimTestResultWhereInput[]
    name?: StringFilter<"SimTestResult"> | string
    status?: BoolFilter<"SimTestResult"> | boolean
    timestamp?: DateTimeNullableFilter<"SimTestResult"> | Date | string | null
    deviceTestId?: StringFilter<"SimTestResult"> | string
    deviceTest?: XOR<DeviceTestScalarRelationFilter, DeviceTestWhereInput>
  }, "id">

  export type SimTestResultOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    timestamp?: SortOrderInput | SortOrder
    deviceTestId?: SortOrder
    _count?: SimTestResultCountOrderByAggregateInput
    _max?: SimTestResultMaxOrderByAggregateInput
    _min?: SimTestResultMinOrderByAggregateInput
  }

  export type SimTestResultScalarWhereWithAggregatesInput = {
    AND?: SimTestResultScalarWhereWithAggregatesInput | SimTestResultScalarWhereWithAggregatesInput[]
    OR?: SimTestResultScalarWhereWithAggregatesInput[]
    NOT?: SimTestResultScalarWhereWithAggregatesInput | SimTestResultScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SimTestResult"> | string
    name?: StringWithAggregatesFilter<"SimTestResult"> | string
    status?: BoolWithAggregatesFilter<"SimTestResult"> | boolean
    timestamp?: DateTimeNullableWithAggregatesFilter<"SimTestResult"> | Date | string | null
    deviceTestId?: StringWithAggregatesFilter<"SimTestResult"> | string
  }

  export type ScreenTestWhereInput = {
    AND?: ScreenTestWhereInput | ScreenTestWhereInput[]
    OR?: ScreenTestWhereInput[]
    NOT?: ScreenTestWhereInput | ScreenTestWhereInput[]
    id?: StringFilter<"ScreenTest"> | string
    multiTouch?: BoolFilter<"ScreenTest"> | boolean
    dotCoverage?: BoolFilter<"ScreenTest"> | boolean
    completed?: BoolFilter<"ScreenTest"> | boolean
    timestamp?: DateTimeNullableFilter<"ScreenTest"> | Date | string | null
    deviceTestId?: StringFilter<"ScreenTest"> | string
    deviceTest?: XOR<DeviceTestScalarRelationFilter, DeviceTestWhereInput>
  }

  export type ScreenTestOrderByWithRelationInput = {
    id?: SortOrder
    multiTouch?: SortOrder
    dotCoverage?: SortOrder
    completed?: SortOrder
    timestamp?: SortOrderInput | SortOrder
    deviceTestId?: SortOrder
    deviceTest?: DeviceTestOrderByWithRelationInput
  }

  export type ScreenTestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    deviceTestId?: string
    AND?: ScreenTestWhereInput | ScreenTestWhereInput[]
    OR?: ScreenTestWhereInput[]
    NOT?: ScreenTestWhereInput | ScreenTestWhereInput[]
    multiTouch?: BoolFilter<"ScreenTest"> | boolean
    dotCoverage?: BoolFilter<"ScreenTest"> | boolean
    completed?: BoolFilter<"ScreenTest"> | boolean
    timestamp?: DateTimeNullableFilter<"ScreenTest"> | Date | string | null
    deviceTest?: XOR<DeviceTestScalarRelationFilter, DeviceTestWhereInput>
  }, "id" | "deviceTestId">

  export type ScreenTestOrderByWithAggregationInput = {
    id?: SortOrder
    multiTouch?: SortOrder
    dotCoverage?: SortOrder
    completed?: SortOrder
    timestamp?: SortOrderInput | SortOrder
    deviceTestId?: SortOrder
    _count?: ScreenTestCountOrderByAggregateInput
    _max?: ScreenTestMaxOrderByAggregateInput
    _min?: ScreenTestMinOrderByAggregateInput
  }

  export type ScreenTestScalarWhereWithAggregatesInput = {
    AND?: ScreenTestScalarWhereWithAggregatesInput | ScreenTestScalarWhereWithAggregatesInput[]
    OR?: ScreenTestScalarWhereWithAggregatesInput[]
    NOT?: ScreenTestScalarWhereWithAggregatesInput | ScreenTestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ScreenTest"> | string
    multiTouch?: BoolWithAggregatesFilter<"ScreenTest"> | boolean
    dotCoverage?: BoolWithAggregatesFilter<"ScreenTest"> | boolean
    completed?: BoolWithAggregatesFilter<"ScreenTest"> | boolean
    timestamp?: DateTimeNullableWithAggregatesFilter<"ScreenTest"> | Date | string | null
    deviceTestId?: StringWithAggregatesFilter<"ScreenTest"> | string
  }

  export type AudioTestWhereInput = {
    AND?: AudioTestWhereInput | AudioTestWhereInput[]
    OR?: AudioTestWhereInput[]
    NOT?: AudioTestWhereInput | AudioTestWhereInput[]
    id?: StringFilter<"AudioTest"> | string
    speaker?: BoolFilter<"AudioTest"> | boolean
    earReceiver?: BoolFilter<"AudioTest"> | boolean
    microphone?: BoolFilter<"AudioTest"> | boolean
    timestamp?: DateTimeNullableFilter<"AudioTest"> | Date | string | null
    deviceTestId?: StringFilter<"AudioTest"> | string
    deviceTest?: XOR<DeviceTestScalarRelationFilter, DeviceTestWhereInput>
  }

  export type AudioTestOrderByWithRelationInput = {
    id?: SortOrder
    speaker?: SortOrder
    earReceiver?: SortOrder
    microphone?: SortOrder
    timestamp?: SortOrderInput | SortOrder
    deviceTestId?: SortOrder
    deviceTest?: DeviceTestOrderByWithRelationInput
  }

  export type AudioTestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    deviceTestId?: string
    AND?: AudioTestWhereInput | AudioTestWhereInput[]
    OR?: AudioTestWhereInput[]
    NOT?: AudioTestWhereInput | AudioTestWhereInput[]
    speaker?: BoolFilter<"AudioTest"> | boolean
    earReceiver?: BoolFilter<"AudioTest"> | boolean
    microphone?: BoolFilter<"AudioTest"> | boolean
    timestamp?: DateTimeNullableFilter<"AudioTest"> | Date | string | null
    deviceTest?: XOR<DeviceTestScalarRelationFilter, DeviceTestWhereInput>
  }, "id" | "deviceTestId">

  export type AudioTestOrderByWithAggregationInput = {
    id?: SortOrder
    speaker?: SortOrder
    earReceiver?: SortOrder
    microphone?: SortOrder
    timestamp?: SortOrderInput | SortOrder
    deviceTestId?: SortOrder
    _count?: AudioTestCountOrderByAggregateInput
    _max?: AudioTestMaxOrderByAggregateInput
    _min?: AudioTestMinOrderByAggregateInput
  }

  export type AudioTestScalarWhereWithAggregatesInput = {
    AND?: AudioTestScalarWhereWithAggregatesInput | AudioTestScalarWhereWithAggregatesInput[]
    OR?: AudioTestScalarWhereWithAggregatesInput[]
    NOT?: AudioTestScalarWhereWithAggregatesInput | AudioTestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AudioTest"> | string
    speaker?: BoolWithAggregatesFilter<"AudioTest"> | boolean
    earReceiver?: BoolWithAggregatesFilter<"AudioTest"> | boolean
    microphone?: BoolWithAggregatesFilter<"AudioTest"> | boolean
    timestamp?: DateTimeNullableWithAggregatesFilter<"AudioTest"> | Date | string | null
    deviceTestId?: StringWithAggregatesFilter<"AudioTest"> | string
  }

  export type ProximitySensorTestWhereInput = {
    AND?: ProximitySensorTestWhereInput | ProximitySensorTestWhereInput[]
    OR?: ProximitySensorTestWhereInput[]
    NOT?: ProximitySensorTestWhereInput | ProximitySensorTestWhereInput[]
    id?: StringFilter<"ProximitySensorTest"> | string
    status?: BoolFilter<"ProximitySensorTest"> | boolean
    message?: StringNullableFilter<"ProximitySensorTest"> | string | null
    timestamp?: DateTimeNullableFilter<"ProximitySensorTest"> | Date | string | null
    deviceTestId?: StringFilter<"ProximitySensorTest"> | string
    deviceTest?: XOR<DeviceTestScalarRelationFilter, DeviceTestWhereInput>
  }

  export type ProximitySensorTestOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrder
    message?: SortOrderInput | SortOrder
    timestamp?: SortOrderInput | SortOrder
    deviceTestId?: SortOrder
    deviceTest?: DeviceTestOrderByWithRelationInput
  }

  export type ProximitySensorTestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    deviceTestId?: string
    AND?: ProximitySensorTestWhereInput | ProximitySensorTestWhereInput[]
    OR?: ProximitySensorTestWhereInput[]
    NOT?: ProximitySensorTestWhereInput | ProximitySensorTestWhereInput[]
    status?: BoolFilter<"ProximitySensorTest"> | boolean
    message?: StringNullableFilter<"ProximitySensorTest"> | string | null
    timestamp?: DateTimeNullableFilter<"ProximitySensorTest"> | Date | string | null
    deviceTest?: XOR<DeviceTestScalarRelationFilter, DeviceTestWhereInput>
  }, "id" | "deviceTestId">

  export type ProximitySensorTestOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrder
    message?: SortOrderInput | SortOrder
    timestamp?: SortOrderInput | SortOrder
    deviceTestId?: SortOrder
    _count?: ProximitySensorTestCountOrderByAggregateInput
    _max?: ProximitySensorTestMaxOrderByAggregateInput
    _min?: ProximitySensorTestMinOrderByAggregateInput
  }

  export type ProximitySensorTestScalarWhereWithAggregatesInput = {
    AND?: ProximitySensorTestScalarWhereWithAggregatesInput | ProximitySensorTestScalarWhereWithAggregatesInput[]
    OR?: ProximitySensorTestScalarWhereWithAggregatesInput[]
    NOT?: ProximitySensorTestScalarWhereWithAggregatesInput | ProximitySensorTestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProximitySensorTest"> | string
    status?: BoolWithAggregatesFilter<"ProximitySensorTest"> | boolean
    message?: StringNullableWithAggregatesFilter<"ProximitySensorTest"> | string | null
    timestamp?: DateTimeNullableWithAggregatesFilter<"ProximitySensorTest"> | Date | string | null
    deviceTestId?: StringWithAggregatesFilter<"ProximitySensorTest"> | string
  }

  export type CameraTestWhereInput = {
    AND?: CameraTestWhereInput | CameraTestWhereInput[]
    OR?: CameraTestWhereInput[]
    NOT?: CameraTestWhereInput | CameraTestWhereInput[]
    id?: StringFilter<"CameraTest"> | string
    frontCamera?: BoolFilter<"CameraTest"> | boolean
    backCamera?: BoolFilter<"CameraTest"> | boolean
    timestamp?: DateTimeNullableFilter<"CameraTest"> | Date | string | null
    deviceTestId?: StringFilter<"CameraTest"> | string
    deviceTest?: XOR<DeviceTestScalarRelationFilter, DeviceTestWhereInput>
  }

  export type CameraTestOrderByWithRelationInput = {
    id?: SortOrder
    frontCamera?: SortOrder
    backCamera?: SortOrder
    timestamp?: SortOrderInput | SortOrder
    deviceTestId?: SortOrder
    deviceTest?: DeviceTestOrderByWithRelationInput
  }

  export type CameraTestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    deviceTestId?: string
    AND?: CameraTestWhereInput | CameraTestWhereInput[]
    OR?: CameraTestWhereInput[]
    NOT?: CameraTestWhereInput | CameraTestWhereInput[]
    frontCamera?: BoolFilter<"CameraTest"> | boolean
    backCamera?: BoolFilter<"CameraTest"> | boolean
    timestamp?: DateTimeNullableFilter<"CameraTest"> | Date | string | null
    deviceTest?: XOR<DeviceTestScalarRelationFilter, DeviceTestWhereInput>
  }, "id" | "deviceTestId">

  export type CameraTestOrderByWithAggregationInput = {
    id?: SortOrder
    frontCamera?: SortOrder
    backCamera?: SortOrder
    timestamp?: SortOrderInput | SortOrder
    deviceTestId?: SortOrder
    _count?: CameraTestCountOrderByAggregateInput
    _max?: CameraTestMaxOrderByAggregateInput
    _min?: CameraTestMinOrderByAggregateInput
  }

  export type CameraTestScalarWhereWithAggregatesInput = {
    AND?: CameraTestScalarWhereWithAggregatesInput | CameraTestScalarWhereWithAggregatesInput[]
    OR?: CameraTestScalarWhereWithAggregatesInput[]
    NOT?: CameraTestScalarWhereWithAggregatesInput | CameraTestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CameraTest"> | string
    frontCamera?: BoolWithAggregatesFilter<"CameraTest"> | boolean
    backCamera?: BoolWithAggregatesFilter<"CameraTest"> | boolean
    timestamp?: DateTimeNullableWithAggregatesFilter<"CameraTest"> | Date | string | null
    deviceTestId?: StringWithAggregatesFilter<"CameraTest"> | string
  }

  export type FingerprintTestWhereInput = {
    AND?: FingerprintTestWhereInput | FingerprintTestWhereInput[]
    OR?: FingerprintTestWhereInput[]
    NOT?: FingerprintTestWhereInput | FingerprintTestWhereInput[]
    id?: StringFilter<"FingerprintTest"> | string
    status?: BoolFilter<"FingerprintTest"> | boolean
    message?: StringNullableFilter<"FingerprintTest"> | string | null
    timestamp?: DateTimeNullableFilter<"FingerprintTest"> | Date | string | null
    deviceTestId?: StringFilter<"FingerprintTest"> | string
    deviceTest?: XOR<DeviceTestScalarRelationFilter, DeviceTestWhereInput>
  }

  export type FingerprintTestOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrder
    message?: SortOrderInput | SortOrder
    timestamp?: SortOrderInput | SortOrder
    deviceTestId?: SortOrder
    deviceTest?: DeviceTestOrderByWithRelationInput
  }

  export type FingerprintTestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    deviceTestId?: string
    AND?: FingerprintTestWhereInput | FingerprintTestWhereInput[]
    OR?: FingerprintTestWhereInput[]
    NOT?: FingerprintTestWhereInput | FingerprintTestWhereInput[]
    status?: BoolFilter<"FingerprintTest"> | boolean
    message?: StringNullableFilter<"FingerprintTest"> | string | null
    timestamp?: DateTimeNullableFilter<"FingerprintTest"> | Date | string | null
    deviceTest?: XOR<DeviceTestScalarRelationFilter, DeviceTestWhereInput>
  }, "id" | "deviceTestId">

  export type FingerprintTestOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrder
    message?: SortOrderInput | SortOrder
    timestamp?: SortOrderInput | SortOrder
    deviceTestId?: SortOrder
    _count?: FingerprintTestCountOrderByAggregateInput
    _max?: FingerprintTestMaxOrderByAggregateInput
    _min?: FingerprintTestMinOrderByAggregateInput
  }

  export type FingerprintTestScalarWhereWithAggregatesInput = {
    AND?: FingerprintTestScalarWhereWithAggregatesInput | FingerprintTestScalarWhereWithAggregatesInput[]
    OR?: FingerprintTestScalarWhereWithAggregatesInput[]
    NOT?: FingerprintTestScalarWhereWithAggregatesInput | FingerprintTestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FingerprintTest"> | string
    status?: BoolWithAggregatesFilter<"FingerprintTest"> | boolean
    message?: StringNullableWithAggregatesFilter<"FingerprintTest"> | string | null
    timestamp?: DateTimeNullableWithAggregatesFilter<"FingerprintTest"> | Date | string | null
    deviceTestId?: StringWithAggregatesFilter<"FingerprintTest"> | string
  }

  export type UsbTestWhereInput = {
    AND?: UsbTestWhereInput | UsbTestWhereInput[]
    OR?: UsbTestWhereInput[]
    NOT?: UsbTestWhereInput | UsbTestWhereInput[]
    id?: StringFilter<"UsbTest"> | string
    status?: BoolFilter<"UsbTest"> | boolean
    message?: StringNullableFilter<"UsbTest"> | string | null
    timestamp?: DateTimeNullableFilter<"UsbTest"> | Date | string | null
    deviceTestId?: StringFilter<"UsbTest"> | string
    deviceTest?: XOR<DeviceTestScalarRelationFilter, DeviceTestWhereInput>
  }

  export type UsbTestOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrder
    message?: SortOrderInput | SortOrder
    timestamp?: SortOrderInput | SortOrder
    deviceTestId?: SortOrder
    deviceTest?: DeviceTestOrderByWithRelationInput
  }

  export type UsbTestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    deviceTestId?: string
    AND?: UsbTestWhereInput | UsbTestWhereInput[]
    OR?: UsbTestWhereInput[]
    NOT?: UsbTestWhereInput | UsbTestWhereInput[]
    status?: BoolFilter<"UsbTest"> | boolean
    message?: StringNullableFilter<"UsbTest"> | string | null
    timestamp?: DateTimeNullableFilter<"UsbTest"> | Date | string | null
    deviceTest?: XOR<DeviceTestScalarRelationFilter, DeviceTestWhereInput>
  }, "id" | "deviceTestId">

  export type UsbTestOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrder
    message?: SortOrderInput | SortOrder
    timestamp?: SortOrderInput | SortOrder
    deviceTestId?: SortOrder
    _count?: UsbTestCountOrderByAggregateInput
    _max?: UsbTestMaxOrderByAggregateInput
    _min?: UsbTestMinOrderByAggregateInput
  }

  export type UsbTestScalarWhereWithAggregatesInput = {
    AND?: UsbTestScalarWhereWithAggregatesInput | UsbTestScalarWhereWithAggregatesInput[]
    OR?: UsbTestScalarWhereWithAggregatesInput[]
    NOT?: UsbTestScalarWhereWithAggregatesInput | UsbTestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UsbTest"> | string
    status?: BoolWithAggregatesFilter<"UsbTest"> | boolean
    message?: StringNullableWithAggregatesFilter<"UsbTest"> | string | null
    timestamp?: DateTimeNullableWithAggregatesFilter<"UsbTest"> | Date | string | null
    deviceTestId?: StringWithAggregatesFilter<"UsbTest"> | string
  }

  export type AudioJackTestWhereInput = {
    AND?: AudioJackTestWhereInput | AudioJackTestWhereInput[]
    OR?: AudioJackTestWhereInput[]
    NOT?: AudioJackTestWhereInput | AudioJackTestWhereInput[]
    id?: StringFilter<"AudioJackTest"> | string
    status?: BoolFilter<"AudioJackTest"> | boolean
    message?: StringNullableFilter<"AudioJackTest"> | string | null
    timestamp?: DateTimeNullableFilter<"AudioJackTest"> | Date | string | null
    deviceTestId?: StringFilter<"AudioJackTest"> | string
    deviceTest?: XOR<DeviceTestScalarRelationFilter, DeviceTestWhereInput>
  }

  export type AudioJackTestOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrder
    message?: SortOrderInput | SortOrder
    timestamp?: SortOrderInput | SortOrder
    deviceTestId?: SortOrder
    deviceTest?: DeviceTestOrderByWithRelationInput
  }

  export type AudioJackTestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    deviceTestId?: string
    AND?: AudioJackTestWhereInput | AudioJackTestWhereInput[]
    OR?: AudioJackTestWhereInput[]
    NOT?: AudioJackTestWhereInput | AudioJackTestWhereInput[]
    status?: BoolFilter<"AudioJackTest"> | boolean
    message?: StringNullableFilter<"AudioJackTest"> | string | null
    timestamp?: DateTimeNullableFilter<"AudioJackTest"> | Date | string | null
    deviceTest?: XOR<DeviceTestScalarRelationFilter, DeviceTestWhereInput>
  }, "id" | "deviceTestId">

  export type AudioJackTestOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrder
    message?: SortOrderInput | SortOrder
    timestamp?: SortOrderInput | SortOrder
    deviceTestId?: SortOrder
    _count?: AudioJackTestCountOrderByAggregateInput
    _max?: AudioJackTestMaxOrderByAggregateInput
    _min?: AudioJackTestMinOrderByAggregateInput
  }

  export type AudioJackTestScalarWhereWithAggregatesInput = {
    AND?: AudioJackTestScalarWhereWithAggregatesInput | AudioJackTestScalarWhereWithAggregatesInput[]
    OR?: AudioJackTestScalarWhereWithAggregatesInput[]
    NOT?: AudioJackTestScalarWhereWithAggregatesInput | AudioJackTestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AudioJackTest"> | string
    status?: BoolWithAggregatesFilter<"AudioJackTest"> | boolean
    message?: StringNullableWithAggregatesFilter<"AudioJackTest"> | string | null
    timestamp?: DateTimeNullableWithAggregatesFilter<"AudioJackTest"> | Date | string | null
    deviceTestId?: StringWithAggregatesFilter<"AudioJackTest"> | string
  }

  export type ManualDiagnosticsResultWhereInput = {
    AND?: ManualDiagnosticsResultWhereInput | ManualDiagnosticsResultWhereInput[]
    OR?: ManualDiagnosticsResultWhereInput[]
    NOT?: ManualDiagnosticsResultWhereInput | ManualDiagnosticsResultWhereInput[]
    id?: StringFilter<"ManualDiagnosticsResult"> | string
    diagnoseId?: StringFilter<"ManualDiagnosticsResult"> | string
    employeeId?: StringNullableFilter<"ManualDiagnosticsResult"> | string | null
    smc?: StringFilter<"ManualDiagnosticsResult"> | string
    variant?: StringFilter<"ManualDiagnosticsResult"> | string
    imei1?: StringNullableFilter<"ManualDiagnosticsResult"> | string | null
    imei2?: StringNullableFilter<"ManualDiagnosticsResult"> | string | null
    screenTouch?: StringFilter<"ManualDiagnosticsResult"> | string
    screenSpot?: StringFilter<"ManualDiagnosticsResult"> | string
    screenLines?: StringFilter<"ManualDiagnosticsResult"> | string
    screenPhysical?: StringFilter<"ManualDiagnosticsResult"> | string
    screenDiscolor?: StringFilter<"ManualDiagnosticsResult"> | string
    screenBubble?: StringFilter<"ManualDiagnosticsResult"> | string
    frontCamera?: StringFilter<"ManualDiagnosticsResult"> | string
    backCamera?: StringFilter<"ManualDiagnosticsResult"> | string
    audioJack?: StringFilter<"ManualDiagnosticsResult"> | string
    wifi?: StringFilter<"ManualDiagnosticsResult"> | string
    gps?: StringFilter<"ManualDiagnosticsResult"> | string
    bluetooth?: StringFilter<"ManualDiagnosticsResult"> | string
    volumeButton?: StringFilter<"ManualDiagnosticsResult"> | string
    flashLight?: StringFilter<"ManualDiagnosticsResult"> | string
    fcImageBlurred?: StringFilter<"ManualDiagnosticsResult"> | string
    bcImageBlurred?: StringFilter<"ManualDiagnosticsResult"> | string
    vibrator?: StringFilter<"ManualDiagnosticsResult"> | string
    battery?: StringFilter<"ManualDiagnosticsResult"> | string
    speaker?: StringFilter<"ManualDiagnosticsResult"> | string
    microphone?: StringFilter<"ManualDiagnosticsResult"> | string
    fingerprint?: StringFilter<"ManualDiagnosticsResult"> | string
    proximity?: StringFilter<"ManualDiagnosticsResult"> | string
    chargingPort?: StringFilter<"ManualDiagnosticsResult"> | string
    powerButton?: StringFilter<"ManualDiagnosticsResult"> | string
    faceLock?: StringFilter<"ManualDiagnosticsResult"> | string
    copyScreen?: StringFilter<"ManualDiagnosticsResult"> | string
    sim?: StringFilter<"ManualDiagnosticsResult"> | string
    physicalScratch?: StringFilter<"ManualDiagnosticsResult"> | string
    physicalDent?: StringFilter<"ManualDiagnosticsResult"> | string
    physicalPanel?: StringFilter<"ManualDiagnosticsResult"> | string
    physicalBent?: StringFilter<"ManualDiagnosticsResult"> | string
    createdAt?: DateTimeFilter<"ManualDiagnosticsResult"> | Date | string
    updatedAt?: DateTimeFilter<"ManualDiagnosticsResult"> | Date | string
  }

  export type ManualDiagnosticsResultOrderByWithRelationInput = {
    id?: SortOrder
    diagnoseId?: SortOrder
    employeeId?: SortOrderInput | SortOrder
    smc?: SortOrder
    variant?: SortOrder
    imei1?: SortOrderInput | SortOrder
    imei2?: SortOrderInput | SortOrder
    screenTouch?: SortOrder
    screenSpot?: SortOrder
    screenLines?: SortOrder
    screenPhysical?: SortOrder
    screenDiscolor?: SortOrder
    screenBubble?: SortOrder
    frontCamera?: SortOrder
    backCamera?: SortOrder
    audioJack?: SortOrder
    wifi?: SortOrder
    gps?: SortOrder
    bluetooth?: SortOrder
    volumeButton?: SortOrder
    flashLight?: SortOrder
    fcImageBlurred?: SortOrder
    bcImageBlurred?: SortOrder
    vibrator?: SortOrder
    battery?: SortOrder
    speaker?: SortOrder
    microphone?: SortOrder
    fingerprint?: SortOrder
    proximity?: SortOrder
    chargingPort?: SortOrder
    powerButton?: SortOrder
    faceLock?: SortOrder
    copyScreen?: SortOrder
    sim?: SortOrder
    physicalScratch?: SortOrder
    physicalDent?: SortOrder
    physicalPanel?: SortOrder
    physicalBent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ManualDiagnosticsResultWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    diagnoseId?: string
    AND?: ManualDiagnosticsResultWhereInput | ManualDiagnosticsResultWhereInput[]
    OR?: ManualDiagnosticsResultWhereInput[]
    NOT?: ManualDiagnosticsResultWhereInput | ManualDiagnosticsResultWhereInput[]
    employeeId?: StringNullableFilter<"ManualDiagnosticsResult"> | string | null
    smc?: StringFilter<"ManualDiagnosticsResult"> | string
    variant?: StringFilter<"ManualDiagnosticsResult"> | string
    imei1?: StringNullableFilter<"ManualDiagnosticsResult"> | string | null
    imei2?: StringNullableFilter<"ManualDiagnosticsResult"> | string | null
    screenTouch?: StringFilter<"ManualDiagnosticsResult"> | string
    screenSpot?: StringFilter<"ManualDiagnosticsResult"> | string
    screenLines?: StringFilter<"ManualDiagnosticsResult"> | string
    screenPhysical?: StringFilter<"ManualDiagnosticsResult"> | string
    screenDiscolor?: StringFilter<"ManualDiagnosticsResult"> | string
    screenBubble?: StringFilter<"ManualDiagnosticsResult"> | string
    frontCamera?: StringFilter<"ManualDiagnosticsResult"> | string
    backCamera?: StringFilter<"ManualDiagnosticsResult"> | string
    audioJack?: StringFilter<"ManualDiagnosticsResult"> | string
    wifi?: StringFilter<"ManualDiagnosticsResult"> | string
    gps?: StringFilter<"ManualDiagnosticsResult"> | string
    bluetooth?: StringFilter<"ManualDiagnosticsResult"> | string
    volumeButton?: StringFilter<"ManualDiagnosticsResult"> | string
    flashLight?: StringFilter<"ManualDiagnosticsResult"> | string
    fcImageBlurred?: StringFilter<"ManualDiagnosticsResult"> | string
    bcImageBlurred?: StringFilter<"ManualDiagnosticsResult"> | string
    vibrator?: StringFilter<"ManualDiagnosticsResult"> | string
    battery?: StringFilter<"ManualDiagnosticsResult"> | string
    speaker?: StringFilter<"ManualDiagnosticsResult"> | string
    microphone?: StringFilter<"ManualDiagnosticsResult"> | string
    fingerprint?: StringFilter<"ManualDiagnosticsResult"> | string
    proximity?: StringFilter<"ManualDiagnosticsResult"> | string
    chargingPort?: StringFilter<"ManualDiagnosticsResult"> | string
    powerButton?: StringFilter<"ManualDiagnosticsResult"> | string
    faceLock?: StringFilter<"ManualDiagnosticsResult"> | string
    copyScreen?: StringFilter<"ManualDiagnosticsResult"> | string
    sim?: StringFilter<"ManualDiagnosticsResult"> | string
    physicalScratch?: StringFilter<"ManualDiagnosticsResult"> | string
    physicalDent?: StringFilter<"ManualDiagnosticsResult"> | string
    physicalPanel?: StringFilter<"ManualDiagnosticsResult"> | string
    physicalBent?: StringFilter<"ManualDiagnosticsResult"> | string
    createdAt?: DateTimeFilter<"ManualDiagnosticsResult"> | Date | string
    updatedAt?: DateTimeFilter<"ManualDiagnosticsResult"> | Date | string
  }, "id" | "diagnoseId">

  export type ManualDiagnosticsResultOrderByWithAggregationInput = {
    id?: SortOrder
    diagnoseId?: SortOrder
    employeeId?: SortOrderInput | SortOrder
    smc?: SortOrder
    variant?: SortOrder
    imei1?: SortOrderInput | SortOrder
    imei2?: SortOrderInput | SortOrder
    screenTouch?: SortOrder
    screenSpot?: SortOrder
    screenLines?: SortOrder
    screenPhysical?: SortOrder
    screenDiscolor?: SortOrder
    screenBubble?: SortOrder
    frontCamera?: SortOrder
    backCamera?: SortOrder
    audioJack?: SortOrder
    wifi?: SortOrder
    gps?: SortOrder
    bluetooth?: SortOrder
    volumeButton?: SortOrder
    flashLight?: SortOrder
    fcImageBlurred?: SortOrder
    bcImageBlurred?: SortOrder
    vibrator?: SortOrder
    battery?: SortOrder
    speaker?: SortOrder
    microphone?: SortOrder
    fingerprint?: SortOrder
    proximity?: SortOrder
    chargingPort?: SortOrder
    powerButton?: SortOrder
    faceLock?: SortOrder
    copyScreen?: SortOrder
    sim?: SortOrder
    physicalScratch?: SortOrder
    physicalDent?: SortOrder
    physicalPanel?: SortOrder
    physicalBent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ManualDiagnosticsResultCountOrderByAggregateInput
    _max?: ManualDiagnosticsResultMaxOrderByAggregateInput
    _min?: ManualDiagnosticsResultMinOrderByAggregateInput
  }

  export type ManualDiagnosticsResultScalarWhereWithAggregatesInput = {
    AND?: ManualDiagnosticsResultScalarWhereWithAggregatesInput | ManualDiagnosticsResultScalarWhereWithAggregatesInput[]
    OR?: ManualDiagnosticsResultScalarWhereWithAggregatesInput[]
    NOT?: ManualDiagnosticsResultScalarWhereWithAggregatesInput | ManualDiagnosticsResultScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ManualDiagnosticsResult"> | string
    diagnoseId?: StringWithAggregatesFilter<"ManualDiagnosticsResult"> | string
    employeeId?: StringNullableWithAggregatesFilter<"ManualDiagnosticsResult"> | string | null
    smc?: StringWithAggregatesFilter<"ManualDiagnosticsResult"> | string
    variant?: StringWithAggregatesFilter<"ManualDiagnosticsResult"> | string
    imei1?: StringNullableWithAggregatesFilter<"ManualDiagnosticsResult"> | string | null
    imei2?: StringNullableWithAggregatesFilter<"ManualDiagnosticsResult"> | string | null
    screenTouch?: StringWithAggregatesFilter<"ManualDiagnosticsResult"> | string
    screenSpot?: StringWithAggregatesFilter<"ManualDiagnosticsResult"> | string
    screenLines?: StringWithAggregatesFilter<"ManualDiagnosticsResult"> | string
    screenPhysical?: StringWithAggregatesFilter<"ManualDiagnosticsResult"> | string
    screenDiscolor?: StringWithAggregatesFilter<"ManualDiagnosticsResult"> | string
    screenBubble?: StringWithAggregatesFilter<"ManualDiagnosticsResult"> | string
    frontCamera?: StringWithAggregatesFilter<"ManualDiagnosticsResult"> | string
    backCamera?: StringWithAggregatesFilter<"ManualDiagnosticsResult"> | string
    audioJack?: StringWithAggregatesFilter<"ManualDiagnosticsResult"> | string
    wifi?: StringWithAggregatesFilter<"ManualDiagnosticsResult"> | string
    gps?: StringWithAggregatesFilter<"ManualDiagnosticsResult"> | string
    bluetooth?: StringWithAggregatesFilter<"ManualDiagnosticsResult"> | string
    volumeButton?: StringWithAggregatesFilter<"ManualDiagnosticsResult"> | string
    flashLight?: StringWithAggregatesFilter<"ManualDiagnosticsResult"> | string
    fcImageBlurred?: StringWithAggregatesFilter<"ManualDiagnosticsResult"> | string
    bcImageBlurred?: StringWithAggregatesFilter<"ManualDiagnosticsResult"> | string
    vibrator?: StringWithAggregatesFilter<"ManualDiagnosticsResult"> | string
    battery?: StringWithAggregatesFilter<"ManualDiagnosticsResult"> | string
    speaker?: StringWithAggregatesFilter<"ManualDiagnosticsResult"> | string
    microphone?: StringWithAggregatesFilter<"ManualDiagnosticsResult"> | string
    fingerprint?: StringWithAggregatesFilter<"ManualDiagnosticsResult"> | string
    proximity?: StringWithAggregatesFilter<"ManualDiagnosticsResult"> | string
    chargingPort?: StringWithAggregatesFilter<"ManualDiagnosticsResult"> | string
    powerButton?: StringWithAggregatesFilter<"ManualDiagnosticsResult"> | string
    faceLock?: StringWithAggregatesFilter<"ManualDiagnosticsResult"> | string
    copyScreen?: StringWithAggregatesFilter<"ManualDiagnosticsResult"> | string
    sim?: StringWithAggregatesFilter<"ManualDiagnosticsResult"> | string
    physicalScratch?: StringWithAggregatesFilter<"ManualDiagnosticsResult"> | string
    physicalDent?: StringWithAggregatesFilter<"ManualDiagnosticsResult"> | string
    physicalPanel?: StringWithAggregatesFilter<"ManualDiagnosticsResult"> | string
    physicalBent?: StringWithAggregatesFilter<"ManualDiagnosticsResult"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ManualDiagnosticsResult"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ManualDiagnosticsResult"> | Date | string
  }

  export type DeclarationWhereInput = {
    AND?: DeclarationWhereInput | DeclarationWhereInput[]
    OR?: DeclarationWhereInput[]
    NOT?: DeclarationWhereInput | DeclarationWhereInput[]
    id?: StringFilter<"Declaration"> | string
    orderId?: StringFilter<"Declaration"> | string
    brand?: StringFilter<"Declaration"> | string
    model?: StringFilter<"Declaration"> | string
    smc?: StringFilter<"Declaration"> | string
    variant?: StringFilter<"Declaration"> | string
    imei1?: StringNullableFilter<"Declaration"> | string | null
    imei2?: StringNullableFilter<"Declaration"> | string | null
    bluetooth?: StringNullableFilter<"Declaration"> | string | null
    gps?: StringNullableFilter<"Declaration"> | string | null
    wifi?: StringNullableFilter<"Declaration"> | string | null
    proximity?: StringNullableFilter<"Declaration"> | string | null
    multiTouch?: StringNullableFilter<"Declaration"> | string | null
    screenCalibration?: StringNullableFilter<"Declaration"> | string | null
    speaker?: StringNullableFilter<"Declaration"> | string | null
    earReceiver?: StringNullableFilter<"Declaration"> | string | null
    microphone?: StringNullableFilter<"Declaration"> | string | null
    frontCamera?: StringNullableFilter<"Declaration"> | string | null
    backCamera?: StringNullableFilter<"Declaration"> | string | null
    sim?: StringNullableFilter<"Declaration"> | string | null
    fingerprint?: StringNullableFilter<"Declaration"> | string | null
    chargingPort?: StringNullableFilter<"Declaration"> | string | null
    audioJack?: StringNullableFilter<"Declaration"> | string | null
    isAccepted?: BoolFilter<"Declaration"> | boolean
    createdAt?: DateTimeFilter<"Declaration"> | Date | string
    updatedAt?: DateTimeFilter<"Declaration"> | Date | string
  }

  export type DeclarationOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    brand?: SortOrder
    model?: SortOrder
    smc?: SortOrder
    variant?: SortOrder
    imei1?: SortOrderInput | SortOrder
    imei2?: SortOrderInput | SortOrder
    bluetooth?: SortOrderInput | SortOrder
    gps?: SortOrderInput | SortOrder
    wifi?: SortOrderInput | SortOrder
    proximity?: SortOrderInput | SortOrder
    multiTouch?: SortOrderInput | SortOrder
    screenCalibration?: SortOrderInput | SortOrder
    speaker?: SortOrderInput | SortOrder
    earReceiver?: SortOrderInput | SortOrder
    microphone?: SortOrderInput | SortOrder
    frontCamera?: SortOrderInput | SortOrder
    backCamera?: SortOrderInput | SortOrder
    sim?: SortOrderInput | SortOrder
    fingerprint?: SortOrderInput | SortOrder
    chargingPort?: SortOrderInput | SortOrder
    audioJack?: SortOrderInput | SortOrder
    isAccepted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeclarationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    orderId?: string
    AND?: DeclarationWhereInput | DeclarationWhereInput[]
    OR?: DeclarationWhereInput[]
    NOT?: DeclarationWhereInput | DeclarationWhereInput[]
    brand?: StringFilter<"Declaration"> | string
    model?: StringFilter<"Declaration"> | string
    smc?: StringFilter<"Declaration"> | string
    variant?: StringFilter<"Declaration"> | string
    imei1?: StringNullableFilter<"Declaration"> | string | null
    imei2?: StringNullableFilter<"Declaration"> | string | null
    bluetooth?: StringNullableFilter<"Declaration"> | string | null
    gps?: StringNullableFilter<"Declaration"> | string | null
    wifi?: StringNullableFilter<"Declaration"> | string | null
    proximity?: StringNullableFilter<"Declaration"> | string | null
    multiTouch?: StringNullableFilter<"Declaration"> | string | null
    screenCalibration?: StringNullableFilter<"Declaration"> | string | null
    speaker?: StringNullableFilter<"Declaration"> | string | null
    earReceiver?: StringNullableFilter<"Declaration"> | string | null
    microphone?: StringNullableFilter<"Declaration"> | string | null
    frontCamera?: StringNullableFilter<"Declaration"> | string | null
    backCamera?: StringNullableFilter<"Declaration"> | string | null
    sim?: StringNullableFilter<"Declaration"> | string | null
    fingerprint?: StringNullableFilter<"Declaration"> | string | null
    chargingPort?: StringNullableFilter<"Declaration"> | string | null
    audioJack?: StringNullableFilter<"Declaration"> | string | null
    isAccepted?: BoolFilter<"Declaration"> | boolean
    createdAt?: DateTimeFilter<"Declaration"> | Date | string
    updatedAt?: DateTimeFilter<"Declaration"> | Date | string
  }, "id" | "orderId">

  export type DeclarationOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    brand?: SortOrder
    model?: SortOrder
    smc?: SortOrder
    variant?: SortOrder
    imei1?: SortOrderInput | SortOrder
    imei2?: SortOrderInput | SortOrder
    bluetooth?: SortOrderInput | SortOrder
    gps?: SortOrderInput | SortOrder
    wifi?: SortOrderInput | SortOrder
    proximity?: SortOrderInput | SortOrder
    multiTouch?: SortOrderInput | SortOrder
    screenCalibration?: SortOrderInput | SortOrder
    speaker?: SortOrderInput | SortOrder
    earReceiver?: SortOrderInput | SortOrder
    microphone?: SortOrderInput | SortOrder
    frontCamera?: SortOrderInput | SortOrder
    backCamera?: SortOrderInput | SortOrder
    sim?: SortOrderInput | SortOrder
    fingerprint?: SortOrderInput | SortOrder
    chargingPort?: SortOrderInput | SortOrder
    audioJack?: SortOrderInput | SortOrder
    isAccepted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DeclarationCountOrderByAggregateInput
    _max?: DeclarationMaxOrderByAggregateInput
    _min?: DeclarationMinOrderByAggregateInput
  }

  export type DeclarationScalarWhereWithAggregatesInput = {
    AND?: DeclarationScalarWhereWithAggregatesInput | DeclarationScalarWhereWithAggregatesInput[]
    OR?: DeclarationScalarWhereWithAggregatesInput[]
    NOT?: DeclarationScalarWhereWithAggregatesInput | DeclarationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Declaration"> | string
    orderId?: StringWithAggregatesFilter<"Declaration"> | string
    brand?: StringWithAggregatesFilter<"Declaration"> | string
    model?: StringWithAggregatesFilter<"Declaration"> | string
    smc?: StringWithAggregatesFilter<"Declaration"> | string
    variant?: StringWithAggregatesFilter<"Declaration"> | string
    imei1?: StringNullableWithAggregatesFilter<"Declaration"> | string | null
    imei2?: StringNullableWithAggregatesFilter<"Declaration"> | string | null
    bluetooth?: StringNullableWithAggregatesFilter<"Declaration"> | string | null
    gps?: StringNullableWithAggregatesFilter<"Declaration"> | string | null
    wifi?: StringNullableWithAggregatesFilter<"Declaration"> | string | null
    proximity?: StringNullableWithAggregatesFilter<"Declaration"> | string | null
    multiTouch?: StringNullableWithAggregatesFilter<"Declaration"> | string | null
    screenCalibration?: StringNullableWithAggregatesFilter<"Declaration"> | string | null
    speaker?: StringNullableWithAggregatesFilter<"Declaration"> | string | null
    earReceiver?: StringNullableWithAggregatesFilter<"Declaration"> | string | null
    microphone?: StringNullableWithAggregatesFilter<"Declaration"> | string | null
    frontCamera?: StringNullableWithAggregatesFilter<"Declaration"> | string | null
    backCamera?: StringNullableWithAggregatesFilter<"Declaration"> | string | null
    sim?: StringNullableWithAggregatesFilter<"Declaration"> | string | null
    fingerprint?: StringNullableWithAggregatesFilter<"Declaration"> | string | null
    chargingPort?: StringNullableWithAggregatesFilter<"Declaration"> | string | null
    audioJack?: StringNullableWithAggregatesFilter<"Declaration"> | string | null
    isAccepted?: BoolWithAggregatesFilter<"Declaration"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Declaration"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Declaration"> | Date | string
  }

  export type AddressWhereInput = {
    AND?: AddressWhereInput | AddressWhereInput[]
    OR?: AddressWhereInput[]
    NOT?: AddressWhereInput | AddressWhereInput[]
    id?: StringFilter<"Address"> | string
    streetAddress?: StringFilter<"Address"> | string
    city?: StringFilter<"Address"> | string
    state?: StringFilter<"Address"> | string
    country?: StringFilter<"Address"> | string
    pinCode?: StringFilter<"Address"> | string
    storeId?: StringFilter<"Address"> | string
    store?: XOR<StoreScalarRelationFilter, StoreWhereInput>
  }

  export type AddressOrderByWithRelationInput = {
    id?: SortOrder
    streetAddress?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    pinCode?: SortOrder
    storeId?: SortOrder
    store?: StoreOrderByWithRelationInput
  }

  export type AddressWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    storeId?: string
    AND?: AddressWhereInput | AddressWhereInput[]
    OR?: AddressWhereInput[]
    NOT?: AddressWhereInput | AddressWhereInput[]
    streetAddress?: StringFilter<"Address"> | string
    city?: StringFilter<"Address"> | string
    state?: StringFilter<"Address"> | string
    country?: StringFilter<"Address"> | string
    pinCode?: StringFilter<"Address"> | string
    store?: XOR<StoreScalarRelationFilter, StoreWhereInput>
  }, "id" | "storeId">

  export type AddressOrderByWithAggregationInput = {
    id?: SortOrder
    streetAddress?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    pinCode?: SortOrder
    storeId?: SortOrder
    _count?: AddressCountOrderByAggregateInput
    _max?: AddressMaxOrderByAggregateInput
    _min?: AddressMinOrderByAggregateInput
  }

  export type AddressScalarWhereWithAggregatesInput = {
    AND?: AddressScalarWhereWithAggregatesInput | AddressScalarWhereWithAggregatesInput[]
    OR?: AddressScalarWhereWithAggregatesInput[]
    NOT?: AddressScalarWhereWithAggregatesInput | AddressScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Address"> | string
    streetAddress?: StringWithAggregatesFilter<"Address"> | string
    city?: StringWithAggregatesFilter<"Address"> | string
    state?: StringWithAggregatesFilter<"Address"> | string
    country?: StringWithAggregatesFilter<"Address"> | string
    pinCode?: StringWithAggregatesFilter<"Address"> | string
    storeId?: StringWithAggregatesFilter<"Address"> | string
  }

  export type OtpWhereInput = {
    AND?: OtpWhereInput | OtpWhereInput[]
    OR?: OtpWhereInput[]
    NOT?: OtpWhereInput | OtpWhereInput[]
    id?: StringFilter<"Otp"> | string
    identifier?: StringFilter<"Otp"> | string
    otp?: StringFilter<"Otp"> | string
    expiresAt?: DateTimeFilter<"Otp"> | Date | string
    used?: BoolFilter<"Otp"> | boolean
    createdAt?: DateTimeFilter<"Otp"> | Date | string
    attempts?: IntFilter<"Otp"> | number
  }

  export type OtpOrderByWithRelationInput = {
    id?: SortOrder
    identifier?: SortOrder
    otp?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
    createdAt?: SortOrder
    attempts?: SortOrder
  }

  export type OtpWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OtpWhereInput | OtpWhereInput[]
    OR?: OtpWhereInput[]
    NOT?: OtpWhereInput | OtpWhereInput[]
    identifier?: StringFilter<"Otp"> | string
    otp?: StringFilter<"Otp"> | string
    expiresAt?: DateTimeFilter<"Otp"> | Date | string
    used?: BoolFilter<"Otp"> | boolean
    createdAt?: DateTimeFilter<"Otp"> | Date | string
    attempts?: IntFilter<"Otp"> | number
  }, "id">

  export type OtpOrderByWithAggregationInput = {
    id?: SortOrder
    identifier?: SortOrder
    otp?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
    createdAt?: SortOrder
    attempts?: SortOrder
    _count?: OtpCountOrderByAggregateInput
    _avg?: OtpAvgOrderByAggregateInput
    _max?: OtpMaxOrderByAggregateInput
    _min?: OtpMinOrderByAggregateInput
    _sum?: OtpSumOrderByAggregateInput
  }

  export type OtpScalarWhereWithAggregatesInput = {
    AND?: OtpScalarWhereWithAggregatesInput | OtpScalarWhereWithAggregatesInput[]
    OR?: OtpScalarWhereWithAggregatesInput[]
    NOT?: OtpScalarWhereWithAggregatesInput | OtpScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Otp"> | string
    identifier?: StringWithAggregatesFilter<"Otp"> | string
    otp?: StringWithAggregatesFilter<"Otp"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Otp"> | Date | string
    used?: BoolWithAggregatesFilter<"Otp"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Otp"> | Date | string
    attempts?: IntWithAggregatesFilter<"Otp"> | number
  }

  export type CustomModelBrandWhereInput = {
    AND?: CustomModelBrandWhereInput | CustomModelBrandWhereInput[]
    OR?: CustomModelBrandWhereInput[]
    NOT?: CustomModelBrandWhereInput | CustomModelBrandWhereInput[]
    id?: StringFilter<"CustomModelBrand"> | string
    name?: StringFilter<"CustomModelBrand"> | string
    logo?: StringNullableFilter<"CustomModelBrand"> | string | null
    apiEndpoint?: StringNullableFilter<"CustomModelBrand"> | string | null
    isActive?: BoolFilter<"CustomModelBrand"> | boolean
    createdAt?: DateTimeFilter<"CustomModelBrand"> | Date | string
    updatedAt?: DateTimeFilter<"CustomModelBrand"> | Date | string
    models?: CustomModelListRelationFilter
  }

  export type CustomModelBrandOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    logo?: SortOrderInput | SortOrder
    apiEndpoint?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    models?: CustomModelOrderByRelationAggregateInput
  }

  export type CustomModelBrandWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: CustomModelBrandWhereInput | CustomModelBrandWhereInput[]
    OR?: CustomModelBrandWhereInput[]
    NOT?: CustomModelBrandWhereInput | CustomModelBrandWhereInput[]
    logo?: StringNullableFilter<"CustomModelBrand"> | string | null
    apiEndpoint?: StringNullableFilter<"CustomModelBrand"> | string | null
    isActive?: BoolFilter<"CustomModelBrand"> | boolean
    createdAt?: DateTimeFilter<"CustomModelBrand"> | Date | string
    updatedAt?: DateTimeFilter<"CustomModelBrand"> | Date | string
    models?: CustomModelListRelationFilter
  }, "id" | "name">

  export type CustomModelBrandOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    logo?: SortOrderInput | SortOrder
    apiEndpoint?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CustomModelBrandCountOrderByAggregateInput
    _max?: CustomModelBrandMaxOrderByAggregateInput
    _min?: CustomModelBrandMinOrderByAggregateInput
  }

  export type CustomModelBrandScalarWhereWithAggregatesInput = {
    AND?: CustomModelBrandScalarWhereWithAggregatesInput | CustomModelBrandScalarWhereWithAggregatesInput[]
    OR?: CustomModelBrandScalarWhereWithAggregatesInput[]
    NOT?: CustomModelBrandScalarWhereWithAggregatesInput | CustomModelBrandScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CustomModelBrand"> | string
    name?: StringWithAggregatesFilter<"CustomModelBrand"> | string
    logo?: StringNullableWithAggregatesFilter<"CustomModelBrand"> | string | null
    apiEndpoint?: StringNullableWithAggregatesFilter<"CustomModelBrand"> | string | null
    isActive?: BoolWithAggregatesFilter<"CustomModelBrand"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"CustomModelBrand"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CustomModelBrand"> | Date | string
  }

  export type CustomModelWhereInput = {
    AND?: CustomModelWhereInput | CustomModelWhereInput[]
    OR?: CustomModelWhereInput[]
    NOT?: CustomModelWhereInput | CustomModelWhereInput[]
    id?: StringFilter<"CustomModel"> | string
    name?: StringFilter<"CustomModel"> | string
    code?: StringFilter<"CustomModel"> | string
    brandId?: StringFilter<"CustomModel"> | string
    isActive?: BoolFilter<"CustomModel"> | boolean
    createdAt?: DateTimeFilter<"CustomModel"> | Date | string
    updatedAt?: DateTimeFilter<"CustomModel"> | Date | string
    brand?: XOR<CustomModelBrandScalarRelationFilter, CustomModelBrandWhereInput>
  }

  export type CustomModelOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    brandId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    brand?: CustomModelBrandOrderByWithRelationInput
  }

  export type CustomModelWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CustomModelWhereInput | CustomModelWhereInput[]
    OR?: CustomModelWhereInput[]
    NOT?: CustomModelWhereInput | CustomModelWhereInput[]
    name?: StringFilter<"CustomModel"> | string
    code?: StringFilter<"CustomModel"> | string
    brandId?: StringFilter<"CustomModel"> | string
    isActive?: BoolFilter<"CustomModel"> | boolean
    createdAt?: DateTimeFilter<"CustomModel"> | Date | string
    updatedAt?: DateTimeFilter<"CustomModel"> | Date | string
    brand?: XOR<CustomModelBrandScalarRelationFilter, CustomModelBrandWhereInput>
  }, "id">

  export type CustomModelOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    brandId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CustomModelCountOrderByAggregateInput
    _max?: CustomModelMaxOrderByAggregateInput
    _min?: CustomModelMinOrderByAggregateInput
  }

  export type CustomModelScalarWhereWithAggregatesInput = {
    AND?: CustomModelScalarWhereWithAggregatesInput | CustomModelScalarWhereWithAggregatesInput[]
    OR?: CustomModelScalarWhereWithAggregatesInput[]
    NOT?: CustomModelScalarWhereWithAggregatesInput | CustomModelScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CustomModel"> | string
    name?: StringWithAggregatesFilter<"CustomModel"> | string
    code?: StringWithAggregatesFilter<"CustomModel"> | string
    brandId?: StringWithAggregatesFilter<"CustomModel"> | string
    isActive?: BoolWithAggregatesFilter<"CustomModel"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"CustomModel"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CustomModel"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    phone: string
    phoneVerified?: boolean | null
    salary?: Decimal | DecimalJsLike | number | string | null
    payoutDate?: number | null
    password: string
    email?: string | null
    dateOfJoining?: Date | string | null
    dateOfTermination?: Date | string | null
    profileImage?: string | null
    aadharFrontImage?: string | null
    aadharBackImage?: string | null
    qualificationImage?: string | null
    VehicleFrontImage?: string | null
    VehicleBackImage?: string | null
    role?: $Enums.Role | null
    storeId?: string | null
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaVerified?: boolean
    createdBy?: string | null
    isAdmin?: boolean
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    manager?: ManagerCreateNestedOneWithoutUserInput
    technician?: TechnicianCreateNestedOneWithoutUserInput
    fieldExecutive?: FieldExecutiveCreateNestedOneWithoutUserInput
    salesExecutive?: SalesExecutiveCreateNestedOneWithoutUserInput
    store?: StoreCreateNestedOneWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    phone: string
    phoneVerified?: boolean | null
    salary?: Decimal | DecimalJsLike | number | string | null
    payoutDate?: number | null
    password: string
    email?: string | null
    dateOfJoining?: Date | string | null
    dateOfTermination?: Date | string | null
    profileImage?: string | null
    aadharFrontImage?: string | null
    aadharBackImage?: string | null
    qualificationImage?: string | null
    VehicleFrontImage?: string | null
    VehicleBackImage?: string | null
    role?: $Enums.Role | null
    storeId?: string | null
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaVerified?: boolean
    createdBy?: string | null
    isAdmin?: boolean
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    manager?: ManagerUncheckedCreateNestedOneWithoutUserInput
    technician?: TechnicianUncheckedCreateNestedOneWithoutUserInput
    fieldExecutive?: FieldExecutiveUncheckedCreateNestedOneWithoutUserInput
    salesExecutive?: SalesExecutiveUncheckedCreateNestedOneWithoutUserInput
    store?: StoreUncheckedCreateNestedOneWithoutUserInput
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    phoneVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payoutDate?: NullableIntFieldUpdateOperationsInput | number | null
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateOfTermination?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    aadharFrontImage?: NullableStringFieldUpdateOperationsInput | string | null
    aadharBackImage?: NullableStringFieldUpdateOperationsInput | string | null
    qualificationImage?: NullableStringFieldUpdateOperationsInput | string | null
    VehicleFrontImage?: NullableStringFieldUpdateOperationsInput | string | null
    VehicleBackImage?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaVerified?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    manager?: ManagerUpdateOneWithoutUserNestedInput
    technician?: TechnicianUpdateOneWithoutUserNestedInput
    fieldExecutive?: FieldExecutiveUpdateOneWithoutUserNestedInput
    salesExecutive?: SalesExecutiveUpdateOneWithoutUserNestedInput
    store?: StoreUpdateOneWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    phoneVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payoutDate?: NullableIntFieldUpdateOperationsInput | number | null
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateOfTermination?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    aadharFrontImage?: NullableStringFieldUpdateOperationsInput | string | null
    aadharBackImage?: NullableStringFieldUpdateOperationsInput | string | null
    qualificationImage?: NullableStringFieldUpdateOperationsInput | string | null
    VehicleFrontImage?: NullableStringFieldUpdateOperationsInput | string | null
    VehicleBackImage?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaVerified?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    manager?: ManagerUncheckedUpdateOneWithoutUserNestedInput
    technician?: TechnicianUncheckedUpdateOneWithoutUserNestedInput
    fieldExecutive?: FieldExecutiveUncheckedUpdateOneWithoutUserNestedInput
    salesExecutive?: SalesExecutiveUncheckedUpdateOneWithoutUserNestedInput
    store?: StoreUncheckedUpdateOneWithoutUserNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    phone: string
    phoneVerified?: boolean | null
    salary?: Decimal | DecimalJsLike | number | string | null
    payoutDate?: number | null
    password: string
    email?: string | null
    dateOfJoining?: Date | string | null
    dateOfTermination?: Date | string | null
    profileImage?: string | null
    aadharFrontImage?: string | null
    aadharBackImage?: string | null
    qualificationImage?: string | null
    VehicleFrontImage?: string | null
    VehicleBackImage?: string | null
    role?: $Enums.Role | null
    storeId?: string | null
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaVerified?: boolean
    createdBy?: string | null
    isAdmin?: boolean
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    phoneVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payoutDate?: NullableIntFieldUpdateOperationsInput | number | null
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateOfTermination?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    aadharFrontImage?: NullableStringFieldUpdateOperationsInput | string | null
    aadharBackImage?: NullableStringFieldUpdateOperationsInput | string | null
    qualificationImage?: NullableStringFieldUpdateOperationsInput | string | null
    VehicleFrontImage?: NullableStringFieldUpdateOperationsInput | string | null
    VehicleBackImage?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaVerified?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    phoneVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payoutDate?: NullableIntFieldUpdateOperationsInput | number | null
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateOfTermination?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    aadharFrontImage?: NullableStringFieldUpdateOperationsInput | string | null
    aadharBackImage?: NullableStringFieldUpdateOperationsInput | string | null
    qualificationImage?: NullableStringFieldUpdateOperationsInput | string | null
    VehicleFrontImage?: NullableStringFieldUpdateOperationsInput | string | null
    VehicleBackImage?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaVerified?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminCreateInput = {
    employeeId: string
    firstName?: string | null
    lastName?: string | null
    user: UserCreateNestedOneWithoutAdminInput
  }

  export type AdminUncheckedCreateInput = {
    userId: string
    employeeId: string
    firstName?: string | null
    lastName?: string | null
  }

  export type AdminUpdateInput = {
    employeeId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdminCreateManyInput = {
    userId: string
    employeeId: string
    firstName?: string | null
    lastName?: string | null
  }

  export type AdminUpdateManyMutationInput = {
    employeeId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdminUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ManagerCreateInput = {
    firstName: string
    lastName: string
    employeeId: string
    aadharId: string
    user: UserCreateNestedOneWithoutManagerInput
    bankDetails?: BankDetailsCreateNestedOneWithoutManagerInput
  }

  export type ManagerUncheckedCreateInput = {
    userId: string
    firstName: string
    lastName: string
    employeeId: string
    aadharId: string
    bankDetails?: BankDetailsUncheckedCreateNestedOneWithoutManagerInput
  }

  export type ManagerUpdateInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    aadharId?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutManagerNestedInput
    bankDetails?: BankDetailsUpdateOneWithoutManagerNestedInput
  }

  export type ManagerUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    aadharId?: StringFieldUpdateOperationsInput | string
    bankDetails?: BankDetailsUncheckedUpdateOneWithoutManagerNestedInput
  }

  export type ManagerCreateManyInput = {
    userId: string
    firstName: string
    lastName: string
    employeeId: string
    aadharId: string
  }

  export type ManagerUpdateManyMutationInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    aadharId?: StringFieldUpdateOperationsInput | string
  }

  export type ManagerUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    aadharId?: StringFieldUpdateOperationsInput | string
  }

  export type TechnicianCreateInput = {
    firstName: string
    lastName: string
    employeeId: string
    aadharId: string
    user: UserCreateNestedOneWithoutTechnicianInput
    bankDetails?: BankDetailsCreateNestedOneWithoutTechnicianInput
  }

  export type TechnicianUncheckedCreateInput = {
    userId: string
    firstName: string
    lastName: string
    employeeId: string
    aadharId: string
    bankDetails?: BankDetailsUncheckedCreateNestedOneWithoutTechnicianInput
  }

  export type TechnicianUpdateInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    aadharId?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutTechnicianNestedInput
    bankDetails?: BankDetailsUpdateOneWithoutTechnicianNestedInput
  }

  export type TechnicianUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    aadharId?: StringFieldUpdateOperationsInput | string
    bankDetails?: BankDetailsUncheckedUpdateOneWithoutTechnicianNestedInput
  }

  export type TechnicianCreateManyInput = {
    userId: string
    firstName: string
    lastName: string
    employeeId: string
    aadharId: string
  }

  export type TechnicianUpdateManyMutationInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    aadharId?: StringFieldUpdateOperationsInput | string
  }

  export type TechnicianUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    aadharId?: StringFieldUpdateOperationsInput | string
  }

  export type FieldExecutiveCreateInput = {
    firstName: string
    lastName: string
    employeeId: string
    aadharId: string
    user: UserCreateNestedOneWithoutFieldExecutiveInput
    bankDetails?: BankDetailsCreateNestedOneWithoutFieldExecutiveInput
  }

  export type FieldExecutiveUncheckedCreateInput = {
    userId: string
    firstName: string
    lastName: string
    employeeId: string
    aadharId: string
    bankDetails?: BankDetailsUncheckedCreateNestedOneWithoutFieldExecutiveInput
  }

  export type FieldExecutiveUpdateInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    aadharId?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutFieldExecutiveNestedInput
    bankDetails?: BankDetailsUpdateOneWithoutFieldExecutiveNestedInput
  }

  export type FieldExecutiveUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    aadharId?: StringFieldUpdateOperationsInput | string
    bankDetails?: BankDetailsUncheckedUpdateOneWithoutFieldExecutiveNestedInput
  }

  export type FieldExecutiveCreateManyInput = {
    userId: string
    firstName: string
    lastName: string
    employeeId: string
    aadharId: string
  }

  export type FieldExecutiveUpdateManyMutationInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    aadharId?: StringFieldUpdateOperationsInput | string
  }

  export type FieldExecutiveUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    aadharId?: StringFieldUpdateOperationsInput | string
  }

  export type SalesExecutiveCreateInput = {
    firstName: string
    lastName: string
    employeeId: string
    aadharId: string
    user: UserCreateNestedOneWithoutSalesExecutiveInput
    bankDetails?: BankDetailsCreateNestedOneWithoutSalesExecutiveInput
  }

  export type SalesExecutiveUncheckedCreateInput = {
    userId: string
    firstName: string
    lastName: string
    employeeId: string
    aadharId: string
    bankDetails?: BankDetailsUncheckedCreateNestedOneWithoutSalesExecutiveInput
  }

  export type SalesExecutiveUpdateInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    aadharId?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutSalesExecutiveNestedInput
    bankDetails?: BankDetailsUpdateOneWithoutSalesExecutiveNestedInput
  }

  export type SalesExecutiveUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    aadharId?: StringFieldUpdateOperationsInput | string
    bankDetails?: BankDetailsUncheckedUpdateOneWithoutSalesExecutiveNestedInput
  }

  export type SalesExecutiveCreateManyInput = {
    userId: string
    firstName: string
    lastName: string
    employeeId: string
    aadharId: string
  }

  export type SalesExecutiveUpdateManyMutationInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    aadharId?: StringFieldUpdateOperationsInput | string
  }

  export type SalesExecutiveUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    aadharId?: StringFieldUpdateOperationsInput | string
  }

  export type StoreCreateInput = {
    storeId: string
    storeName: string
    ownerName: string
    ownerPhone: string
    ownerEmail: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStoreInput
    address?: AddressCreateNestedOneWithoutStoreInput
    bankDetails?: BankDetailsCreateNestedOneWithoutStoreInput
  }

  export type StoreUncheckedCreateInput = {
    userId: string
    storeId: string
    storeName: string
    ownerName: string
    ownerPhone: string
    ownerEmail: string
    createdAt?: Date | string
    updatedAt?: Date | string
    address?: AddressUncheckedCreateNestedOneWithoutStoreInput
    bankDetails?: BankDetailsUncheckedCreateNestedOneWithoutStoreInput
  }

  export type StoreUpdateInput = {
    storeId?: StringFieldUpdateOperationsInput | string
    storeName?: StringFieldUpdateOperationsInput | string
    ownerName?: StringFieldUpdateOperationsInput | string
    ownerPhone?: StringFieldUpdateOperationsInput | string
    ownerEmail?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStoreNestedInput
    address?: AddressUpdateOneWithoutStoreNestedInput
    bankDetails?: BankDetailsUpdateOneWithoutStoreNestedInput
  }

  export type StoreUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    storeName?: StringFieldUpdateOperationsInput | string
    ownerName?: StringFieldUpdateOperationsInput | string
    ownerPhone?: StringFieldUpdateOperationsInput | string
    ownerEmail?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: AddressUncheckedUpdateOneWithoutStoreNestedInput
    bankDetails?: BankDetailsUncheckedUpdateOneWithoutStoreNestedInput
  }

  export type StoreCreateManyInput = {
    userId: string
    storeId: string
    storeName: string
    ownerName: string
    ownerPhone: string
    ownerEmail: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StoreUpdateManyMutationInput = {
    storeId?: StringFieldUpdateOperationsInput | string
    storeName?: StringFieldUpdateOperationsInput | string
    ownerName?: StringFieldUpdateOperationsInput | string
    ownerPhone?: StringFieldUpdateOperationsInput | string
    ownerEmail?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoreUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    storeName?: StringFieldUpdateOperationsInput | string
    ownerName?: StringFieldUpdateOperationsInput | string
    ownerPhone?: StringFieldUpdateOperationsInput | string
    ownerEmail?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankDetailsCreateInput = {
    id?: string
    accountNumber?: string | null
    ifsc?: string | null
    bankName?: string | null
    beneficiaryName?: string | null
    upiId?: string | null
    manager?: ManagerCreateNestedOneWithoutBankDetailsInput
    technician?: TechnicianCreateNestedOneWithoutBankDetailsInput
    fieldExecutive?: FieldExecutiveCreateNestedOneWithoutBankDetailsInput
    salesExecutive?: SalesExecutiveCreateNestedOneWithoutBankDetailsInput
    store?: StoreCreateNestedOneWithoutBankDetailsInput
  }

  export type BankDetailsUncheckedCreateInput = {
    id?: string
    accountNumber?: string | null
    ifsc?: string | null
    bankName?: string | null
    beneficiaryName?: string | null
    upiId?: string | null
    managerId?: string | null
    technicianId?: string | null
    fieldExecId?: string | null
    salesExecId?: string | null
    storeId?: string | null
  }

  export type BankDetailsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ifsc?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    beneficiaryName?: NullableStringFieldUpdateOperationsInput | string | null
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    manager?: ManagerUpdateOneWithoutBankDetailsNestedInput
    technician?: TechnicianUpdateOneWithoutBankDetailsNestedInput
    fieldExecutive?: FieldExecutiveUpdateOneWithoutBankDetailsNestedInput
    salesExecutive?: SalesExecutiveUpdateOneWithoutBankDetailsNestedInput
    store?: StoreUpdateOneWithoutBankDetailsNestedInput
  }

  export type BankDetailsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ifsc?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    beneficiaryName?: NullableStringFieldUpdateOperationsInput | string | null
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    technicianId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldExecId?: NullableStringFieldUpdateOperationsInput | string | null
    salesExecId?: NullableStringFieldUpdateOperationsInput | string | null
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BankDetailsCreateManyInput = {
    id?: string
    accountNumber?: string | null
    ifsc?: string | null
    bankName?: string | null
    beneficiaryName?: string | null
    upiId?: string | null
    managerId?: string | null
    technicianId?: string | null
    fieldExecId?: string | null
    salesExecId?: string | null
    storeId?: string | null
  }

  export type BankDetailsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ifsc?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    beneficiaryName?: NullableStringFieldUpdateOperationsInput | string | null
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BankDetailsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ifsc?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    beneficiaryName?: NullableStringFieldUpdateOperationsInput | string | null
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    technicianId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldExecId?: NullableStringFieldUpdateOperationsInput | string | null
    salesExecId?: NullableStringFieldUpdateOperationsInput | string | null
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionCreateInput = {
    id?: string
    expiresAt: Date | string
    createdAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    device?: string | null
    browser?: string | null
    os?: string | null
    location?: string | null
    latitude?: number | null
    longitude?: number | null
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    userId: string
    expiresAt: Date | string
    createdAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    device?: string | null
    browser?: string | null
    os?: string | null
    location?: string | null
    latitude?: number | null
    longitude?: number | null
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    os?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    os?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type SessionCreateManyInput = {
    id?: string
    userId: string
    expiresAt: Date | string
    createdAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    device?: string | null
    browser?: string | null
    os?: string | null
    location?: string | null
    latitude?: number | null
    longitude?: number | null
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    os?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    os?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type NotificationCreateInput = {
    id?: string
    userId: string
    title: string
    body: string
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    userId: string
    title: string
    body: string
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    userId: string
    title: string
    body: string
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceTestCreateInput = {
    id?: string
    testId: string
    employeeId?: string | null
    imageUrl?: string | null
    expiresAt: Date | string
    device: JsonNullValueInput | InputJsonValue
    imei1?: string | null
    imei2?: string | null
    createdAt?: Date | string
    connectivityTestResults?: ConnectivityTestResultCreateNestedManyWithoutDeviceTestInput
    simTestResults?: SimTestResultCreateNestedManyWithoutDeviceTestInput
    deviceTestResults?: DeviceTestResultCreateNestedManyWithoutDeviceTestInput
    screenTest?: ScreenTestCreateNestedOneWithoutDeviceTestInput
    audioTest?: AudioTestCreateNestedOneWithoutDeviceTestInput
    proximitySensorTest?: ProximitySensorTestCreateNestedOneWithoutDeviceTestInput
    cameraTest?: CameraTestCreateNestedOneWithoutDeviceTestInput
    fingerprintTest?: FingerprintTestCreateNestedOneWithoutDeviceTestInput
    usbTest?: UsbTestCreateNestedOneWithoutDeviceTestInput
    audioJackTest?: AudioJackTestCreateNestedOneWithoutDeviceTestInput
  }

  export type DeviceTestUncheckedCreateInput = {
    id?: string
    testId: string
    employeeId?: string | null
    imageUrl?: string | null
    expiresAt: Date | string
    device: JsonNullValueInput | InputJsonValue
    imei1?: string | null
    imei2?: string | null
    createdAt?: Date | string
    connectivityTestResults?: ConnectivityTestResultUncheckedCreateNestedManyWithoutDeviceTestInput
    simTestResults?: SimTestResultUncheckedCreateNestedManyWithoutDeviceTestInput
    deviceTestResults?: DeviceTestResultUncheckedCreateNestedManyWithoutDeviceTestInput
    screenTest?: ScreenTestUncheckedCreateNestedOneWithoutDeviceTestInput
    audioTest?: AudioTestUncheckedCreateNestedOneWithoutDeviceTestInput
    proximitySensorTest?: ProximitySensorTestUncheckedCreateNestedOneWithoutDeviceTestInput
    cameraTest?: CameraTestUncheckedCreateNestedOneWithoutDeviceTestInput
    fingerprintTest?: FingerprintTestUncheckedCreateNestedOneWithoutDeviceTestInput
    usbTest?: UsbTestUncheckedCreateNestedOneWithoutDeviceTestInput
    audioJackTest?: AudioJackTestUncheckedCreateNestedOneWithoutDeviceTestInput
  }

  export type DeviceTestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    testId?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    device?: JsonNullValueInput | InputJsonValue
    imei1?: NullableStringFieldUpdateOperationsInput | string | null
    imei2?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    connectivityTestResults?: ConnectivityTestResultUpdateManyWithoutDeviceTestNestedInput
    simTestResults?: SimTestResultUpdateManyWithoutDeviceTestNestedInput
    deviceTestResults?: DeviceTestResultUpdateManyWithoutDeviceTestNestedInput
    screenTest?: ScreenTestUpdateOneWithoutDeviceTestNestedInput
    audioTest?: AudioTestUpdateOneWithoutDeviceTestNestedInput
    proximitySensorTest?: ProximitySensorTestUpdateOneWithoutDeviceTestNestedInput
    cameraTest?: CameraTestUpdateOneWithoutDeviceTestNestedInput
    fingerprintTest?: FingerprintTestUpdateOneWithoutDeviceTestNestedInput
    usbTest?: UsbTestUpdateOneWithoutDeviceTestNestedInput
    audioJackTest?: AudioJackTestUpdateOneWithoutDeviceTestNestedInput
  }

  export type DeviceTestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    testId?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    device?: JsonNullValueInput | InputJsonValue
    imei1?: NullableStringFieldUpdateOperationsInput | string | null
    imei2?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    connectivityTestResults?: ConnectivityTestResultUncheckedUpdateManyWithoutDeviceTestNestedInput
    simTestResults?: SimTestResultUncheckedUpdateManyWithoutDeviceTestNestedInput
    deviceTestResults?: DeviceTestResultUncheckedUpdateManyWithoutDeviceTestNestedInput
    screenTest?: ScreenTestUncheckedUpdateOneWithoutDeviceTestNestedInput
    audioTest?: AudioTestUncheckedUpdateOneWithoutDeviceTestNestedInput
    proximitySensorTest?: ProximitySensorTestUncheckedUpdateOneWithoutDeviceTestNestedInput
    cameraTest?: CameraTestUncheckedUpdateOneWithoutDeviceTestNestedInput
    fingerprintTest?: FingerprintTestUncheckedUpdateOneWithoutDeviceTestNestedInput
    usbTest?: UsbTestUncheckedUpdateOneWithoutDeviceTestNestedInput
    audioJackTest?: AudioJackTestUncheckedUpdateOneWithoutDeviceTestNestedInput
  }

  export type DeviceTestCreateManyInput = {
    id?: string
    testId: string
    employeeId?: string | null
    imageUrl?: string | null
    expiresAt: Date | string
    device: JsonNullValueInput | InputJsonValue
    imei1?: string | null
    imei2?: string | null
    createdAt?: Date | string
  }

  export type DeviceTestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    testId?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    device?: JsonNullValueInput | InputJsonValue
    imei1?: NullableStringFieldUpdateOperationsInput | string | null
    imei2?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceTestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    testId?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    device?: JsonNullValueInput | InputJsonValue
    imei1?: NullableStringFieldUpdateOperationsInput | string | null
    imei2?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConnectivityTestResultCreateInput = {
    id?: string
    name: string
    status: boolean
    message?: string | null
    timestamp?: Date | string | null
    deviceTest: DeviceTestCreateNestedOneWithoutConnectivityTestResultsInput
  }

  export type ConnectivityTestResultUncheckedCreateInput = {
    id?: string
    name: string
    status: boolean
    message?: string | null
    timestamp?: Date | string | null
    deviceTestId: string
  }

  export type ConnectivityTestResultUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    message?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceTest?: DeviceTestUpdateOneRequiredWithoutConnectivityTestResultsNestedInput
  }

  export type ConnectivityTestResultUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    message?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceTestId?: StringFieldUpdateOperationsInput | string
  }

  export type ConnectivityTestResultCreateManyInput = {
    id?: string
    name: string
    status: boolean
    message?: string | null
    timestamp?: Date | string | null
    deviceTestId: string
  }

  export type ConnectivityTestResultUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    message?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ConnectivityTestResultUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    message?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceTestId?: StringFieldUpdateOperationsInput | string
  }

  export type DeviceTestResultCreateInput = {
    id?: string
    name: string
    status: boolean
    message?: string | null
    timestamp?: Date | string | null
    deviceTest: DeviceTestCreateNestedOneWithoutDeviceTestResultsInput
  }

  export type DeviceTestResultUncheckedCreateInput = {
    id?: string
    name: string
    status: boolean
    message?: string | null
    timestamp?: Date | string | null
    deviceTestId: string
  }

  export type DeviceTestResultUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    message?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceTest?: DeviceTestUpdateOneRequiredWithoutDeviceTestResultsNestedInput
  }

  export type DeviceTestResultUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    message?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceTestId?: StringFieldUpdateOperationsInput | string
  }

  export type DeviceTestResultCreateManyInput = {
    id?: string
    name: string
    status: boolean
    message?: string | null
    timestamp?: Date | string | null
    deviceTestId: string
  }

  export type DeviceTestResultUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    message?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DeviceTestResultUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    message?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceTestId?: StringFieldUpdateOperationsInput | string
  }

  export type SimTestResultCreateInput = {
    id?: string
    name: string
    status: boolean
    timestamp?: Date | string | null
    deviceTest: DeviceTestCreateNestedOneWithoutSimTestResultsInput
  }

  export type SimTestResultUncheckedCreateInput = {
    id?: string
    name: string
    status: boolean
    timestamp?: Date | string | null
    deviceTestId: string
  }

  export type SimTestResultUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceTest?: DeviceTestUpdateOneRequiredWithoutSimTestResultsNestedInput
  }

  export type SimTestResultUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceTestId?: StringFieldUpdateOperationsInput | string
  }

  export type SimTestResultCreateManyInput = {
    id?: string
    name: string
    status: boolean
    timestamp?: Date | string | null
    deviceTestId: string
  }

  export type SimTestResultUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SimTestResultUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceTestId?: StringFieldUpdateOperationsInput | string
  }

  export type ScreenTestCreateInput = {
    id?: string
    multiTouch: boolean
    dotCoverage: boolean
    completed: boolean
    timestamp?: Date | string | null
    deviceTest: DeviceTestCreateNestedOneWithoutScreenTestInput
  }

  export type ScreenTestUncheckedCreateInput = {
    id?: string
    multiTouch: boolean
    dotCoverage: boolean
    completed: boolean
    timestamp?: Date | string | null
    deviceTestId: string
  }

  export type ScreenTestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    multiTouch?: BoolFieldUpdateOperationsInput | boolean
    dotCoverage?: BoolFieldUpdateOperationsInput | boolean
    completed?: BoolFieldUpdateOperationsInput | boolean
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceTest?: DeviceTestUpdateOneRequiredWithoutScreenTestNestedInput
  }

  export type ScreenTestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    multiTouch?: BoolFieldUpdateOperationsInput | boolean
    dotCoverage?: BoolFieldUpdateOperationsInput | boolean
    completed?: BoolFieldUpdateOperationsInput | boolean
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceTestId?: StringFieldUpdateOperationsInput | string
  }

  export type ScreenTestCreateManyInput = {
    id?: string
    multiTouch: boolean
    dotCoverage: boolean
    completed: boolean
    timestamp?: Date | string | null
    deviceTestId: string
  }

  export type ScreenTestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    multiTouch?: BoolFieldUpdateOperationsInput | boolean
    dotCoverage?: BoolFieldUpdateOperationsInput | boolean
    completed?: BoolFieldUpdateOperationsInput | boolean
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ScreenTestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    multiTouch?: BoolFieldUpdateOperationsInput | boolean
    dotCoverage?: BoolFieldUpdateOperationsInput | boolean
    completed?: BoolFieldUpdateOperationsInput | boolean
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceTestId?: StringFieldUpdateOperationsInput | string
  }

  export type AudioTestCreateInput = {
    id?: string
    speaker: boolean
    earReceiver: boolean
    microphone: boolean
    timestamp?: Date | string | null
    deviceTest: DeviceTestCreateNestedOneWithoutAudioTestInput
  }

  export type AudioTestUncheckedCreateInput = {
    id?: string
    speaker: boolean
    earReceiver: boolean
    microphone: boolean
    timestamp?: Date | string | null
    deviceTestId: string
  }

  export type AudioTestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    speaker?: BoolFieldUpdateOperationsInput | boolean
    earReceiver?: BoolFieldUpdateOperationsInput | boolean
    microphone?: BoolFieldUpdateOperationsInput | boolean
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceTest?: DeviceTestUpdateOneRequiredWithoutAudioTestNestedInput
  }

  export type AudioTestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    speaker?: BoolFieldUpdateOperationsInput | boolean
    earReceiver?: BoolFieldUpdateOperationsInput | boolean
    microphone?: BoolFieldUpdateOperationsInput | boolean
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceTestId?: StringFieldUpdateOperationsInput | string
  }

  export type AudioTestCreateManyInput = {
    id?: string
    speaker: boolean
    earReceiver: boolean
    microphone: boolean
    timestamp?: Date | string | null
    deviceTestId: string
  }

  export type AudioTestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    speaker?: BoolFieldUpdateOperationsInput | boolean
    earReceiver?: BoolFieldUpdateOperationsInput | boolean
    microphone?: BoolFieldUpdateOperationsInput | boolean
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AudioTestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    speaker?: BoolFieldUpdateOperationsInput | boolean
    earReceiver?: BoolFieldUpdateOperationsInput | boolean
    microphone?: BoolFieldUpdateOperationsInput | boolean
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceTestId?: StringFieldUpdateOperationsInput | string
  }

  export type ProximitySensorTestCreateInput = {
    id?: string
    status: boolean
    message?: string | null
    timestamp?: Date | string | null
    deviceTest: DeviceTestCreateNestedOneWithoutProximitySensorTestInput
  }

  export type ProximitySensorTestUncheckedCreateInput = {
    id?: string
    status: boolean
    message?: string | null
    timestamp?: Date | string | null
    deviceTestId: string
  }

  export type ProximitySensorTestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    message?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceTest?: DeviceTestUpdateOneRequiredWithoutProximitySensorTestNestedInput
  }

  export type ProximitySensorTestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    message?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceTestId?: StringFieldUpdateOperationsInput | string
  }

  export type ProximitySensorTestCreateManyInput = {
    id?: string
    status: boolean
    message?: string | null
    timestamp?: Date | string | null
    deviceTestId: string
  }

  export type ProximitySensorTestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    message?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProximitySensorTestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    message?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceTestId?: StringFieldUpdateOperationsInput | string
  }

  export type CameraTestCreateInput = {
    id?: string
    frontCamera: boolean
    backCamera: boolean
    timestamp?: Date | string | null
    deviceTest: DeviceTestCreateNestedOneWithoutCameraTestInput
  }

  export type CameraTestUncheckedCreateInput = {
    id?: string
    frontCamera: boolean
    backCamera: boolean
    timestamp?: Date | string | null
    deviceTestId: string
  }

  export type CameraTestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    frontCamera?: BoolFieldUpdateOperationsInput | boolean
    backCamera?: BoolFieldUpdateOperationsInput | boolean
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceTest?: DeviceTestUpdateOneRequiredWithoutCameraTestNestedInput
  }

  export type CameraTestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    frontCamera?: BoolFieldUpdateOperationsInput | boolean
    backCamera?: BoolFieldUpdateOperationsInput | boolean
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceTestId?: StringFieldUpdateOperationsInput | string
  }

  export type CameraTestCreateManyInput = {
    id?: string
    frontCamera: boolean
    backCamera: boolean
    timestamp?: Date | string | null
    deviceTestId: string
  }

  export type CameraTestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    frontCamera?: BoolFieldUpdateOperationsInput | boolean
    backCamera?: BoolFieldUpdateOperationsInput | boolean
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CameraTestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    frontCamera?: BoolFieldUpdateOperationsInput | boolean
    backCamera?: BoolFieldUpdateOperationsInput | boolean
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceTestId?: StringFieldUpdateOperationsInput | string
  }

  export type FingerprintTestCreateInput = {
    id?: string
    status: boolean
    message?: string | null
    timestamp?: Date | string | null
    deviceTest: DeviceTestCreateNestedOneWithoutFingerprintTestInput
  }

  export type FingerprintTestUncheckedCreateInput = {
    id?: string
    status: boolean
    message?: string | null
    timestamp?: Date | string | null
    deviceTestId: string
  }

  export type FingerprintTestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    message?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceTest?: DeviceTestUpdateOneRequiredWithoutFingerprintTestNestedInput
  }

  export type FingerprintTestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    message?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceTestId?: StringFieldUpdateOperationsInput | string
  }

  export type FingerprintTestCreateManyInput = {
    id?: string
    status: boolean
    message?: string | null
    timestamp?: Date | string | null
    deviceTestId: string
  }

  export type FingerprintTestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    message?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FingerprintTestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    message?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceTestId?: StringFieldUpdateOperationsInput | string
  }

  export type UsbTestCreateInput = {
    id?: string
    status: boolean
    message?: string | null
    timestamp?: Date | string | null
    deviceTest: DeviceTestCreateNestedOneWithoutUsbTestInput
  }

  export type UsbTestUncheckedCreateInput = {
    id?: string
    status: boolean
    message?: string | null
    timestamp?: Date | string | null
    deviceTestId: string
  }

  export type UsbTestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    message?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceTest?: DeviceTestUpdateOneRequiredWithoutUsbTestNestedInput
  }

  export type UsbTestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    message?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceTestId?: StringFieldUpdateOperationsInput | string
  }

  export type UsbTestCreateManyInput = {
    id?: string
    status: boolean
    message?: string | null
    timestamp?: Date | string | null
    deviceTestId: string
  }

  export type UsbTestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    message?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UsbTestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    message?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceTestId?: StringFieldUpdateOperationsInput | string
  }

  export type AudioJackTestCreateInput = {
    id?: string
    status: boolean
    message?: string | null
    timestamp?: Date | string | null
    deviceTest: DeviceTestCreateNestedOneWithoutAudioJackTestInput
  }

  export type AudioJackTestUncheckedCreateInput = {
    id?: string
    status: boolean
    message?: string | null
    timestamp?: Date | string | null
    deviceTestId: string
  }

  export type AudioJackTestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    message?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceTest?: DeviceTestUpdateOneRequiredWithoutAudioJackTestNestedInput
  }

  export type AudioJackTestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    message?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceTestId?: StringFieldUpdateOperationsInput | string
  }

  export type AudioJackTestCreateManyInput = {
    id?: string
    status: boolean
    message?: string | null
    timestamp?: Date | string | null
    deviceTestId: string
  }

  export type AudioJackTestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    message?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AudioJackTestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    message?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceTestId?: StringFieldUpdateOperationsInput | string
  }

  export type ManualDiagnosticsResultCreateInput = {
    id?: string
    diagnoseId: string
    employeeId?: string | null
    smc: string
    variant: string
    imei1?: string | null
    imei2?: string | null
    screenTouch: string
    screenSpot: string
    screenLines: string
    screenPhysical: string
    screenDiscolor: string
    screenBubble: string
    frontCamera: string
    backCamera: string
    audioJack: string
    wifi: string
    gps: string
    bluetooth: string
    volumeButton: string
    flashLight: string
    fcImageBlurred: string
    bcImageBlurred: string
    vibrator: string
    battery: string
    speaker: string
    microphone: string
    fingerprint: string
    proximity: string
    chargingPort: string
    powerButton: string
    faceLock: string
    copyScreen: string
    sim: string
    physicalScratch: string
    physicalDent: string
    physicalPanel: string
    physicalBent: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ManualDiagnosticsResultUncheckedCreateInput = {
    id?: string
    diagnoseId: string
    employeeId?: string | null
    smc: string
    variant: string
    imei1?: string | null
    imei2?: string | null
    screenTouch: string
    screenSpot: string
    screenLines: string
    screenPhysical: string
    screenDiscolor: string
    screenBubble: string
    frontCamera: string
    backCamera: string
    audioJack: string
    wifi: string
    gps: string
    bluetooth: string
    volumeButton: string
    flashLight: string
    fcImageBlurred: string
    bcImageBlurred: string
    vibrator: string
    battery: string
    speaker: string
    microphone: string
    fingerprint: string
    proximity: string
    chargingPort: string
    powerButton: string
    faceLock: string
    copyScreen: string
    sim: string
    physicalScratch: string
    physicalDent: string
    physicalPanel: string
    physicalBent: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ManualDiagnosticsResultUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    diagnoseId?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    smc?: StringFieldUpdateOperationsInput | string
    variant?: StringFieldUpdateOperationsInput | string
    imei1?: NullableStringFieldUpdateOperationsInput | string | null
    imei2?: NullableStringFieldUpdateOperationsInput | string | null
    screenTouch?: StringFieldUpdateOperationsInput | string
    screenSpot?: StringFieldUpdateOperationsInput | string
    screenLines?: StringFieldUpdateOperationsInput | string
    screenPhysical?: StringFieldUpdateOperationsInput | string
    screenDiscolor?: StringFieldUpdateOperationsInput | string
    screenBubble?: StringFieldUpdateOperationsInput | string
    frontCamera?: StringFieldUpdateOperationsInput | string
    backCamera?: StringFieldUpdateOperationsInput | string
    audioJack?: StringFieldUpdateOperationsInput | string
    wifi?: StringFieldUpdateOperationsInput | string
    gps?: StringFieldUpdateOperationsInput | string
    bluetooth?: StringFieldUpdateOperationsInput | string
    volumeButton?: StringFieldUpdateOperationsInput | string
    flashLight?: StringFieldUpdateOperationsInput | string
    fcImageBlurred?: StringFieldUpdateOperationsInput | string
    bcImageBlurred?: StringFieldUpdateOperationsInput | string
    vibrator?: StringFieldUpdateOperationsInput | string
    battery?: StringFieldUpdateOperationsInput | string
    speaker?: StringFieldUpdateOperationsInput | string
    microphone?: StringFieldUpdateOperationsInput | string
    fingerprint?: StringFieldUpdateOperationsInput | string
    proximity?: StringFieldUpdateOperationsInput | string
    chargingPort?: StringFieldUpdateOperationsInput | string
    powerButton?: StringFieldUpdateOperationsInput | string
    faceLock?: StringFieldUpdateOperationsInput | string
    copyScreen?: StringFieldUpdateOperationsInput | string
    sim?: StringFieldUpdateOperationsInput | string
    physicalScratch?: StringFieldUpdateOperationsInput | string
    physicalDent?: StringFieldUpdateOperationsInput | string
    physicalPanel?: StringFieldUpdateOperationsInput | string
    physicalBent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ManualDiagnosticsResultUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    diagnoseId?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    smc?: StringFieldUpdateOperationsInput | string
    variant?: StringFieldUpdateOperationsInput | string
    imei1?: NullableStringFieldUpdateOperationsInput | string | null
    imei2?: NullableStringFieldUpdateOperationsInput | string | null
    screenTouch?: StringFieldUpdateOperationsInput | string
    screenSpot?: StringFieldUpdateOperationsInput | string
    screenLines?: StringFieldUpdateOperationsInput | string
    screenPhysical?: StringFieldUpdateOperationsInput | string
    screenDiscolor?: StringFieldUpdateOperationsInput | string
    screenBubble?: StringFieldUpdateOperationsInput | string
    frontCamera?: StringFieldUpdateOperationsInput | string
    backCamera?: StringFieldUpdateOperationsInput | string
    audioJack?: StringFieldUpdateOperationsInput | string
    wifi?: StringFieldUpdateOperationsInput | string
    gps?: StringFieldUpdateOperationsInput | string
    bluetooth?: StringFieldUpdateOperationsInput | string
    volumeButton?: StringFieldUpdateOperationsInput | string
    flashLight?: StringFieldUpdateOperationsInput | string
    fcImageBlurred?: StringFieldUpdateOperationsInput | string
    bcImageBlurred?: StringFieldUpdateOperationsInput | string
    vibrator?: StringFieldUpdateOperationsInput | string
    battery?: StringFieldUpdateOperationsInput | string
    speaker?: StringFieldUpdateOperationsInput | string
    microphone?: StringFieldUpdateOperationsInput | string
    fingerprint?: StringFieldUpdateOperationsInput | string
    proximity?: StringFieldUpdateOperationsInput | string
    chargingPort?: StringFieldUpdateOperationsInput | string
    powerButton?: StringFieldUpdateOperationsInput | string
    faceLock?: StringFieldUpdateOperationsInput | string
    copyScreen?: StringFieldUpdateOperationsInput | string
    sim?: StringFieldUpdateOperationsInput | string
    physicalScratch?: StringFieldUpdateOperationsInput | string
    physicalDent?: StringFieldUpdateOperationsInput | string
    physicalPanel?: StringFieldUpdateOperationsInput | string
    physicalBent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ManualDiagnosticsResultCreateManyInput = {
    id?: string
    diagnoseId: string
    employeeId?: string | null
    smc: string
    variant: string
    imei1?: string | null
    imei2?: string | null
    screenTouch: string
    screenSpot: string
    screenLines: string
    screenPhysical: string
    screenDiscolor: string
    screenBubble: string
    frontCamera: string
    backCamera: string
    audioJack: string
    wifi: string
    gps: string
    bluetooth: string
    volumeButton: string
    flashLight: string
    fcImageBlurred: string
    bcImageBlurred: string
    vibrator: string
    battery: string
    speaker: string
    microphone: string
    fingerprint: string
    proximity: string
    chargingPort: string
    powerButton: string
    faceLock: string
    copyScreen: string
    sim: string
    physicalScratch: string
    physicalDent: string
    physicalPanel: string
    physicalBent: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ManualDiagnosticsResultUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    diagnoseId?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    smc?: StringFieldUpdateOperationsInput | string
    variant?: StringFieldUpdateOperationsInput | string
    imei1?: NullableStringFieldUpdateOperationsInput | string | null
    imei2?: NullableStringFieldUpdateOperationsInput | string | null
    screenTouch?: StringFieldUpdateOperationsInput | string
    screenSpot?: StringFieldUpdateOperationsInput | string
    screenLines?: StringFieldUpdateOperationsInput | string
    screenPhysical?: StringFieldUpdateOperationsInput | string
    screenDiscolor?: StringFieldUpdateOperationsInput | string
    screenBubble?: StringFieldUpdateOperationsInput | string
    frontCamera?: StringFieldUpdateOperationsInput | string
    backCamera?: StringFieldUpdateOperationsInput | string
    audioJack?: StringFieldUpdateOperationsInput | string
    wifi?: StringFieldUpdateOperationsInput | string
    gps?: StringFieldUpdateOperationsInput | string
    bluetooth?: StringFieldUpdateOperationsInput | string
    volumeButton?: StringFieldUpdateOperationsInput | string
    flashLight?: StringFieldUpdateOperationsInput | string
    fcImageBlurred?: StringFieldUpdateOperationsInput | string
    bcImageBlurred?: StringFieldUpdateOperationsInput | string
    vibrator?: StringFieldUpdateOperationsInput | string
    battery?: StringFieldUpdateOperationsInput | string
    speaker?: StringFieldUpdateOperationsInput | string
    microphone?: StringFieldUpdateOperationsInput | string
    fingerprint?: StringFieldUpdateOperationsInput | string
    proximity?: StringFieldUpdateOperationsInput | string
    chargingPort?: StringFieldUpdateOperationsInput | string
    powerButton?: StringFieldUpdateOperationsInput | string
    faceLock?: StringFieldUpdateOperationsInput | string
    copyScreen?: StringFieldUpdateOperationsInput | string
    sim?: StringFieldUpdateOperationsInput | string
    physicalScratch?: StringFieldUpdateOperationsInput | string
    physicalDent?: StringFieldUpdateOperationsInput | string
    physicalPanel?: StringFieldUpdateOperationsInput | string
    physicalBent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ManualDiagnosticsResultUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    diagnoseId?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    smc?: StringFieldUpdateOperationsInput | string
    variant?: StringFieldUpdateOperationsInput | string
    imei1?: NullableStringFieldUpdateOperationsInput | string | null
    imei2?: NullableStringFieldUpdateOperationsInput | string | null
    screenTouch?: StringFieldUpdateOperationsInput | string
    screenSpot?: StringFieldUpdateOperationsInput | string
    screenLines?: StringFieldUpdateOperationsInput | string
    screenPhysical?: StringFieldUpdateOperationsInput | string
    screenDiscolor?: StringFieldUpdateOperationsInput | string
    screenBubble?: StringFieldUpdateOperationsInput | string
    frontCamera?: StringFieldUpdateOperationsInput | string
    backCamera?: StringFieldUpdateOperationsInput | string
    audioJack?: StringFieldUpdateOperationsInput | string
    wifi?: StringFieldUpdateOperationsInput | string
    gps?: StringFieldUpdateOperationsInput | string
    bluetooth?: StringFieldUpdateOperationsInput | string
    volumeButton?: StringFieldUpdateOperationsInput | string
    flashLight?: StringFieldUpdateOperationsInput | string
    fcImageBlurred?: StringFieldUpdateOperationsInput | string
    bcImageBlurred?: StringFieldUpdateOperationsInput | string
    vibrator?: StringFieldUpdateOperationsInput | string
    battery?: StringFieldUpdateOperationsInput | string
    speaker?: StringFieldUpdateOperationsInput | string
    microphone?: StringFieldUpdateOperationsInput | string
    fingerprint?: StringFieldUpdateOperationsInput | string
    proximity?: StringFieldUpdateOperationsInput | string
    chargingPort?: StringFieldUpdateOperationsInput | string
    powerButton?: StringFieldUpdateOperationsInput | string
    faceLock?: StringFieldUpdateOperationsInput | string
    copyScreen?: StringFieldUpdateOperationsInput | string
    sim?: StringFieldUpdateOperationsInput | string
    physicalScratch?: StringFieldUpdateOperationsInput | string
    physicalDent?: StringFieldUpdateOperationsInput | string
    physicalPanel?: StringFieldUpdateOperationsInput | string
    physicalBent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeclarationCreateInput = {
    id?: string
    orderId: string
    brand: string
    model: string
    smc: string
    variant: string
    imei1?: string | null
    imei2?: string | null
    bluetooth?: string | null
    gps?: string | null
    wifi?: string | null
    proximity?: string | null
    multiTouch?: string | null
    screenCalibration?: string | null
    speaker?: string | null
    earReceiver?: string | null
    microphone?: string | null
    frontCamera?: string | null
    backCamera?: string | null
    sim?: string | null
    fingerprint?: string | null
    chargingPort?: string | null
    audioJack?: string | null
    isAccepted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeclarationUncheckedCreateInput = {
    id?: string
    orderId: string
    brand: string
    model: string
    smc: string
    variant: string
    imei1?: string | null
    imei2?: string | null
    bluetooth?: string | null
    gps?: string | null
    wifi?: string | null
    proximity?: string | null
    multiTouch?: string | null
    screenCalibration?: string | null
    speaker?: string | null
    earReceiver?: string | null
    microphone?: string | null
    frontCamera?: string | null
    backCamera?: string | null
    sim?: string | null
    fingerprint?: string | null
    chargingPort?: string | null
    audioJack?: string | null
    isAccepted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeclarationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    smc?: StringFieldUpdateOperationsInput | string
    variant?: StringFieldUpdateOperationsInput | string
    imei1?: NullableStringFieldUpdateOperationsInput | string | null
    imei2?: NullableStringFieldUpdateOperationsInput | string | null
    bluetooth?: NullableStringFieldUpdateOperationsInput | string | null
    gps?: NullableStringFieldUpdateOperationsInput | string | null
    wifi?: NullableStringFieldUpdateOperationsInput | string | null
    proximity?: NullableStringFieldUpdateOperationsInput | string | null
    multiTouch?: NullableStringFieldUpdateOperationsInput | string | null
    screenCalibration?: NullableStringFieldUpdateOperationsInput | string | null
    speaker?: NullableStringFieldUpdateOperationsInput | string | null
    earReceiver?: NullableStringFieldUpdateOperationsInput | string | null
    microphone?: NullableStringFieldUpdateOperationsInput | string | null
    frontCamera?: NullableStringFieldUpdateOperationsInput | string | null
    backCamera?: NullableStringFieldUpdateOperationsInput | string | null
    sim?: NullableStringFieldUpdateOperationsInput | string | null
    fingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    chargingPort?: NullableStringFieldUpdateOperationsInput | string | null
    audioJack?: NullableStringFieldUpdateOperationsInput | string | null
    isAccepted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeclarationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    smc?: StringFieldUpdateOperationsInput | string
    variant?: StringFieldUpdateOperationsInput | string
    imei1?: NullableStringFieldUpdateOperationsInput | string | null
    imei2?: NullableStringFieldUpdateOperationsInput | string | null
    bluetooth?: NullableStringFieldUpdateOperationsInput | string | null
    gps?: NullableStringFieldUpdateOperationsInput | string | null
    wifi?: NullableStringFieldUpdateOperationsInput | string | null
    proximity?: NullableStringFieldUpdateOperationsInput | string | null
    multiTouch?: NullableStringFieldUpdateOperationsInput | string | null
    screenCalibration?: NullableStringFieldUpdateOperationsInput | string | null
    speaker?: NullableStringFieldUpdateOperationsInput | string | null
    earReceiver?: NullableStringFieldUpdateOperationsInput | string | null
    microphone?: NullableStringFieldUpdateOperationsInput | string | null
    frontCamera?: NullableStringFieldUpdateOperationsInput | string | null
    backCamera?: NullableStringFieldUpdateOperationsInput | string | null
    sim?: NullableStringFieldUpdateOperationsInput | string | null
    fingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    chargingPort?: NullableStringFieldUpdateOperationsInput | string | null
    audioJack?: NullableStringFieldUpdateOperationsInput | string | null
    isAccepted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeclarationCreateManyInput = {
    id?: string
    orderId: string
    brand: string
    model: string
    smc: string
    variant: string
    imei1?: string | null
    imei2?: string | null
    bluetooth?: string | null
    gps?: string | null
    wifi?: string | null
    proximity?: string | null
    multiTouch?: string | null
    screenCalibration?: string | null
    speaker?: string | null
    earReceiver?: string | null
    microphone?: string | null
    frontCamera?: string | null
    backCamera?: string | null
    sim?: string | null
    fingerprint?: string | null
    chargingPort?: string | null
    audioJack?: string | null
    isAccepted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeclarationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    smc?: StringFieldUpdateOperationsInput | string
    variant?: StringFieldUpdateOperationsInput | string
    imei1?: NullableStringFieldUpdateOperationsInput | string | null
    imei2?: NullableStringFieldUpdateOperationsInput | string | null
    bluetooth?: NullableStringFieldUpdateOperationsInput | string | null
    gps?: NullableStringFieldUpdateOperationsInput | string | null
    wifi?: NullableStringFieldUpdateOperationsInput | string | null
    proximity?: NullableStringFieldUpdateOperationsInput | string | null
    multiTouch?: NullableStringFieldUpdateOperationsInput | string | null
    screenCalibration?: NullableStringFieldUpdateOperationsInput | string | null
    speaker?: NullableStringFieldUpdateOperationsInput | string | null
    earReceiver?: NullableStringFieldUpdateOperationsInput | string | null
    microphone?: NullableStringFieldUpdateOperationsInput | string | null
    frontCamera?: NullableStringFieldUpdateOperationsInput | string | null
    backCamera?: NullableStringFieldUpdateOperationsInput | string | null
    sim?: NullableStringFieldUpdateOperationsInput | string | null
    fingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    chargingPort?: NullableStringFieldUpdateOperationsInput | string | null
    audioJack?: NullableStringFieldUpdateOperationsInput | string | null
    isAccepted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeclarationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    smc?: StringFieldUpdateOperationsInput | string
    variant?: StringFieldUpdateOperationsInput | string
    imei1?: NullableStringFieldUpdateOperationsInput | string | null
    imei2?: NullableStringFieldUpdateOperationsInput | string | null
    bluetooth?: NullableStringFieldUpdateOperationsInput | string | null
    gps?: NullableStringFieldUpdateOperationsInput | string | null
    wifi?: NullableStringFieldUpdateOperationsInput | string | null
    proximity?: NullableStringFieldUpdateOperationsInput | string | null
    multiTouch?: NullableStringFieldUpdateOperationsInput | string | null
    screenCalibration?: NullableStringFieldUpdateOperationsInput | string | null
    speaker?: NullableStringFieldUpdateOperationsInput | string | null
    earReceiver?: NullableStringFieldUpdateOperationsInput | string | null
    microphone?: NullableStringFieldUpdateOperationsInput | string | null
    frontCamera?: NullableStringFieldUpdateOperationsInput | string | null
    backCamera?: NullableStringFieldUpdateOperationsInput | string | null
    sim?: NullableStringFieldUpdateOperationsInput | string | null
    fingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    chargingPort?: NullableStringFieldUpdateOperationsInput | string | null
    audioJack?: NullableStringFieldUpdateOperationsInput | string | null
    isAccepted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressCreateInput = {
    id?: string
    streetAddress: string
    city: string
    state: string
    country: string
    pinCode: string
    store: StoreCreateNestedOneWithoutAddressInput
  }

  export type AddressUncheckedCreateInput = {
    id?: string
    streetAddress: string
    city: string
    state: string
    country: string
    pinCode: string
    storeId: string
  }

  export type AddressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    streetAddress?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    pinCode?: StringFieldUpdateOperationsInput | string
    store?: StoreUpdateOneRequiredWithoutAddressNestedInput
  }

  export type AddressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    streetAddress?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    pinCode?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
  }

  export type AddressCreateManyInput = {
    id?: string
    streetAddress: string
    city: string
    state: string
    country: string
    pinCode: string
    storeId: string
  }

  export type AddressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    streetAddress?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    pinCode?: StringFieldUpdateOperationsInput | string
  }

  export type AddressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    streetAddress?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    pinCode?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
  }

  export type OtpCreateInput = {
    id?: string
    identifier: string
    otp: string
    expiresAt: Date | string
    used?: boolean
    createdAt?: Date | string
    attempts?: number
  }

  export type OtpUncheckedCreateInput = {
    id?: string
    identifier: string
    otp: string
    expiresAt: Date | string
    used?: boolean
    createdAt?: Date | string
    attempts?: number
  }

  export type OtpUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attempts?: IntFieldUpdateOperationsInput | number
  }

  export type OtpUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attempts?: IntFieldUpdateOperationsInput | number
  }

  export type OtpCreateManyInput = {
    id?: string
    identifier: string
    otp: string
    expiresAt: Date | string
    used?: boolean
    createdAt?: Date | string
    attempts?: number
  }

  export type OtpUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attempts?: IntFieldUpdateOperationsInput | number
  }

  export type OtpUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attempts?: IntFieldUpdateOperationsInput | number
  }

  export type CustomModelBrandCreateInput = {
    id?: string
    name: string
    logo?: string | null
    apiEndpoint?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    models?: CustomModelCreateNestedManyWithoutBrandInput
  }

  export type CustomModelBrandUncheckedCreateInput = {
    id?: string
    name: string
    logo?: string | null
    apiEndpoint?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    models?: CustomModelUncheckedCreateNestedManyWithoutBrandInput
  }

  export type CustomModelBrandUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    apiEndpoint?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    models?: CustomModelUpdateManyWithoutBrandNestedInput
  }

  export type CustomModelBrandUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    apiEndpoint?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    models?: CustomModelUncheckedUpdateManyWithoutBrandNestedInput
  }

  export type CustomModelBrandCreateManyInput = {
    id?: string
    name: string
    logo?: string | null
    apiEndpoint?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomModelBrandUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    apiEndpoint?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomModelBrandUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    apiEndpoint?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomModelCreateInput = {
    id?: string
    name: string
    code: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    brand: CustomModelBrandCreateNestedOneWithoutModelsInput
  }

  export type CustomModelUncheckedCreateInput = {
    id?: string
    name: string
    code: string
    brandId: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomModelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brand?: CustomModelBrandUpdateOneRequiredWithoutModelsNestedInput
  }

  export type CustomModelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    brandId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomModelCreateManyInput = {
    id?: string
    name: string
    code: string
    brandId: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomModelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomModelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    brandId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumRoleNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel> | null
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRoleNullableFilter<$PrismaModel> | $Enums.Role | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type EnumUserStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusFilter<$PrismaModel> | $Enums.UserStatus
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type ManagerNullableScalarRelationFilter = {
    is?: ManagerWhereInput | null
    isNot?: ManagerWhereInput | null
  }

  export type TechnicianNullableScalarRelationFilter = {
    is?: TechnicianWhereInput | null
    isNot?: TechnicianWhereInput | null
  }

  export type FieldExecutiveNullableScalarRelationFilter = {
    is?: FieldExecutiveWhereInput | null
    isNot?: FieldExecutiveWhereInput | null
  }

  export type SalesExecutiveNullableScalarRelationFilter = {
    is?: SalesExecutiveWhereInput | null
    isNot?: SalesExecutiveWhereInput | null
  }

  export type StoreNullableScalarRelationFilter = {
    is?: StoreWhereInput | null
    isNot?: StoreWhereInput | null
  }

  export type AdminNullableScalarRelationFilter = {
    is?: AdminWhereInput | null
    isNot?: AdminWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    phone?: SortOrder
    phoneVerified?: SortOrder
    salary?: SortOrder
    payoutDate?: SortOrder
    password?: SortOrder
    email?: SortOrder
    dateOfJoining?: SortOrder
    dateOfTermination?: SortOrder
    profileImage?: SortOrder
    aadharFrontImage?: SortOrder
    aadharBackImage?: SortOrder
    qualificationImage?: SortOrder
    VehicleFrontImage?: SortOrder
    VehicleBackImage?: SortOrder
    role?: SortOrder
    storeId?: SortOrder
    mfaEnabled?: SortOrder
    mfaSecret?: SortOrder
    mfaVerified?: SortOrder
    createdBy?: SortOrder
    isAdmin?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    salary?: SortOrder
    payoutDate?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    phone?: SortOrder
    phoneVerified?: SortOrder
    salary?: SortOrder
    payoutDate?: SortOrder
    password?: SortOrder
    email?: SortOrder
    dateOfJoining?: SortOrder
    dateOfTermination?: SortOrder
    profileImage?: SortOrder
    aadharFrontImage?: SortOrder
    aadharBackImage?: SortOrder
    qualificationImage?: SortOrder
    VehicleFrontImage?: SortOrder
    VehicleBackImage?: SortOrder
    role?: SortOrder
    storeId?: SortOrder
    mfaEnabled?: SortOrder
    mfaSecret?: SortOrder
    mfaVerified?: SortOrder
    createdBy?: SortOrder
    isAdmin?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    phone?: SortOrder
    phoneVerified?: SortOrder
    salary?: SortOrder
    payoutDate?: SortOrder
    password?: SortOrder
    email?: SortOrder
    dateOfJoining?: SortOrder
    dateOfTermination?: SortOrder
    profileImage?: SortOrder
    aadharFrontImage?: SortOrder
    aadharBackImage?: SortOrder
    qualificationImage?: SortOrder
    VehicleFrontImage?: SortOrder
    VehicleBackImage?: SortOrder
    role?: SortOrder
    storeId?: SortOrder
    mfaEnabled?: SortOrder
    mfaSecret?: SortOrder
    mfaVerified?: SortOrder
    createdBy?: SortOrder
    isAdmin?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    salary?: SortOrder
    payoutDate?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumRoleNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel> | null
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRoleNullableWithAggregatesFilter<$PrismaModel> | $Enums.Role | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumRoleNullableFilter<$PrismaModel>
    _max?: NestedEnumRoleNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumUserStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusWithAggregatesFilter<$PrismaModel> | $Enums.UserStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserStatusFilter<$PrismaModel>
    _max?: NestedEnumUserStatusFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type AdminCountOrderByAggregateInput = {
    userId?: SortOrder
    employeeId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
  }

  export type AdminMaxOrderByAggregateInput = {
    userId?: SortOrder
    employeeId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
  }

  export type AdminMinOrderByAggregateInput = {
    userId?: SortOrder
    employeeId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
  }

  export type BankDetailsNullableScalarRelationFilter = {
    is?: BankDetailsWhereInput | null
    isNot?: BankDetailsWhereInput | null
  }

  export type ManagerCountOrderByAggregateInput = {
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    employeeId?: SortOrder
    aadharId?: SortOrder
  }

  export type ManagerMaxOrderByAggregateInput = {
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    employeeId?: SortOrder
    aadharId?: SortOrder
  }

  export type ManagerMinOrderByAggregateInput = {
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    employeeId?: SortOrder
    aadharId?: SortOrder
  }

  export type TechnicianCountOrderByAggregateInput = {
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    employeeId?: SortOrder
    aadharId?: SortOrder
  }

  export type TechnicianMaxOrderByAggregateInput = {
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    employeeId?: SortOrder
    aadharId?: SortOrder
  }

  export type TechnicianMinOrderByAggregateInput = {
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    employeeId?: SortOrder
    aadharId?: SortOrder
  }

  export type FieldExecutiveCountOrderByAggregateInput = {
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    employeeId?: SortOrder
    aadharId?: SortOrder
  }

  export type FieldExecutiveMaxOrderByAggregateInput = {
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    employeeId?: SortOrder
    aadharId?: SortOrder
  }

  export type FieldExecutiveMinOrderByAggregateInput = {
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    employeeId?: SortOrder
    aadharId?: SortOrder
  }

  export type SalesExecutiveCountOrderByAggregateInput = {
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    employeeId?: SortOrder
    aadharId?: SortOrder
  }

  export type SalesExecutiveMaxOrderByAggregateInput = {
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    employeeId?: SortOrder
    aadharId?: SortOrder
  }

  export type SalesExecutiveMinOrderByAggregateInput = {
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    employeeId?: SortOrder
    aadharId?: SortOrder
  }

  export type AddressNullableScalarRelationFilter = {
    is?: AddressWhereInput | null
    isNot?: AddressWhereInput | null
  }

  export type StoreCountOrderByAggregateInput = {
    userId?: SortOrder
    storeId?: SortOrder
    storeName?: SortOrder
    ownerName?: SortOrder
    ownerPhone?: SortOrder
    ownerEmail?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StoreMaxOrderByAggregateInput = {
    userId?: SortOrder
    storeId?: SortOrder
    storeName?: SortOrder
    ownerName?: SortOrder
    ownerPhone?: SortOrder
    ownerEmail?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StoreMinOrderByAggregateInput = {
    userId?: SortOrder
    storeId?: SortOrder
    storeName?: SortOrder
    ownerName?: SortOrder
    ownerPhone?: SortOrder
    ownerEmail?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BankDetailsCountOrderByAggregateInput = {
    id?: SortOrder
    accountNumber?: SortOrder
    ifsc?: SortOrder
    bankName?: SortOrder
    beneficiaryName?: SortOrder
    upiId?: SortOrder
    managerId?: SortOrder
    technicianId?: SortOrder
    fieldExecId?: SortOrder
    salesExecId?: SortOrder
    storeId?: SortOrder
  }

  export type BankDetailsMaxOrderByAggregateInput = {
    id?: SortOrder
    accountNumber?: SortOrder
    ifsc?: SortOrder
    bankName?: SortOrder
    beneficiaryName?: SortOrder
    upiId?: SortOrder
    managerId?: SortOrder
    technicianId?: SortOrder
    fieldExecId?: SortOrder
    salesExecId?: SortOrder
    storeId?: SortOrder
  }

  export type BankDetailsMinOrderByAggregateInput = {
    id?: SortOrder
    accountNumber?: SortOrder
    ifsc?: SortOrder
    bankName?: SortOrder
    beneficiaryName?: SortOrder
    upiId?: SortOrder
    managerId?: SortOrder
    technicianId?: SortOrder
    fieldExecId?: SortOrder
    salesExecId?: SortOrder
    storeId?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    device?: SortOrder
    browser?: SortOrder
    os?: SortOrder
    location?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type SessionAvgOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    device?: SortOrder
    browser?: SortOrder
    os?: SortOrder
    location?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    device?: SortOrder
    browser?: SortOrder
    os?: SortOrder
    location?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type SessionSumOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    body?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    body?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    body?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ConnectivityTestResultListRelationFilter = {
    every?: ConnectivityTestResultWhereInput
    some?: ConnectivityTestResultWhereInput
    none?: ConnectivityTestResultWhereInput
  }

  export type SimTestResultListRelationFilter = {
    every?: SimTestResultWhereInput
    some?: SimTestResultWhereInput
    none?: SimTestResultWhereInput
  }

  export type DeviceTestResultListRelationFilter = {
    every?: DeviceTestResultWhereInput
    some?: DeviceTestResultWhereInput
    none?: DeviceTestResultWhereInput
  }

  export type ScreenTestNullableScalarRelationFilter = {
    is?: ScreenTestWhereInput | null
    isNot?: ScreenTestWhereInput | null
  }

  export type AudioTestNullableScalarRelationFilter = {
    is?: AudioTestWhereInput | null
    isNot?: AudioTestWhereInput | null
  }

  export type ProximitySensorTestNullableScalarRelationFilter = {
    is?: ProximitySensorTestWhereInput | null
    isNot?: ProximitySensorTestWhereInput | null
  }

  export type CameraTestNullableScalarRelationFilter = {
    is?: CameraTestWhereInput | null
    isNot?: CameraTestWhereInput | null
  }

  export type FingerprintTestNullableScalarRelationFilter = {
    is?: FingerprintTestWhereInput | null
    isNot?: FingerprintTestWhereInput | null
  }

  export type UsbTestNullableScalarRelationFilter = {
    is?: UsbTestWhereInput | null
    isNot?: UsbTestWhereInput | null
  }

  export type AudioJackTestNullableScalarRelationFilter = {
    is?: AudioJackTestWhereInput | null
    isNot?: AudioJackTestWhereInput | null
  }

  export type ConnectivityTestResultOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SimTestResultOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DeviceTestResultOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DeviceTestCountOrderByAggregateInput = {
    id?: SortOrder
    testId?: SortOrder
    employeeId?: SortOrder
    imageUrl?: SortOrder
    expiresAt?: SortOrder
    device?: SortOrder
    imei1?: SortOrder
    imei2?: SortOrder
    createdAt?: SortOrder
  }

  export type DeviceTestMaxOrderByAggregateInput = {
    id?: SortOrder
    testId?: SortOrder
    employeeId?: SortOrder
    imageUrl?: SortOrder
    expiresAt?: SortOrder
    imei1?: SortOrder
    imei2?: SortOrder
    createdAt?: SortOrder
  }

  export type DeviceTestMinOrderByAggregateInput = {
    id?: SortOrder
    testId?: SortOrder
    employeeId?: SortOrder
    imageUrl?: SortOrder
    expiresAt?: SortOrder
    imei1?: SortOrder
    imei2?: SortOrder
    createdAt?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type DeviceTestScalarRelationFilter = {
    is?: DeviceTestWhereInput
    isNot?: DeviceTestWhereInput
  }

  export type ConnectivityTestResultCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    message?: SortOrder
    timestamp?: SortOrder
    deviceTestId?: SortOrder
  }

  export type ConnectivityTestResultMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    message?: SortOrder
    timestamp?: SortOrder
    deviceTestId?: SortOrder
  }

  export type ConnectivityTestResultMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    message?: SortOrder
    timestamp?: SortOrder
    deviceTestId?: SortOrder
  }

  export type DeviceTestResultCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    message?: SortOrder
    timestamp?: SortOrder
    deviceTestId?: SortOrder
  }

  export type DeviceTestResultMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    message?: SortOrder
    timestamp?: SortOrder
    deviceTestId?: SortOrder
  }

  export type DeviceTestResultMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    message?: SortOrder
    timestamp?: SortOrder
    deviceTestId?: SortOrder
  }

  export type SimTestResultCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    timestamp?: SortOrder
    deviceTestId?: SortOrder
  }

  export type SimTestResultMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    timestamp?: SortOrder
    deviceTestId?: SortOrder
  }

  export type SimTestResultMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    timestamp?: SortOrder
    deviceTestId?: SortOrder
  }

  export type ScreenTestCountOrderByAggregateInput = {
    id?: SortOrder
    multiTouch?: SortOrder
    dotCoverage?: SortOrder
    completed?: SortOrder
    timestamp?: SortOrder
    deviceTestId?: SortOrder
  }

  export type ScreenTestMaxOrderByAggregateInput = {
    id?: SortOrder
    multiTouch?: SortOrder
    dotCoverage?: SortOrder
    completed?: SortOrder
    timestamp?: SortOrder
    deviceTestId?: SortOrder
  }

  export type ScreenTestMinOrderByAggregateInput = {
    id?: SortOrder
    multiTouch?: SortOrder
    dotCoverage?: SortOrder
    completed?: SortOrder
    timestamp?: SortOrder
    deviceTestId?: SortOrder
  }

  export type AudioTestCountOrderByAggregateInput = {
    id?: SortOrder
    speaker?: SortOrder
    earReceiver?: SortOrder
    microphone?: SortOrder
    timestamp?: SortOrder
    deviceTestId?: SortOrder
  }

  export type AudioTestMaxOrderByAggregateInput = {
    id?: SortOrder
    speaker?: SortOrder
    earReceiver?: SortOrder
    microphone?: SortOrder
    timestamp?: SortOrder
    deviceTestId?: SortOrder
  }

  export type AudioTestMinOrderByAggregateInput = {
    id?: SortOrder
    speaker?: SortOrder
    earReceiver?: SortOrder
    microphone?: SortOrder
    timestamp?: SortOrder
    deviceTestId?: SortOrder
  }

  export type ProximitySensorTestCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    message?: SortOrder
    timestamp?: SortOrder
    deviceTestId?: SortOrder
  }

  export type ProximitySensorTestMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    message?: SortOrder
    timestamp?: SortOrder
    deviceTestId?: SortOrder
  }

  export type ProximitySensorTestMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    message?: SortOrder
    timestamp?: SortOrder
    deviceTestId?: SortOrder
  }

  export type CameraTestCountOrderByAggregateInput = {
    id?: SortOrder
    frontCamera?: SortOrder
    backCamera?: SortOrder
    timestamp?: SortOrder
    deviceTestId?: SortOrder
  }

  export type CameraTestMaxOrderByAggregateInput = {
    id?: SortOrder
    frontCamera?: SortOrder
    backCamera?: SortOrder
    timestamp?: SortOrder
    deviceTestId?: SortOrder
  }

  export type CameraTestMinOrderByAggregateInput = {
    id?: SortOrder
    frontCamera?: SortOrder
    backCamera?: SortOrder
    timestamp?: SortOrder
    deviceTestId?: SortOrder
  }

  export type FingerprintTestCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    message?: SortOrder
    timestamp?: SortOrder
    deviceTestId?: SortOrder
  }

  export type FingerprintTestMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    message?: SortOrder
    timestamp?: SortOrder
    deviceTestId?: SortOrder
  }

  export type FingerprintTestMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    message?: SortOrder
    timestamp?: SortOrder
    deviceTestId?: SortOrder
  }

  export type UsbTestCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    message?: SortOrder
    timestamp?: SortOrder
    deviceTestId?: SortOrder
  }

  export type UsbTestMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    message?: SortOrder
    timestamp?: SortOrder
    deviceTestId?: SortOrder
  }

  export type UsbTestMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    message?: SortOrder
    timestamp?: SortOrder
    deviceTestId?: SortOrder
  }

  export type AudioJackTestCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    message?: SortOrder
    timestamp?: SortOrder
    deviceTestId?: SortOrder
  }

  export type AudioJackTestMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    message?: SortOrder
    timestamp?: SortOrder
    deviceTestId?: SortOrder
  }

  export type AudioJackTestMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    message?: SortOrder
    timestamp?: SortOrder
    deviceTestId?: SortOrder
  }

  export type ManualDiagnosticsResultCountOrderByAggregateInput = {
    id?: SortOrder
    diagnoseId?: SortOrder
    employeeId?: SortOrder
    smc?: SortOrder
    variant?: SortOrder
    imei1?: SortOrder
    imei2?: SortOrder
    screenTouch?: SortOrder
    screenSpot?: SortOrder
    screenLines?: SortOrder
    screenPhysical?: SortOrder
    screenDiscolor?: SortOrder
    screenBubble?: SortOrder
    frontCamera?: SortOrder
    backCamera?: SortOrder
    audioJack?: SortOrder
    wifi?: SortOrder
    gps?: SortOrder
    bluetooth?: SortOrder
    volumeButton?: SortOrder
    flashLight?: SortOrder
    fcImageBlurred?: SortOrder
    bcImageBlurred?: SortOrder
    vibrator?: SortOrder
    battery?: SortOrder
    speaker?: SortOrder
    microphone?: SortOrder
    fingerprint?: SortOrder
    proximity?: SortOrder
    chargingPort?: SortOrder
    powerButton?: SortOrder
    faceLock?: SortOrder
    copyScreen?: SortOrder
    sim?: SortOrder
    physicalScratch?: SortOrder
    physicalDent?: SortOrder
    physicalPanel?: SortOrder
    physicalBent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ManualDiagnosticsResultMaxOrderByAggregateInput = {
    id?: SortOrder
    diagnoseId?: SortOrder
    employeeId?: SortOrder
    smc?: SortOrder
    variant?: SortOrder
    imei1?: SortOrder
    imei2?: SortOrder
    screenTouch?: SortOrder
    screenSpot?: SortOrder
    screenLines?: SortOrder
    screenPhysical?: SortOrder
    screenDiscolor?: SortOrder
    screenBubble?: SortOrder
    frontCamera?: SortOrder
    backCamera?: SortOrder
    audioJack?: SortOrder
    wifi?: SortOrder
    gps?: SortOrder
    bluetooth?: SortOrder
    volumeButton?: SortOrder
    flashLight?: SortOrder
    fcImageBlurred?: SortOrder
    bcImageBlurred?: SortOrder
    vibrator?: SortOrder
    battery?: SortOrder
    speaker?: SortOrder
    microphone?: SortOrder
    fingerprint?: SortOrder
    proximity?: SortOrder
    chargingPort?: SortOrder
    powerButton?: SortOrder
    faceLock?: SortOrder
    copyScreen?: SortOrder
    sim?: SortOrder
    physicalScratch?: SortOrder
    physicalDent?: SortOrder
    physicalPanel?: SortOrder
    physicalBent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ManualDiagnosticsResultMinOrderByAggregateInput = {
    id?: SortOrder
    diagnoseId?: SortOrder
    employeeId?: SortOrder
    smc?: SortOrder
    variant?: SortOrder
    imei1?: SortOrder
    imei2?: SortOrder
    screenTouch?: SortOrder
    screenSpot?: SortOrder
    screenLines?: SortOrder
    screenPhysical?: SortOrder
    screenDiscolor?: SortOrder
    screenBubble?: SortOrder
    frontCamera?: SortOrder
    backCamera?: SortOrder
    audioJack?: SortOrder
    wifi?: SortOrder
    gps?: SortOrder
    bluetooth?: SortOrder
    volumeButton?: SortOrder
    flashLight?: SortOrder
    fcImageBlurred?: SortOrder
    bcImageBlurred?: SortOrder
    vibrator?: SortOrder
    battery?: SortOrder
    speaker?: SortOrder
    microphone?: SortOrder
    fingerprint?: SortOrder
    proximity?: SortOrder
    chargingPort?: SortOrder
    powerButton?: SortOrder
    faceLock?: SortOrder
    copyScreen?: SortOrder
    sim?: SortOrder
    physicalScratch?: SortOrder
    physicalDent?: SortOrder
    physicalPanel?: SortOrder
    physicalBent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeclarationCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    brand?: SortOrder
    model?: SortOrder
    smc?: SortOrder
    variant?: SortOrder
    imei1?: SortOrder
    imei2?: SortOrder
    bluetooth?: SortOrder
    gps?: SortOrder
    wifi?: SortOrder
    proximity?: SortOrder
    multiTouch?: SortOrder
    screenCalibration?: SortOrder
    speaker?: SortOrder
    earReceiver?: SortOrder
    microphone?: SortOrder
    frontCamera?: SortOrder
    backCamera?: SortOrder
    sim?: SortOrder
    fingerprint?: SortOrder
    chargingPort?: SortOrder
    audioJack?: SortOrder
    isAccepted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeclarationMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    brand?: SortOrder
    model?: SortOrder
    smc?: SortOrder
    variant?: SortOrder
    imei1?: SortOrder
    imei2?: SortOrder
    bluetooth?: SortOrder
    gps?: SortOrder
    wifi?: SortOrder
    proximity?: SortOrder
    multiTouch?: SortOrder
    screenCalibration?: SortOrder
    speaker?: SortOrder
    earReceiver?: SortOrder
    microphone?: SortOrder
    frontCamera?: SortOrder
    backCamera?: SortOrder
    sim?: SortOrder
    fingerprint?: SortOrder
    chargingPort?: SortOrder
    audioJack?: SortOrder
    isAccepted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeclarationMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    brand?: SortOrder
    model?: SortOrder
    smc?: SortOrder
    variant?: SortOrder
    imei1?: SortOrder
    imei2?: SortOrder
    bluetooth?: SortOrder
    gps?: SortOrder
    wifi?: SortOrder
    proximity?: SortOrder
    multiTouch?: SortOrder
    screenCalibration?: SortOrder
    speaker?: SortOrder
    earReceiver?: SortOrder
    microphone?: SortOrder
    frontCamera?: SortOrder
    backCamera?: SortOrder
    sim?: SortOrder
    fingerprint?: SortOrder
    chargingPort?: SortOrder
    audioJack?: SortOrder
    isAccepted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StoreScalarRelationFilter = {
    is?: StoreWhereInput
    isNot?: StoreWhereInput
  }

  export type AddressCountOrderByAggregateInput = {
    id?: SortOrder
    streetAddress?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    pinCode?: SortOrder
    storeId?: SortOrder
  }

  export type AddressMaxOrderByAggregateInput = {
    id?: SortOrder
    streetAddress?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    pinCode?: SortOrder
    storeId?: SortOrder
  }

  export type AddressMinOrderByAggregateInput = {
    id?: SortOrder
    streetAddress?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    pinCode?: SortOrder
    storeId?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type OtpCountOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    otp?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
    createdAt?: SortOrder
    attempts?: SortOrder
  }

  export type OtpAvgOrderByAggregateInput = {
    attempts?: SortOrder
  }

  export type OtpMaxOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    otp?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
    createdAt?: SortOrder
    attempts?: SortOrder
  }

  export type OtpMinOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    otp?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
    createdAt?: SortOrder
    attempts?: SortOrder
  }

  export type OtpSumOrderByAggregateInput = {
    attempts?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type CustomModelListRelationFilter = {
    every?: CustomModelWhereInput
    some?: CustomModelWhereInput
    none?: CustomModelWhereInput
  }

  export type CustomModelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomModelBrandCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    logo?: SortOrder
    apiEndpoint?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomModelBrandMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    logo?: SortOrder
    apiEndpoint?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomModelBrandMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    logo?: SortOrder
    apiEndpoint?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomModelBrandScalarRelationFilter = {
    is?: CustomModelBrandWhereInput
    isNot?: CustomModelBrandWhereInput
  }

  export type CustomModelCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    brandId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomModelMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    brandId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomModelMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    brandId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type ManagerCreateNestedOneWithoutUserInput = {
    create?: XOR<ManagerCreateWithoutUserInput, ManagerUncheckedCreateWithoutUserInput>
    connectOrCreate?: ManagerCreateOrConnectWithoutUserInput
    connect?: ManagerWhereUniqueInput
  }

  export type TechnicianCreateNestedOneWithoutUserInput = {
    create?: XOR<TechnicianCreateWithoutUserInput, TechnicianUncheckedCreateWithoutUserInput>
    connectOrCreate?: TechnicianCreateOrConnectWithoutUserInput
    connect?: TechnicianWhereUniqueInput
  }

  export type FieldExecutiveCreateNestedOneWithoutUserInput = {
    create?: XOR<FieldExecutiveCreateWithoutUserInput, FieldExecutiveUncheckedCreateWithoutUserInput>
    connectOrCreate?: FieldExecutiveCreateOrConnectWithoutUserInput
    connect?: FieldExecutiveWhereUniqueInput
  }

  export type SalesExecutiveCreateNestedOneWithoutUserInput = {
    create?: XOR<SalesExecutiveCreateWithoutUserInput, SalesExecutiveUncheckedCreateWithoutUserInput>
    connectOrCreate?: SalesExecutiveCreateOrConnectWithoutUserInput
    connect?: SalesExecutiveWhereUniqueInput
  }

  export type StoreCreateNestedOneWithoutUserInput = {
    create?: XOR<StoreCreateWithoutUserInput, StoreUncheckedCreateWithoutUserInput>
    connectOrCreate?: StoreCreateOrConnectWithoutUserInput
    connect?: StoreWhereUniqueInput
  }

  export type AdminCreateNestedOneWithoutUserInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput
    connect?: AdminWhereUniqueInput
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type ManagerUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<ManagerCreateWithoutUserInput, ManagerUncheckedCreateWithoutUserInput>
    connectOrCreate?: ManagerCreateOrConnectWithoutUserInput
    connect?: ManagerWhereUniqueInput
  }

  export type TechnicianUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<TechnicianCreateWithoutUserInput, TechnicianUncheckedCreateWithoutUserInput>
    connectOrCreate?: TechnicianCreateOrConnectWithoutUserInput
    connect?: TechnicianWhereUniqueInput
  }

  export type FieldExecutiveUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<FieldExecutiveCreateWithoutUserInput, FieldExecutiveUncheckedCreateWithoutUserInput>
    connectOrCreate?: FieldExecutiveCreateOrConnectWithoutUserInput
    connect?: FieldExecutiveWhereUniqueInput
  }

  export type SalesExecutiveUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<SalesExecutiveCreateWithoutUserInput, SalesExecutiveUncheckedCreateWithoutUserInput>
    connectOrCreate?: SalesExecutiveCreateOrConnectWithoutUserInput
    connect?: SalesExecutiveWhereUniqueInput
  }

  export type StoreUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<StoreCreateWithoutUserInput, StoreUncheckedCreateWithoutUserInput>
    connectOrCreate?: StoreCreateOrConnectWithoutUserInput
    connect?: StoreWhereUniqueInput
  }

  export type AdminUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput
    connect?: AdminWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableEnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type EnumUserStatusFieldUpdateOperationsInput = {
    set?: $Enums.UserStatus
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type ManagerUpdateOneWithoutUserNestedInput = {
    create?: XOR<ManagerCreateWithoutUserInput, ManagerUncheckedCreateWithoutUserInput>
    connectOrCreate?: ManagerCreateOrConnectWithoutUserInput
    upsert?: ManagerUpsertWithoutUserInput
    disconnect?: ManagerWhereInput | boolean
    delete?: ManagerWhereInput | boolean
    connect?: ManagerWhereUniqueInput
    update?: XOR<XOR<ManagerUpdateToOneWithWhereWithoutUserInput, ManagerUpdateWithoutUserInput>, ManagerUncheckedUpdateWithoutUserInput>
  }

  export type TechnicianUpdateOneWithoutUserNestedInput = {
    create?: XOR<TechnicianCreateWithoutUserInput, TechnicianUncheckedCreateWithoutUserInput>
    connectOrCreate?: TechnicianCreateOrConnectWithoutUserInput
    upsert?: TechnicianUpsertWithoutUserInput
    disconnect?: TechnicianWhereInput | boolean
    delete?: TechnicianWhereInput | boolean
    connect?: TechnicianWhereUniqueInput
    update?: XOR<XOR<TechnicianUpdateToOneWithWhereWithoutUserInput, TechnicianUpdateWithoutUserInput>, TechnicianUncheckedUpdateWithoutUserInput>
  }

  export type FieldExecutiveUpdateOneWithoutUserNestedInput = {
    create?: XOR<FieldExecutiveCreateWithoutUserInput, FieldExecutiveUncheckedCreateWithoutUserInput>
    connectOrCreate?: FieldExecutiveCreateOrConnectWithoutUserInput
    upsert?: FieldExecutiveUpsertWithoutUserInput
    disconnect?: FieldExecutiveWhereInput | boolean
    delete?: FieldExecutiveWhereInput | boolean
    connect?: FieldExecutiveWhereUniqueInput
    update?: XOR<XOR<FieldExecutiveUpdateToOneWithWhereWithoutUserInput, FieldExecutiveUpdateWithoutUserInput>, FieldExecutiveUncheckedUpdateWithoutUserInput>
  }

  export type SalesExecutiveUpdateOneWithoutUserNestedInput = {
    create?: XOR<SalesExecutiveCreateWithoutUserInput, SalesExecutiveUncheckedCreateWithoutUserInput>
    connectOrCreate?: SalesExecutiveCreateOrConnectWithoutUserInput
    upsert?: SalesExecutiveUpsertWithoutUserInput
    disconnect?: SalesExecutiveWhereInput | boolean
    delete?: SalesExecutiveWhereInput | boolean
    connect?: SalesExecutiveWhereUniqueInput
    update?: XOR<XOR<SalesExecutiveUpdateToOneWithWhereWithoutUserInput, SalesExecutiveUpdateWithoutUserInput>, SalesExecutiveUncheckedUpdateWithoutUserInput>
  }

  export type StoreUpdateOneWithoutUserNestedInput = {
    create?: XOR<StoreCreateWithoutUserInput, StoreUncheckedCreateWithoutUserInput>
    connectOrCreate?: StoreCreateOrConnectWithoutUserInput
    upsert?: StoreUpsertWithoutUserInput
    disconnect?: StoreWhereInput | boolean
    delete?: StoreWhereInput | boolean
    connect?: StoreWhereUniqueInput
    update?: XOR<XOR<StoreUpdateToOneWithWhereWithoutUserInput, StoreUpdateWithoutUserInput>, StoreUncheckedUpdateWithoutUserInput>
  }

  export type AdminUpdateOneWithoutUserNestedInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput
    upsert?: AdminUpsertWithoutUserInput
    disconnect?: AdminWhereInput | boolean
    delete?: AdminWhereInput | boolean
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutUserInput, AdminUpdateWithoutUserInput>, AdminUncheckedUpdateWithoutUserInput>
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type ManagerUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<ManagerCreateWithoutUserInput, ManagerUncheckedCreateWithoutUserInput>
    connectOrCreate?: ManagerCreateOrConnectWithoutUserInput
    upsert?: ManagerUpsertWithoutUserInput
    disconnect?: ManagerWhereInput | boolean
    delete?: ManagerWhereInput | boolean
    connect?: ManagerWhereUniqueInput
    update?: XOR<XOR<ManagerUpdateToOneWithWhereWithoutUserInput, ManagerUpdateWithoutUserInput>, ManagerUncheckedUpdateWithoutUserInput>
  }

  export type TechnicianUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<TechnicianCreateWithoutUserInput, TechnicianUncheckedCreateWithoutUserInput>
    connectOrCreate?: TechnicianCreateOrConnectWithoutUserInput
    upsert?: TechnicianUpsertWithoutUserInput
    disconnect?: TechnicianWhereInput | boolean
    delete?: TechnicianWhereInput | boolean
    connect?: TechnicianWhereUniqueInput
    update?: XOR<XOR<TechnicianUpdateToOneWithWhereWithoutUserInput, TechnicianUpdateWithoutUserInput>, TechnicianUncheckedUpdateWithoutUserInput>
  }

  export type FieldExecutiveUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<FieldExecutiveCreateWithoutUserInput, FieldExecutiveUncheckedCreateWithoutUserInput>
    connectOrCreate?: FieldExecutiveCreateOrConnectWithoutUserInput
    upsert?: FieldExecutiveUpsertWithoutUserInput
    disconnect?: FieldExecutiveWhereInput | boolean
    delete?: FieldExecutiveWhereInput | boolean
    connect?: FieldExecutiveWhereUniqueInput
    update?: XOR<XOR<FieldExecutiveUpdateToOneWithWhereWithoutUserInput, FieldExecutiveUpdateWithoutUserInput>, FieldExecutiveUncheckedUpdateWithoutUserInput>
  }

  export type SalesExecutiveUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<SalesExecutiveCreateWithoutUserInput, SalesExecutiveUncheckedCreateWithoutUserInput>
    connectOrCreate?: SalesExecutiveCreateOrConnectWithoutUserInput
    upsert?: SalesExecutiveUpsertWithoutUserInput
    disconnect?: SalesExecutiveWhereInput | boolean
    delete?: SalesExecutiveWhereInput | boolean
    connect?: SalesExecutiveWhereUniqueInput
    update?: XOR<XOR<SalesExecutiveUpdateToOneWithWhereWithoutUserInput, SalesExecutiveUpdateWithoutUserInput>, SalesExecutiveUncheckedUpdateWithoutUserInput>
  }

  export type StoreUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<StoreCreateWithoutUserInput, StoreUncheckedCreateWithoutUserInput>
    connectOrCreate?: StoreCreateOrConnectWithoutUserInput
    upsert?: StoreUpsertWithoutUserInput
    disconnect?: StoreWhereInput | boolean
    delete?: StoreWhereInput | boolean
    connect?: StoreWhereUniqueInput
    update?: XOR<XOR<StoreUpdateToOneWithWhereWithoutUserInput, StoreUpdateWithoutUserInput>, StoreUncheckedUpdateWithoutUserInput>
  }

  export type AdminUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput
    upsert?: AdminUpsertWithoutUserInput
    disconnect?: AdminWhereInput | boolean
    delete?: AdminWhereInput | boolean
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutUserInput, AdminUpdateWithoutUserInput>, AdminUncheckedUpdateWithoutUserInput>
  }

  export type UserCreateNestedOneWithoutAdminInput = {
    create?: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAdminNestedInput = {
    create?: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminInput
    upsert?: UserUpsertWithoutAdminInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAdminInput, UserUpdateWithoutAdminInput>, UserUncheckedUpdateWithoutAdminInput>
  }

  export type UserCreateNestedOneWithoutManagerInput = {
    create?: XOR<UserCreateWithoutManagerInput, UserUncheckedCreateWithoutManagerInput>
    connectOrCreate?: UserCreateOrConnectWithoutManagerInput
    connect?: UserWhereUniqueInput
  }

  export type BankDetailsCreateNestedOneWithoutManagerInput = {
    create?: XOR<BankDetailsCreateWithoutManagerInput, BankDetailsUncheckedCreateWithoutManagerInput>
    connectOrCreate?: BankDetailsCreateOrConnectWithoutManagerInput
    connect?: BankDetailsWhereUniqueInput
  }

  export type BankDetailsUncheckedCreateNestedOneWithoutManagerInput = {
    create?: XOR<BankDetailsCreateWithoutManagerInput, BankDetailsUncheckedCreateWithoutManagerInput>
    connectOrCreate?: BankDetailsCreateOrConnectWithoutManagerInput
    connect?: BankDetailsWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutManagerNestedInput = {
    create?: XOR<UserCreateWithoutManagerInput, UserUncheckedCreateWithoutManagerInput>
    connectOrCreate?: UserCreateOrConnectWithoutManagerInput
    upsert?: UserUpsertWithoutManagerInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutManagerInput, UserUpdateWithoutManagerInput>, UserUncheckedUpdateWithoutManagerInput>
  }

  export type BankDetailsUpdateOneWithoutManagerNestedInput = {
    create?: XOR<BankDetailsCreateWithoutManagerInput, BankDetailsUncheckedCreateWithoutManagerInput>
    connectOrCreate?: BankDetailsCreateOrConnectWithoutManagerInput
    upsert?: BankDetailsUpsertWithoutManagerInput
    disconnect?: BankDetailsWhereInput | boolean
    delete?: BankDetailsWhereInput | boolean
    connect?: BankDetailsWhereUniqueInput
    update?: XOR<XOR<BankDetailsUpdateToOneWithWhereWithoutManagerInput, BankDetailsUpdateWithoutManagerInput>, BankDetailsUncheckedUpdateWithoutManagerInput>
  }

  export type BankDetailsUncheckedUpdateOneWithoutManagerNestedInput = {
    create?: XOR<BankDetailsCreateWithoutManagerInput, BankDetailsUncheckedCreateWithoutManagerInput>
    connectOrCreate?: BankDetailsCreateOrConnectWithoutManagerInput
    upsert?: BankDetailsUpsertWithoutManagerInput
    disconnect?: BankDetailsWhereInput | boolean
    delete?: BankDetailsWhereInput | boolean
    connect?: BankDetailsWhereUniqueInput
    update?: XOR<XOR<BankDetailsUpdateToOneWithWhereWithoutManagerInput, BankDetailsUpdateWithoutManagerInput>, BankDetailsUncheckedUpdateWithoutManagerInput>
  }

  export type UserCreateNestedOneWithoutTechnicianInput = {
    create?: XOR<UserCreateWithoutTechnicianInput, UserUncheckedCreateWithoutTechnicianInput>
    connectOrCreate?: UserCreateOrConnectWithoutTechnicianInput
    connect?: UserWhereUniqueInput
  }

  export type BankDetailsCreateNestedOneWithoutTechnicianInput = {
    create?: XOR<BankDetailsCreateWithoutTechnicianInput, BankDetailsUncheckedCreateWithoutTechnicianInput>
    connectOrCreate?: BankDetailsCreateOrConnectWithoutTechnicianInput
    connect?: BankDetailsWhereUniqueInput
  }

  export type BankDetailsUncheckedCreateNestedOneWithoutTechnicianInput = {
    create?: XOR<BankDetailsCreateWithoutTechnicianInput, BankDetailsUncheckedCreateWithoutTechnicianInput>
    connectOrCreate?: BankDetailsCreateOrConnectWithoutTechnicianInput
    connect?: BankDetailsWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutTechnicianNestedInput = {
    create?: XOR<UserCreateWithoutTechnicianInput, UserUncheckedCreateWithoutTechnicianInput>
    connectOrCreate?: UserCreateOrConnectWithoutTechnicianInput
    upsert?: UserUpsertWithoutTechnicianInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTechnicianInput, UserUpdateWithoutTechnicianInput>, UserUncheckedUpdateWithoutTechnicianInput>
  }

  export type BankDetailsUpdateOneWithoutTechnicianNestedInput = {
    create?: XOR<BankDetailsCreateWithoutTechnicianInput, BankDetailsUncheckedCreateWithoutTechnicianInput>
    connectOrCreate?: BankDetailsCreateOrConnectWithoutTechnicianInput
    upsert?: BankDetailsUpsertWithoutTechnicianInput
    disconnect?: BankDetailsWhereInput | boolean
    delete?: BankDetailsWhereInput | boolean
    connect?: BankDetailsWhereUniqueInput
    update?: XOR<XOR<BankDetailsUpdateToOneWithWhereWithoutTechnicianInput, BankDetailsUpdateWithoutTechnicianInput>, BankDetailsUncheckedUpdateWithoutTechnicianInput>
  }

  export type BankDetailsUncheckedUpdateOneWithoutTechnicianNestedInput = {
    create?: XOR<BankDetailsCreateWithoutTechnicianInput, BankDetailsUncheckedCreateWithoutTechnicianInput>
    connectOrCreate?: BankDetailsCreateOrConnectWithoutTechnicianInput
    upsert?: BankDetailsUpsertWithoutTechnicianInput
    disconnect?: BankDetailsWhereInput | boolean
    delete?: BankDetailsWhereInput | boolean
    connect?: BankDetailsWhereUniqueInput
    update?: XOR<XOR<BankDetailsUpdateToOneWithWhereWithoutTechnicianInput, BankDetailsUpdateWithoutTechnicianInput>, BankDetailsUncheckedUpdateWithoutTechnicianInput>
  }

  export type UserCreateNestedOneWithoutFieldExecutiveInput = {
    create?: XOR<UserCreateWithoutFieldExecutiveInput, UserUncheckedCreateWithoutFieldExecutiveInput>
    connectOrCreate?: UserCreateOrConnectWithoutFieldExecutiveInput
    connect?: UserWhereUniqueInput
  }

  export type BankDetailsCreateNestedOneWithoutFieldExecutiveInput = {
    create?: XOR<BankDetailsCreateWithoutFieldExecutiveInput, BankDetailsUncheckedCreateWithoutFieldExecutiveInput>
    connectOrCreate?: BankDetailsCreateOrConnectWithoutFieldExecutiveInput
    connect?: BankDetailsWhereUniqueInput
  }

  export type BankDetailsUncheckedCreateNestedOneWithoutFieldExecutiveInput = {
    create?: XOR<BankDetailsCreateWithoutFieldExecutiveInput, BankDetailsUncheckedCreateWithoutFieldExecutiveInput>
    connectOrCreate?: BankDetailsCreateOrConnectWithoutFieldExecutiveInput
    connect?: BankDetailsWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutFieldExecutiveNestedInput = {
    create?: XOR<UserCreateWithoutFieldExecutiveInput, UserUncheckedCreateWithoutFieldExecutiveInput>
    connectOrCreate?: UserCreateOrConnectWithoutFieldExecutiveInput
    upsert?: UserUpsertWithoutFieldExecutiveInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFieldExecutiveInput, UserUpdateWithoutFieldExecutiveInput>, UserUncheckedUpdateWithoutFieldExecutiveInput>
  }

  export type BankDetailsUpdateOneWithoutFieldExecutiveNestedInput = {
    create?: XOR<BankDetailsCreateWithoutFieldExecutiveInput, BankDetailsUncheckedCreateWithoutFieldExecutiveInput>
    connectOrCreate?: BankDetailsCreateOrConnectWithoutFieldExecutiveInput
    upsert?: BankDetailsUpsertWithoutFieldExecutiveInput
    disconnect?: BankDetailsWhereInput | boolean
    delete?: BankDetailsWhereInput | boolean
    connect?: BankDetailsWhereUniqueInput
    update?: XOR<XOR<BankDetailsUpdateToOneWithWhereWithoutFieldExecutiveInput, BankDetailsUpdateWithoutFieldExecutiveInput>, BankDetailsUncheckedUpdateWithoutFieldExecutiveInput>
  }

  export type BankDetailsUncheckedUpdateOneWithoutFieldExecutiveNestedInput = {
    create?: XOR<BankDetailsCreateWithoutFieldExecutiveInput, BankDetailsUncheckedCreateWithoutFieldExecutiveInput>
    connectOrCreate?: BankDetailsCreateOrConnectWithoutFieldExecutiveInput
    upsert?: BankDetailsUpsertWithoutFieldExecutiveInput
    disconnect?: BankDetailsWhereInput | boolean
    delete?: BankDetailsWhereInput | boolean
    connect?: BankDetailsWhereUniqueInput
    update?: XOR<XOR<BankDetailsUpdateToOneWithWhereWithoutFieldExecutiveInput, BankDetailsUpdateWithoutFieldExecutiveInput>, BankDetailsUncheckedUpdateWithoutFieldExecutiveInput>
  }

  export type UserCreateNestedOneWithoutSalesExecutiveInput = {
    create?: XOR<UserCreateWithoutSalesExecutiveInput, UserUncheckedCreateWithoutSalesExecutiveInput>
    connectOrCreate?: UserCreateOrConnectWithoutSalesExecutiveInput
    connect?: UserWhereUniqueInput
  }

  export type BankDetailsCreateNestedOneWithoutSalesExecutiveInput = {
    create?: XOR<BankDetailsCreateWithoutSalesExecutiveInput, BankDetailsUncheckedCreateWithoutSalesExecutiveInput>
    connectOrCreate?: BankDetailsCreateOrConnectWithoutSalesExecutiveInput
    connect?: BankDetailsWhereUniqueInput
  }

  export type BankDetailsUncheckedCreateNestedOneWithoutSalesExecutiveInput = {
    create?: XOR<BankDetailsCreateWithoutSalesExecutiveInput, BankDetailsUncheckedCreateWithoutSalesExecutiveInput>
    connectOrCreate?: BankDetailsCreateOrConnectWithoutSalesExecutiveInput
    connect?: BankDetailsWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSalesExecutiveNestedInput = {
    create?: XOR<UserCreateWithoutSalesExecutiveInput, UserUncheckedCreateWithoutSalesExecutiveInput>
    connectOrCreate?: UserCreateOrConnectWithoutSalesExecutiveInput
    upsert?: UserUpsertWithoutSalesExecutiveInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSalesExecutiveInput, UserUpdateWithoutSalesExecutiveInput>, UserUncheckedUpdateWithoutSalesExecutiveInput>
  }

  export type BankDetailsUpdateOneWithoutSalesExecutiveNestedInput = {
    create?: XOR<BankDetailsCreateWithoutSalesExecutiveInput, BankDetailsUncheckedCreateWithoutSalesExecutiveInput>
    connectOrCreate?: BankDetailsCreateOrConnectWithoutSalesExecutiveInput
    upsert?: BankDetailsUpsertWithoutSalesExecutiveInput
    disconnect?: BankDetailsWhereInput | boolean
    delete?: BankDetailsWhereInput | boolean
    connect?: BankDetailsWhereUniqueInput
    update?: XOR<XOR<BankDetailsUpdateToOneWithWhereWithoutSalesExecutiveInput, BankDetailsUpdateWithoutSalesExecutiveInput>, BankDetailsUncheckedUpdateWithoutSalesExecutiveInput>
  }

  export type BankDetailsUncheckedUpdateOneWithoutSalesExecutiveNestedInput = {
    create?: XOR<BankDetailsCreateWithoutSalesExecutiveInput, BankDetailsUncheckedCreateWithoutSalesExecutiveInput>
    connectOrCreate?: BankDetailsCreateOrConnectWithoutSalesExecutiveInput
    upsert?: BankDetailsUpsertWithoutSalesExecutiveInput
    disconnect?: BankDetailsWhereInput | boolean
    delete?: BankDetailsWhereInput | boolean
    connect?: BankDetailsWhereUniqueInput
    update?: XOR<XOR<BankDetailsUpdateToOneWithWhereWithoutSalesExecutiveInput, BankDetailsUpdateWithoutSalesExecutiveInput>, BankDetailsUncheckedUpdateWithoutSalesExecutiveInput>
  }

  export type UserCreateNestedOneWithoutStoreInput = {
    create?: XOR<UserCreateWithoutStoreInput, UserUncheckedCreateWithoutStoreInput>
    connectOrCreate?: UserCreateOrConnectWithoutStoreInput
    connect?: UserWhereUniqueInput
  }

  export type AddressCreateNestedOneWithoutStoreInput = {
    create?: XOR<AddressCreateWithoutStoreInput, AddressUncheckedCreateWithoutStoreInput>
    connectOrCreate?: AddressCreateOrConnectWithoutStoreInput
    connect?: AddressWhereUniqueInput
  }

  export type BankDetailsCreateNestedOneWithoutStoreInput = {
    create?: XOR<BankDetailsCreateWithoutStoreInput, BankDetailsUncheckedCreateWithoutStoreInput>
    connectOrCreate?: BankDetailsCreateOrConnectWithoutStoreInput
    connect?: BankDetailsWhereUniqueInput
  }

  export type AddressUncheckedCreateNestedOneWithoutStoreInput = {
    create?: XOR<AddressCreateWithoutStoreInput, AddressUncheckedCreateWithoutStoreInput>
    connectOrCreate?: AddressCreateOrConnectWithoutStoreInput
    connect?: AddressWhereUniqueInput
  }

  export type BankDetailsUncheckedCreateNestedOneWithoutStoreInput = {
    create?: XOR<BankDetailsCreateWithoutStoreInput, BankDetailsUncheckedCreateWithoutStoreInput>
    connectOrCreate?: BankDetailsCreateOrConnectWithoutStoreInput
    connect?: BankDetailsWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutStoreNestedInput = {
    create?: XOR<UserCreateWithoutStoreInput, UserUncheckedCreateWithoutStoreInput>
    connectOrCreate?: UserCreateOrConnectWithoutStoreInput
    upsert?: UserUpsertWithoutStoreInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStoreInput, UserUpdateWithoutStoreInput>, UserUncheckedUpdateWithoutStoreInput>
  }

  export type AddressUpdateOneWithoutStoreNestedInput = {
    create?: XOR<AddressCreateWithoutStoreInput, AddressUncheckedCreateWithoutStoreInput>
    connectOrCreate?: AddressCreateOrConnectWithoutStoreInput
    upsert?: AddressUpsertWithoutStoreInput
    disconnect?: AddressWhereInput | boolean
    delete?: AddressWhereInput | boolean
    connect?: AddressWhereUniqueInput
    update?: XOR<XOR<AddressUpdateToOneWithWhereWithoutStoreInput, AddressUpdateWithoutStoreInput>, AddressUncheckedUpdateWithoutStoreInput>
  }

  export type BankDetailsUpdateOneWithoutStoreNestedInput = {
    create?: XOR<BankDetailsCreateWithoutStoreInput, BankDetailsUncheckedCreateWithoutStoreInput>
    connectOrCreate?: BankDetailsCreateOrConnectWithoutStoreInput
    upsert?: BankDetailsUpsertWithoutStoreInput
    disconnect?: BankDetailsWhereInput | boolean
    delete?: BankDetailsWhereInput | boolean
    connect?: BankDetailsWhereUniqueInput
    update?: XOR<XOR<BankDetailsUpdateToOneWithWhereWithoutStoreInput, BankDetailsUpdateWithoutStoreInput>, BankDetailsUncheckedUpdateWithoutStoreInput>
  }

  export type AddressUncheckedUpdateOneWithoutStoreNestedInput = {
    create?: XOR<AddressCreateWithoutStoreInput, AddressUncheckedCreateWithoutStoreInput>
    connectOrCreate?: AddressCreateOrConnectWithoutStoreInput
    upsert?: AddressUpsertWithoutStoreInput
    disconnect?: AddressWhereInput | boolean
    delete?: AddressWhereInput | boolean
    connect?: AddressWhereUniqueInput
    update?: XOR<XOR<AddressUpdateToOneWithWhereWithoutStoreInput, AddressUpdateWithoutStoreInput>, AddressUncheckedUpdateWithoutStoreInput>
  }

  export type BankDetailsUncheckedUpdateOneWithoutStoreNestedInput = {
    create?: XOR<BankDetailsCreateWithoutStoreInput, BankDetailsUncheckedCreateWithoutStoreInput>
    connectOrCreate?: BankDetailsCreateOrConnectWithoutStoreInput
    upsert?: BankDetailsUpsertWithoutStoreInput
    disconnect?: BankDetailsWhereInput | boolean
    delete?: BankDetailsWhereInput | boolean
    connect?: BankDetailsWhereUniqueInput
    update?: XOR<XOR<BankDetailsUpdateToOneWithWhereWithoutStoreInput, BankDetailsUpdateWithoutStoreInput>, BankDetailsUncheckedUpdateWithoutStoreInput>
  }

  export type ManagerCreateNestedOneWithoutBankDetailsInput = {
    create?: XOR<ManagerCreateWithoutBankDetailsInput, ManagerUncheckedCreateWithoutBankDetailsInput>
    connectOrCreate?: ManagerCreateOrConnectWithoutBankDetailsInput
    connect?: ManagerWhereUniqueInput
  }

  export type TechnicianCreateNestedOneWithoutBankDetailsInput = {
    create?: XOR<TechnicianCreateWithoutBankDetailsInput, TechnicianUncheckedCreateWithoutBankDetailsInput>
    connectOrCreate?: TechnicianCreateOrConnectWithoutBankDetailsInput
    connect?: TechnicianWhereUniqueInput
  }

  export type FieldExecutiveCreateNestedOneWithoutBankDetailsInput = {
    create?: XOR<FieldExecutiveCreateWithoutBankDetailsInput, FieldExecutiveUncheckedCreateWithoutBankDetailsInput>
    connectOrCreate?: FieldExecutiveCreateOrConnectWithoutBankDetailsInput
    connect?: FieldExecutiveWhereUniqueInput
  }

  export type SalesExecutiveCreateNestedOneWithoutBankDetailsInput = {
    create?: XOR<SalesExecutiveCreateWithoutBankDetailsInput, SalesExecutiveUncheckedCreateWithoutBankDetailsInput>
    connectOrCreate?: SalesExecutiveCreateOrConnectWithoutBankDetailsInput
    connect?: SalesExecutiveWhereUniqueInput
  }

  export type StoreCreateNestedOneWithoutBankDetailsInput = {
    create?: XOR<StoreCreateWithoutBankDetailsInput, StoreUncheckedCreateWithoutBankDetailsInput>
    connectOrCreate?: StoreCreateOrConnectWithoutBankDetailsInput
    connect?: StoreWhereUniqueInput
  }

  export type ManagerUpdateOneWithoutBankDetailsNestedInput = {
    create?: XOR<ManagerCreateWithoutBankDetailsInput, ManagerUncheckedCreateWithoutBankDetailsInput>
    connectOrCreate?: ManagerCreateOrConnectWithoutBankDetailsInput
    upsert?: ManagerUpsertWithoutBankDetailsInput
    disconnect?: ManagerWhereInput | boolean
    delete?: ManagerWhereInput | boolean
    connect?: ManagerWhereUniqueInput
    update?: XOR<XOR<ManagerUpdateToOneWithWhereWithoutBankDetailsInput, ManagerUpdateWithoutBankDetailsInput>, ManagerUncheckedUpdateWithoutBankDetailsInput>
  }

  export type TechnicianUpdateOneWithoutBankDetailsNestedInput = {
    create?: XOR<TechnicianCreateWithoutBankDetailsInput, TechnicianUncheckedCreateWithoutBankDetailsInput>
    connectOrCreate?: TechnicianCreateOrConnectWithoutBankDetailsInput
    upsert?: TechnicianUpsertWithoutBankDetailsInput
    disconnect?: TechnicianWhereInput | boolean
    delete?: TechnicianWhereInput | boolean
    connect?: TechnicianWhereUniqueInput
    update?: XOR<XOR<TechnicianUpdateToOneWithWhereWithoutBankDetailsInput, TechnicianUpdateWithoutBankDetailsInput>, TechnicianUncheckedUpdateWithoutBankDetailsInput>
  }

  export type FieldExecutiveUpdateOneWithoutBankDetailsNestedInput = {
    create?: XOR<FieldExecutiveCreateWithoutBankDetailsInput, FieldExecutiveUncheckedCreateWithoutBankDetailsInput>
    connectOrCreate?: FieldExecutiveCreateOrConnectWithoutBankDetailsInput
    upsert?: FieldExecutiveUpsertWithoutBankDetailsInput
    disconnect?: FieldExecutiveWhereInput | boolean
    delete?: FieldExecutiveWhereInput | boolean
    connect?: FieldExecutiveWhereUniqueInput
    update?: XOR<XOR<FieldExecutiveUpdateToOneWithWhereWithoutBankDetailsInput, FieldExecutiveUpdateWithoutBankDetailsInput>, FieldExecutiveUncheckedUpdateWithoutBankDetailsInput>
  }

  export type SalesExecutiveUpdateOneWithoutBankDetailsNestedInput = {
    create?: XOR<SalesExecutiveCreateWithoutBankDetailsInput, SalesExecutiveUncheckedCreateWithoutBankDetailsInput>
    connectOrCreate?: SalesExecutiveCreateOrConnectWithoutBankDetailsInput
    upsert?: SalesExecutiveUpsertWithoutBankDetailsInput
    disconnect?: SalesExecutiveWhereInput | boolean
    delete?: SalesExecutiveWhereInput | boolean
    connect?: SalesExecutiveWhereUniqueInput
    update?: XOR<XOR<SalesExecutiveUpdateToOneWithWhereWithoutBankDetailsInput, SalesExecutiveUpdateWithoutBankDetailsInput>, SalesExecutiveUncheckedUpdateWithoutBankDetailsInput>
  }

  export type StoreUpdateOneWithoutBankDetailsNestedInput = {
    create?: XOR<StoreCreateWithoutBankDetailsInput, StoreUncheckedCreateWithoutBankDetailsInput>
    connectOrCreate?: StoreCreateOrConnectWithoutBankDetailsInput
    upsert?: StoreUpsertWithoutBankDetailsInput
    disconnect?: StoreWhereInput | boolean
    delete?: StoreWhereInput | boolean
    connect?: StoreWhereUniqueInput
    update?: XOR<XOR<StoreUpdateToOneWithWhereWithoutBankDetailsInput, StoreUpdateWithoutBankDetailsInput>, StoreUncheckedUpdateWithoutBankDetailsInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type ConnectivityTestResultCreateNestedManyWithoutDeviceTestInput = {
    create?: XOR<ConnectivityTestResultCreateWithoutDeviceTestInput, ConnectivityTestResultUncheckedCreateWithoutDeviceTestInput> | ConnectivityTestResultCreateWithoutDeviceTestInput[] | ConnectivityTestResultUncheckedCreateWithoutDeviceTestInput[]
    connectOrCreate?: ConnectivityTestResultCreateOrConnectWithoutDeviceTestInput | ConnectivityTestResultCreateOrConnectWithoutDeviceTestInput[]
    createMany?: ConnectivityTestResultCreateManyDeviceTestInputEnvelope
    connect?: ConnectivityTestResultWhereUniqueInput | ConnectivityTestResultWhereUniqueInput[]
  }

  export type SimTestResultCreateNestedManyWithoutDeviceTestInput = {
    create?: XOR<SimTestResultCreateWithoutDeviceTestInput, SimTestResultUncheckedCreateWithoutDeviceTestInput> | SimTestResultCreateWithoutDeviceTestInput[] | SimTestResultUncheckedCreateWithoutDeviceTestInput[]
    connectOrCreate?: SimTestResultCreateOrConnectWithoutDeviceTestInput | SimTestResultCreateOrConnectWithoutDeviceTestInput[]
    createMany?: SimTestResultCreateManyDeviceTestInputEnvelope
    connect?: SimTestResultWhereUniqueInput | SimTestResultWhereUniqueInput[]
  }

  export type DeviceTestResultCreateNestedManyWithoutDeviceTestInput = {
    create?: XOR<DeviceTestResultCreateWithoutDeviceTestInput, DeviceTestResultUncheckedCreateWithoutDeviceTestInput> | DeviceTestResultCreateWithoutDeviceTestInput[] | DeviceTestResultUncheckedCreateWithoutDeviceTestInput[]
    connectOrCreate?: DeviceTestResultCreateOrConnectWithoutDeviceTestInput | DeviceTestResultCreateOrConnectWithoutDeviceTestInput[]
    createMany?: DeviceTestResultCreateManyDeviceTestInputEnvelope
    connect?: DeviceTestResultWhereUniqueInput | DeviceTestResultWhereUniqueInput[]
  }

  export type ScreenTestCreateNestedOneWithoutDeviceTestInput = {
    create?: XOR<ScreenTestCreateWithoutDeviceTestInput, ScreenTestUncheckedCreateWithoutDeviceTestInput>
    connectOrCreate?: ScreenTestCreateOrConnectWithoutDeviceTestInput
    connect?: ScreenTestWhereUniqueInput
  }

  export type AudioTestCreateNestedOneWithoutDeviceTestInput = {
    create?: XOR<AudioTestCreateWithoutDeviceTestInput, AudioTestUncheckedCreateWithoutDeviceTestInput>
    connectOrCreate?: AudioTestCreateOrConnectWithoutDeviceTestInput
    connect?: AudioTestWhereUniqueInput
  }

  export type ProximitySensorTestCreateNestedOneWithoutDeviceTestInput = {
    create?: XOR<ProximitySensorTestCreateWithoutDeviceTestInput, ProximitySensorTestUncheckedCreateWithoutDeviceTestInput>
    connectOrCreate?: ProximitySensorTestCreateOrConnectWithoutDeviceTestInput
    connect?: ProximitySensorTestWhereUniqueInput
  }

  export type CameraTestCreateNestedOneWithoutDeviceTestInput = {
    create?: XOR<CameraTestCreateWithoutDeviceTestInput, CameraTestUncheckedCreateWithoutDeviceTestInput>
    connectOrCreate?: CameraTestCreateOrConnectWithoutDeviceTestInput
    connect?: CameraTestWhereUniqueInput
  }

  export type FingerprintTestCreateNestedOneWithoutDeviceTestInput = {
    create?: XOR<FingerprintTestCreateWithoutDeviceTestInput, FingerprintTestUncheckedCreateWithoutDeviceTestInput>
    connectOrCreate?: FingerprintTestCreateOrConnectWithoutDeviceTestInput
    connect?: FingerprintTestWhereUniqueInput
  }

  export type UsbTestCreateNestedOneWithoutDeviceTestInput = {
    create?: XOR<UsbTestCreateWithoutDeviceTestInput, UsbTestUncheckedCreateWithoutDeviceTestInput>
    connectOrCreate?: UsbTestCreateOrConnectWithoutDeviceTestInput
    connect?: UsbTestWhereUniqueInput
  }

  export type AudioJackTestCreateNestedOneWithoutDeviceTestInput = {
    create?: XOR<AudioJackTestCreateWithoutDeviceTestInput, AudioJackTestUncheckedCreateWithoutDeviceTestInput>
    connectOrCreate?: AudioJackTestCreateOrConnectWithoutDeviceTestInput
    connect?: AudioJackTestWhereUniqueInput
  }

  export type ConnectivityTestResultUncheckedCreateNestedManyWithoutDeviceTestInput = {
    create?: XOR<ConnectivityTestResultCreateWithoutDeviceTestInput, ConnectivityTestResultUncheckedCreateWithoutDeviceTestInput> | ConnectivityTestResultCreateWithoutDeviceTestInput[] | ConnectivityTestResultUncheckedCreateWithoutDeviceTestInput[]
    connectOrCreate?: ConnectivityTestResultCreateOrConnectWithoutDeviceTestInput | ConnectivityTestResultCreateOrConnectWithoutDeviceTestInput[]
    createMany?: ConnectivityTestResultCreateManyDeviceTestInputEnvelope
    connect?: ConnectivityTestResultWhereUniqueInput | ConnectivityTestResultWhereUniqueInput[]
  }

  export type SimTestResultUncheckedCreateNestedManyWithoutDeviceTestInput = {
    create?: XOR<SimTestResultCreateWithoutDeviceTestInput, SimTestResultUncheckedCreateWithoutDeviceTestInput> | SimTestResultCreateWithoutDeviceTestInput[] | SimTestResultUncheckedCreateWithoutDeviceTestInput[]
    connectOrCreate?: SimTestResultCreateOrConnectWithoutDeviceTestInput | SimTestResultCreateOrConnectWithoutDeviceTestInput[]
    createMany?: SimTestResultCreateManyDeviceTestInputEnvelope
    connect?: SimTestResultWhereUniqueInput | SimTestResultWhereUniqueInput[]
  }

  export type DeviceTestResultUncheckedCreateNestedManyWithoutDeviceTestInput = {
    create?: XOR<DeviceTestResultCreateWithoutDeviceTestInput, DeviceTestResultUncheckedCreateWithoutDeviceTestInput> | DeviceTestResultCreateWithoutDeviceTestInput[] | DeviceTestResultUncheckedCreateWithoutDeviceTestInput[]
    connectOrCreate?: DeviceTestResultCreateOrConnectWithoutDeviceTestInput | DeviceTestResultCreateOrConnectWithoutDeviceTestInput[]
    createMany?: DeviceTestResultCreateManyDeviceTestInputEnvelope
    connect?: DeviceTestResultWhereUniqueInput | DeviceTestResultWhereUniqueInput[]
  }

  export type ScreenTestUncheckedCreateNestedOneWithoutDeviceTestInput = {
    create?: XOR<ScreenTestCreateWithoutDeviceTestInput, ScreenTestUncheckedCreateWithoutDeviceTestInput>
    connectOrCreate?: ScreenTestCreateOrConnectWithoutDeviceTestInput
    connect?: ScreenTestWhereUniqueInput
  }

  export type AudioTestUncheckedCreateNestedOneWithoutDeviceTestInput = {
    create?: XOR<AudioTestCreateWithoutDeviceTestInput, AudioTestUncheckedCreateWithoutDeviceTestInput>
    connectOrCreate?: AudioTestCreateOrConnectWithoutDeviceTestInput
    connect?: AudioTestWhereUniqueInput
  }

  export type ProximitySensorTestUncheckedCreateNestedOneWithoutDeviceTestInput = {
    create?: XOR<ProximitySensorTestCreateWithoutDeviceTestInput, ProximitySensorTestUncheckedCreateWithoutDeviceTestInput>
    connectOrCreate?: ProximitySensorTestCreateOrConnectWithoutDeviceTestInput
    connect?: ProximitySensorTestWhereUniqueInput
  }

  export type CameraTestUncheckedCreateNestedOneWithoutDeviceTestInput = {
    create?: XOR<CameraTestCreateWithoutDeviceTestInput, CameraTestUncheckedCreateWithoutDeviceTestInput>
    connectOrCreate?: CameraTestCreateOrConnectWithoutDeviceTestInput
    connect?: CameraTestWhereUniqueInput
  }

  export type FingerprintTestUncheckedCreateNestedOneWithoutDeviceTestInput = {
    create?: XOR<FingerprintTestCreateWithoutDeviceTestInput, FingerprintTestUncheckedCreateWithoutDeviceTestInput>
    connectOrCreate?: FingerprintTestCreateOrConnectWithoutDeviceTestInput
    connect?: FingerprintTestWhereUniqueInput
  }

  export type UsbTestUncheckedCreateNestedOneWithoutDeviceTestInput = {
    create?: XOR<UsbTestCreateWithoutDeviceTestInput, UsbTestUncheckedCreateWithoutDeviceTestInput>
    connectOrCreate?: UsbTestCreateOrConnectWithoutDeviceTestInput
    connect?: UsbTestWhereUniqueInput
  }

  export type AudioJackTestUncheckedCreateNestedOneWithoutDeviceTestInput = {
    create?: XOR<AudioJackTestCreateWithoutDeviceTestInput, AudioJackTestUncheckedCreateWithoutDeviceTestInput>
    connectOrCreate?: AudioJackTestCreateOrConnectWithoutDeviceTestInput
    connect?: AudioJackTestWhereUniqueInput
  }

  export type ConnectivityTestResultUpdateManyWithoutDeviceTestNestedInput = {
    create?: XOR<ConnectivityTestResultCreateWithoutDeviceTestInput, ConnectivityTestResultUncheckedCreateWithoutDeviceTestInput> | ConnectivityTestResultCreateWithoutDeviceTestInput[] | ConnectivityTestResultUncheckedCreateWithoutDeviceTestInput[]
    connectOrCreate?: ConnectivityTestResultCreateOrConnectWithoutDeviceTestInput | ConnectivityTestResultCreateOrConnectWithoutDeviceTestInput[]
    upsert?: ConnectivityTestResultUpsertWithWhereUniqueWithoutDeviceTestInput | ConnectivityTestResultUpsertWithWhereUniqueWithoutDeviceTestInput[]
    createMany?: ConnectivityTestResultCreateManyDeviceTestInputEnvelope
    set?: ConnectivityTestResultWhereUniqueInput | ConnectivityTestResultWhereUniqueInput[]
    disconnect?: ConnectivityTestResultWhereUniqueInput | ConnectivityTestResultWhereUniqueInput[]
    delete?: ConnectivityTestResultWhereUniqueInput | ConnectivityTestResultWhereUniqueInput[]
    connect?: ConnectivityTestResultWhereUniqueInput | ConnectivityTestResultWhereUniqueInput[]
    update?: ConnectivityTestResultUpdateWithWhereUniqueWithoutDeviceTestInput | ConnectivityTestResultUpdateWithWhereUniqueWithoutDeviceTestInput[]
    updateMany?: ConnectivityTestResultUpdateManyWithWhereWithoutDeviceTestInput | ConnectivityTestResultUpdateManyWithWhereWithoutDeviceTestInput[]
    deleteMany?: ConnectivityTestResultScalarWhereInput | ConnectivityTestResultScalarWhereInput[]
  }

  export type SimTestResultUpdateManyWithoutDeviceTestNestedInput = {
    create?: XOR<SimTestResultCreateWithoutDeviceTestInput, SimTestResultUncheckedCreateWithoutDeviceTestInput> | SimTestResultCreateWithoutDeviceTestInput[] | SimTestResultUncheckedCreateWithoutDeviceTestInput[]
    connectOrCreate?: SimTestResultCreateOrConnectWithoutDeviceTestInput | SimTestResultCreateOrConnectWithoutDeviceTestInput[]
    upsert?: SimTestResultUpsertWithWhereUniqueWithoutDeviceTestInput | SimTestResultUpsertWithWhereUniqueWithoutDeviceTestInput[]
    createMany?: SimTestResultCreateManyDeviceTestInputEnvelope
    set?: SimTestResultWhereUniqueInput | SimTestResultWhereUniqueInput[]
    disconnect?: SimTestResultWhereUniqueInput | SimTestResultWhereUniqueInput[]
    delete?: SimTestResultWhereUniqueInput | SimTestResultWhereUniqueInput[]
    connect?: SimTestResultWhereUniqueInput | SimTestResultWhereUniqueInput[]
    update?: SimTestResultUpdateWithWhereUniqueWithoutDeviceTestInput | SimTestResultUpdateWithWhereUniqueWithoutDeviceTestInput[]
    updateMany?: SimTestResultUpdateManyWithWhereWithoutDeviceTestInput | SimTestResultUpdateManyWithWhereWithoutDeviceTestInput[]
    deleteMany?: SimTestResultScalarWhereInput | SimTestResultScalarWhereInput[]
  }

  export type DeviceTestResultUpdateManyWithoutDeviceTestNestedInput = {
    create?: XOR<DeviceTestResultCreateWithoutDeviceTestInput, DeviceTestResultUncheckedCreateWithoutDeviceTestInput> | DeviceTestResultCreateWithoutDeviceTestInput[] | DeviceTestResultUncheckedCreateWithoutDeviceTestInput[]
    connectOrCreate?: DeviceTestResultCreateOrConnectWithoutDeviceTestInput | DeviceTestResultCreateOrConnectWithoutDeviceTestInput[]
    upsert?: DeviceTestResultUpsertWithWhereUniqueWithoutDeviceTestInput | DeviceTestResultUpsertWithWhereUniqueWithoutDeviceTestInput[]
    createMany?: DeviceTestResultCreateManyDeviceTestInputEnvelope
    set?: DeviceTestResultWhereUniqueInput | DeviceTestResultWhereUniqueInput[]
    disconnect?: DeviceTestResultWhereUniqueInput | DeviceTestResultWhereUniqueInput[]
    delete?: DeviceTestResultWhereUniqueInput | DeviceTestResultWhereUniqueInput[]
    connect?: DeviceTestResultWhereUniqueInput | DeviceTestResultWhereUniqueInput[]
    update?: DeviceTestResultUpdateWithWhereUniqueWithoutDeviceTestInput | DeviceTestResultUpdateWithWhereUniqueWithoutDeviceTestInput[]
    updateMany?: DeviceTestResultUpdateManyWithWhereWithoutDeviceTestInput | DeviceTestResultUpdateManyWithWhereWithoutDeviceTestInput[]
    deleteMany?: DeviceTestResultScalarWhereInput | DeviceTestResultScalarWhereInput[]
  }

  export type ScreenTestUpdateOneWithoutDeviceTestNestedInput = {
    create?: XOR<ScreenTestCreateWithoutDeviceTestInput, ScreenTestUncheckedCreateWithoutDeviceTestInput>
    connectOrCreate?: ScreenTestCreateOrConnectWithoutDeviceTestInput
    upsert?: ScreenTestUpsertWithoutDeviceTestInput
    disconnect?: ScreenTestWhereInput | boolean
    delete?: ScreenTestWhereInput | boolean
    connect?: ScreenTestWhereUniqueInput
    update?: XOR<XOR<ScreenTestUpdateToOneWithWhereWithoutDeviceTestInput, ScreenTestUpdateWithoutDeviceTestInput>, ScreenTestUncheckedUpdateWithoutDeviceTestInput>
  }

  export type AudioTestUpdateOneWithoutDeviceTestNestedInput = {
    create?: XOR<AudioTestCreateWithoutDeviceTestInput, AudioTestUncheckedCreateWithoutDeviceTestInput>
    connectOrCreate?: AudioTestCreateOrConnectWithoutDeviceTestInput
    upsert?: AudioTestUpsertWithoutDeviceTestInput
    disconnect?: AudioTestWhereInput | boolean
    delete?: AudioTestWhereInput | boolean
    connect?: AudioTestWhereUniqueInput
    update?: XOR<XOR<AudioTestUpdateToOneWithWhereWithoutDeviceTestInput, AudioTestUpdateWithoutDeviceTestInput>, AudioTestUncheckedUpdateWithoutDeviceTestInput>
  }

  export type ProximitySensorTestUpdateOneWithoutDeviceTestNestedInput = {
    create?: XOR<ProximitySensorTestCreateWithoutDeviceTestInput, ProximitySensorTestUncheckedCreateWithoutDeviceTestInput>
    connectOrCreate?: ProximitySensorTestCreateOrConnectWithoutDeviceTestInput
    upsert?: ProximitySensorTestUpsertWithoutDeviceTestInput
    disconnect?: ProximitySensorTestWhereInput | boolean
    delete?: ProximitySensorTestWhereInput | boolean
    connect?: ProximitySensorTestWhereUniqueInput
    update?: XOR<XOR<ProximitySensorTestUpdateToOneWithWhereWithoutDeviceTestInput, ProximitySensorTestUpdateWithoutDeviceTestInput>, ProximitySensorTestUncheckedUpdateWithoutDeviceTestInput>
  }

  export type CameraTestUpdateOneWithoutDeviceTestNestedInput = {
    create?: XOR<CameraTestCreateWithoutDeviceTestInput, CameraTestUncheckedCreateWithoutDeviceTestInput>
    connectOrCreate?: CameraTestCreateOrConnectWithoutDeviceTestInput
    upsert?: CameraTestUpsertWithoutDeviceTestInput
    disconnect?: CameraTestWhereInput | boolean
    delete?: CameraTestWhereInput | boolean
    connect?: CameraTestWhereUniqueInput
    update?: XOR<XOR<CameraTestUpdateToOneWithWhereWithoutDeviceTestInput, CameraTestUpdateWithoutDeviceTestInput>, CameraTestUncheckedUpdateWithoutDeviceTestInput>
  }

  export type FingerprintTestUpdateOneWithoutDeviceTestNestedInput = {
    create?: XOR<FingerprintTestCreateWithoutDeviceTestInput, FingerprintTestUncheckedCreateWithoutDeviceTestInput>
    connectOrCreate?: FingerprintTestCreateOrConnectWithoutDeviceTestInput
    upsert?: FingerprintTestUpsertWithoutDeviceTestInput
    disconnect?: FingerprintTestWhereInput | boolean
    delete?: FingerprintTestWhereInput | boolean
    connect?: FingerprintTestWhereUniqueInput
    update?: XOR<XOR<FingerprintTestUpdateToOneWithWhereWithoutDeviceTestInput, FingerprintTestUpdateWithoutDeviceTestInput>, FingerprintTestUncheckedUpdateWithoutDeviceTestInput>
  }

  export type UsbTestUpdateOneWithoutDeviceTestNestedInput = {
    create?: XOR<UsbTestCreateWithoutDeviceTestInput, UsbTestUncheckedCreateWithoutDeviceTestInput>
    connectOrCreate?: UsbTestCreateOrConnectWithoutDeviceTestInput
    upsert?: UsbTestUpsertWithoutDeviceTestInput
    disconnect?: UsbTestWhereInput | boolean
    delete?: UsbTestWhereInput | boolean
    connect?: UsbTestWhereUniqueInput
    update?: XOR<XOR<UsbTestUpdateToOneWithWhereWithoutDeviceTestInput, UsbTestUpdateWithoutDeviceTestInput>, UsbTestUncheckedUpdateWithoutDeviceTestInput>
  }

  export type AudioJackTestUpdateOneWithoutDeviceTestNestedInput = {
    create?: XOR<AudioJackTestCreateWithoutDeviceTestInput, AudioJackTestUncheckedCreateWithoutDeviceTestInput>
    connectOrCreate?: AudioJackTestCreateOrConnectWithoutDeviceTestInput
    upsert?: AudioJackTestUpsertWithoutDeviceTestInput
    disconnect?: AudioJackTestWhereInput | boolean
    delete?: AudioJackTestWhereInput | boolean
    connect?: AudioJackTestWhereUniqueInput
    update?: XOR<XOR<AudioJackTestUpdateToOneWithWhereWithoutDeviceTestInput, AudioJackTestUpdateWithoutDeviceTestInput>, AudioJackTestUncheckedUpdateWithoutDeviceTestInput>
  }

  export type ConnectivityTestResultUncheckedUpdateManyWithoutDeviceTestNestedInput = {
    create?: XOR<ConnectivityTestResultCreateWithoutDeviceTestInput, ConnectivityTestResultUncheckedCreateWithoutDeviceTestInput> | ConnectivityTestResultCreateWithoutDeviceTestInput[] | ConnectivityTestResultUncheckedCreateWithoutDeviceTestInput[]
    connectOrCreate?: ConnectivityTestResultCreateOrConnectWithoutDeviceTestInput | ConnectivityTestResultCreateOrConnectWithoutDeviceTestInput[]
    upsert?: ConnectivityTestResultUpsertWithWhereUniqueWithoutDeviceTestInput | ConnectivityTestResultUpsertWithWhereUniqueWithoutDeviceTestInput[]
    createMany?: ConnectivityTestResultCreateManyDeviceTestInputEnvelope
    set?: ConnectivityTestResultWhereUniqueInput | ConnectivityTestResultWhereUniqueInput[]
    disconnect?: ConnectivityTestResultWhereUniqueInput | ConnectivityTestResultWhereUniqueInput[]
    delete?: ConnectivityTestResultWhereUniqueInput | ConnectivityTestResultWhereUniqueInput[]
    connect?: ConnectivityTestResultWhereUniqueInput | ConnectivityTestResultWhereUniqueInput[]
    update?: ConnectivityTestResultUpdateWithWhereUniqueWithoutDeviceTestInput | ConnectivityTestResultUpdateWithWhereUniqueWithoutDeviceTestInput[]
    updateMany?: ConnectivityTestResultUpdateManyWithWhereWithoutDeviceTestInput | ConnectivityTestResultUpdateManyWithWhereWithoutDeviceTestInput[]
    deleteMany?: ConnectivityTestResultScalarWhereInput | ConnectivityTestResultScalarWhereInput[]
  }

  export type SimTestResultUncheckedUpdateManyWithoutDeviceTestNestedInput = {
    create?: XOR<SimTestResultCreateWithoutDeviceTestInput, SimTestResultUncheckedCreateWithoutDeviceTestInput> | SimTestResultCreateWithoutDeviceTestInput[] | SimTestResultUncheckedCreateWithoutDeviceTestInput[]
    connectOrCreate?: SimTestResultCreateOrConnectWithoutDeviceTestInput | SimTestResultCreateOrConnectWithoutDeviceTestInput[]
    upsert?: SimTestResultUpsertWithWhereUniqueWithoutDeviceTestInput | SimTestResultUpsertWithWhereUniqueWithoutDeviceTestInput[]
    createMany?: SimTestResultCreateManyDeviceTestInputEnvelope
    set?: SimTestResultWhereUniqueInput | SimTestResultWhereUniqueInput[]
    disconnect?: SimTestResultWhereUniqueInput | SimTestResultWhereUniqueInput[]
    delete?: SimTestResultWhereUniqueInput | SimTestResultWhereUniqueInput[]
    connect?: SimTestResultWhereUniqueInput | SimTestResultWhereUniqueInput[]
    update?: SimTestResultUpdateWithWhereUniqueWithoutDeviceTestInput | SimTestResultUpdateWithWhereUniqueWithoutDeviceTestInput[]
    updateMany?: SimTestResultUpdateManyWithWhereWithoutDeviceTestInput | SimTestResultUpdateManyWithWhereWithoutDeviceTestInput[]
    deleteMany?: SimTestResultScalarWhereInput | SimTestResultScalarWhereInput[]
  }

  export type DeviceTestResultUncheckedUpdateManyWithoutDeviceTestNestedInput = {
    create?: XOR<DeviceTestResultCreateWithoutDeviceTestInput, DeviceTestResultUncheckedCreateWithoutDeviceTestInput> | DeviceTestResultCreateWithoutDeviceTestInput[] | DeviceTestResultUncheckedCreateWithoutDeviceTestInput[]
    connectOrCreate?: DeviceTestResultCreateOrConnectWithoutDeviceTestInput | DeviceTestResultCreateOrConnectWithoutDeviceTestInput[]
    upsert?: DeviceTestResultUpsertWithWhereUniqueWithoutDeviceTestInput | DeviceTestResultUpsertWithWhereUniqueWithoutDeviceTestInput[]
    createMany?: DeviceTestResultCreateManyDeviceTestInputEnvelope
    set?: DeviceTestResultWhereUniqueInput | DeviceTestResultWhereUniqueInput[]
    disconnect?: DeviceTestResultWhereUniqueInput | DeviceTestResultWhereUniqueInput[]
    delete?: DeviceTestResultWhereUniqueInput | DeviceTestResultWhereUniqueInput[]
    connect?: DeviceTestResultWhereUniqueInput | DeviceTestResultWhereUniqueInput[]
    update?: DeviceTestResultUpdateWithWhereUniqueWithoutDeviceTestInput | DeviceTestResultUpdateWithWhereUniqueWithoutDeviceTestInput[]
    updateMany?: DeviceTestResultUpdateManyWithWhereWithoutDeviceTestInput | DeviceTestResultUpdateManyWithWhereWithoutDeviceTestInput[]
    deleteMany?: DeviceTestResultScalarWhereInput | DeviceTestResultScalarWhereInput[]
  }

  export type ScreenTestUncheckedUpdateOneWithoutDeviceTestNestedInput = {
    create?: XOR<ScreenTestCreateWithoutDeviceTestInput, ScreenTestUncheckedCreateWithoutDeviceTestInput>
    connectOrCreate?: ScreenTestCreateOrConnectWithoutDeviceTestInput
    upsert?: ScreenTestUpsertWithoutDeviceTestInput
    disconnect?: ScreenTestWhereInput | boolean
    delete?: ScreenTestWhereInput | boolean
    connect?: ScreenTestWhereUniqueInput
    update?: XOR<XOR<ScreenTestUpdateToOneWithWhereWithoutDeviceTestInput, ScreenTestUpdateWithoutDeviceTestInput>, ScreenTestUncheckedUpdateWithoutDeviceTestInput>
  }

  export type AudioTestUncheckedUpdateOneWithoutDeviceTestNestedInput = {
    create?: XOR<AudioTestCreateWithoutDeviceTestInput, AudioTestUncheckedCreateWithoutDeviceTestInput>
    connectOrCreate?: AudioTestCreateOrConnectWithoutDeviceTestInput
    upsert?: AudioTestUpsertWithoutDeviceTestInput
    disconnect?: AudioTestWhereInput | boolean
    delete?: AudioTestWhereInput | boolean
    connect?: AudioTestWhereUniqueInput
    update?: XOR<XOR<AudioTestUpdateToOneWithWhereWithoutDeviceTestInput, AudioTestUpdateWithoutDeviceTestInput>, AudioTestUncheckedUpdateWithoutDeviceTestInput>
  }

  export type ProximitySensorTestUncheckedUpdateOneWithoutDeviceTestNestedInput = {
    create?: XOR<ProximitySensorTestCreateWithoutDeviceTestInput, ProximitySensorTestUncheckedCreateWithoutDeviceTestInput>
    connectOrCreate?: ProximitySensorTestCreateOrConnectWithoutDeviceTestInput
    upsert?: ProximitySensorTestUpsertWithoutDeviceTestInput
    disconnect?: ProximitySensorTestWhereInput | boolean
    delete?: ProximitySensorTestWhereInput | boolean
    connect?: ProximitySensorTestWhereUniqueInput
    update?: XOR<XOR<ProximitySensorTestUpdateToOneWithWhereWithoutDeviceTestInput, ProximitySensorTestUpdateWithoutDeviceTestInput>, ProximitySensorTestUncheckedUpdateWithoutDeviceTestInput>
  }

  export type CameraTestUncheckedUpdateOneWithoutDeviceTestNestedInput = {
    create?: XOR<CameraTestCreateWithoutDeviceTestInput, CameraTestUncheckedCreateWithoutDeviceTestInput>
    connectOrCreate?: CameraTestCreateOrConnectWithoutDeviceTestInput
    upsert?: CameraTestUpsertWithoutDeviceTestInput
    disconnect?: CameraTestWhereInput | boolean
    delete?: CameraTestWhereInput | boolean
    connect?: CameraTestWhereUniqueInput
    update?: XOR<XOR<CameraTestUpdateToOneWithWhereWithoutDeviceTestInput, CameraTestUpdateWithoutDeviceTestInput>, CameraTestUncheckedUpdateWithoutDeviceTestInput>
  }

  export type FingerprintTestUncheckedUpdateOneWithoutDeviceTestNestedInput = {
    create?: XOR<FingerprintTestCreateWithoutDeviceTestInput, FingerprintTestUncheckedCreateWithoutDeviceTestInput>
    connectOrCreate?: FingerprintTestCreateOrConnectWithoutDeviceTestInput
    upsert?: FingerprintTestUpsertWithoutDeviceTestInput
    disconnect?: FingerprintTestWhereInput | boolean
    delete?: FingerprintTestWhereInput | boolean
    connect?: FingerprintTestWhereUniqueInput
    update?: XOR<XOR<FingerprintTestUpdateToOneWithWhereWithoutDeviceTestInput, FingerprintTestUpdateWithoutDeviceTestInput>, FingerprintTestUncheckedUpdateWithoutDeviceTestInput>
  }

  export type UsbTestUncheckedUpdateOneWithoutDeviceTestNestedInput = {
    create?: XOR<UsbTestCreateWithoutDeviceTestInput, UsbTestUncheckedCreateWithoutDeviceTestInput>
    connectOrCreate?: UsbTestCreateOrConnectWithoutDeviceTestInput
    upsert?: UsbTestUpsertWithoutDeviceTestInput
    disconnect?: UsbTestWhereInput | boolean
    delete?: UsbTestWhereInput | boolean
    connect?: UsbTestWhereUniqueInput
    update?: XOR<XOR<UsbTestUpdateToOneWithWhereWithoutDeviceTestInput, UsbTestUpdateWithoutDeviceTestInput>, UsbTestUncheckedUpdateWithoutDeviceTestInput>
  }

  export type AudioJackTestUncheckedUpdateOneWithoutDeviceTestNestedInput = {
    create?: XOR<AudioJackTestCreateWithoutDeviceTestInput, AudioJackTestUncheckedCreateWithoutDeviceTestInput>
    connectOrCreate?: AudioJackTestCreateOrConnectWithoutDeviceTestInput
    upsert?: AudioJackTestUpsertWithoutDeviceTestInput
    disconnect?: AudioJackTestWhereInput | boolean
    delete?: AudioJackTestWhereInput | boolean
    connect?: AudioJackTestWhereUniqueInput
    update?: XOR<XOR<AudioJackTestUpdateToOneWithWhereWithoutDeviceTestInput, AudioJackTestUpdateWithoutDeviceTestInput>, AudioJackTestUncheckedUpdateWithoutDeviceTestInput>
  }

  export type DeviceTestCreateNestedOneWithoutConnectivityTestResultsInput = {
    create?: XOR<DeviceTestCreateWithoutConnectivityTestResultsInput, DeviceTestUncheckedCreateWithoutConnectivityTestResultsInput>
    connectOrCreate?: DeviceTestCreateOrConnectWithoutConnectivityTestResultsInput
    connect?: DeviceTestWhereUniqueInput
  }

  export type DeviceTestUpdateOneRequiredWithoutConnectivityTestResultsNestedInput = {
    create?: XOR<DeviceTestCreateWithoutConnectivityTestResultsInput, DeviceTestUncheckedCreateWithoutConnectivityTestResultsInput>
    connectOrCreate?: DeviceTestCreateOrConnectWithoutConnectivityTestResultsInput
    upsert?: DeviceTestUpsertWithoutConnectivityTestResultsInput
    connect?: DeviceTestWhereUniqueInput
    update?: XOR<XOR<DeviceTestUpdateToOneWithWhereWithoutConnectivityTestResultsInput, DeviceTestUpdateWithoutConnectivityTestResultsInput>, DeviceTestUncheckedUpdateWithoutConnectivityTestResultsInput>
  }

  export type DeviceTestCreateNestedOneWithoutDeviceTestResultsInput = {
    create?: XOR<DeviceTestCreateWithoutDeviceTestResultsInput, DeviceTestUncheckedCreateWithoutDeviceTestResultsInput>
    connectOrCreate?: DeviceTestCreateOrConnectWithoutDeviceTestResultsInput
    connect?: DeviceTestWhereUniqueInput
  }

  export type DeviceTestUpdateOneRequiredWithoutDeviceTestResultsNestedInput = {
    create?: XOR<DeviceTestCreateWithoutDeviceTestResultsInput, DeviceTestUncheckedCreateWithoutDeviceTestResultsInput>
    connectOrCreate?: DeviceTestCreateOrConnectWithoutDeviceTestResultsInput
    upsert?: DeviceTestUpsertWithoutDeviceTestResultsInput
    connect?: DeviceTestWhereUniqueInput
    update?: XOR<XOR<DeviceTestUpdateToOneWithWhereWithoutDeviceTestResultsInput, DeviceTestUpdateWithoutDeviceTestResultsInput>, DeviceTestUncheckedUpdateWithoutDeviceTestResultsInput>
  }

  export type DeviceTestCreateNestedOneWithoutSimTestResultsInput = {
    create?: XOR<DeviceTestCreateWithoutSimTestResultsInput, DeviceTestUncheckedCreateWithoutSimTestResultsInput>
    connectOrCreate?: DeviceTestCreateOrConnectWithoutSimTestResultsInput
    connect?: DeviceTestWhereUniqueInput
  }

  export type DeviceTestUpdateOneRequiredWithoutSimTestResultsNestedInput = {
    create?: XOR<DeviceTestCreateWithoutSimTestResultsInput, DeviceTestUncheckedCreateWithoutSimTestResultsInput>
    connectOrCreate?: DeviceTestCreateOrConnectWithoutSimTestResultsInput
    upsert?: DeviceTestUpsertWithoutSimTestResultsInput
    connect?: DeviceTestWhereUniqueInput
    update?: XOR<XOR<DeviceTestUpdateToOneWithWhereWithoutSimTestResultsInput, DeviceTestUpdateWithoutSimTestResultsInput>, DeviceTestUncheckedUpdateWithoutSimTestResultsInput>
  }

  export type DeviceTestCreateNestedOneWithoutScreenTestInput = {
    create?: XOR<DeviceTestCreateWithoutScreenTestInput, DeviceTestUncheckedCreateWithoutScreenTestInput>
    connectOrCreate?: DeviceTestCreateOrConnectWithoutScreenTestInput
    connect?: DeviceTestWhereUniqueInput
  }

  export type DeviceTestUpdateOneRequiredWithoutScreenTestNestedInput = {
    create?: XOR<DeviceTestCreateWithoutScreenTestInput, DeviceTestUncheckedCreateWithoutScreenTestInput>
    connectOrCreate?: DeviceTestCreateOrConnectWithoutScreenTestInput
    upsert?: DeviceTestUpsertWithoutScreenTestInput
    connect?: DeviceTestWhereUniqueInput
    update?: XOR<XOR<DeviceTestUpdateToOneWithWhereWithoutScreenTestInput, DeviceTestUpdateWithoutScreenTestInput>, DeviceTestUncheckedUpdateWithoutScreenTestInput>
  }

  export type DeviceTestCreateNestedOneWithoutAudioTestInput = {
    create?: XOR<DeviceTestCreateWithoutAudioTestInput, DeviceTestUncheckedCreateWithoutAudioTestInput>
    connectOrCreate?: DeviceTestCreateOrConnectWithoutAudioTestInput
    connect?: DeviceTestWhereUniqueInput
  }

  export type DeviceTestUpdateOneRequiredWithoutAudioTestNestedInput = {
    create?: XOR<DeviceTestCreateWithoutAudioTestInput, DeviceTestUncheckedCreateWithoutAudioTestInput>
    connectOrCreate?: DeviceTestCreateOrConnectWithoutAudioTestInput
    upsert?: DeviceTestUpsertWithoutAudioTestInput
    connect?: DeviceTestWhereUniqueInput
    update?: XOR<XOR<DeviceTestUpdateToOneWithWhereWithoutAudioTestInput, DeviceTestUpdateWithoutAudioTestInput>, DeviceTestUncheckedUpdateWithoutAudioTestInput>
  }

  export type DeviceTestCreateNestedOneWithoutProximitySensorTestInput = {
    create?: XOR<DeviceTestCreateWithoutProximitySensorTestInput, DeviceTestUncheckedCreateWithoutProximitySensorTestInput>
    connectOrCreate?: DeviceTestCreateOrConnectWithoutProximitySensorTestInput
    connect?: DeviceTestWhereUniqueInput
  }

  export type DeviceTestUpdateOneRequiredWithoutProximitySensorTestNestedInput = {
    create?: XOR<DeviceTestCreateWithoutProximitySensorTestInput, DeviceTestUncheckedCreateWithoutProximitySensorTestInput>
    connectOrCreate?: DeviceTestCreateOrConnectWithoutProximitySensorTestInput
    upsert?: DeviceTestUpsertWithoutProximitySensorTestInput
    connect?: DeviceTestWhereUniqueInput
    update?: XOR<XOR<DeviceTestUpdateToOneWithWhereWithoutProximitySensorTestInput, DeviceTestUpdateWithoutProximitySensorTestInput>, DeviceTestUncheckedUpdateWithoutProximitySensorTestInput>
  }

  export type DeviceTestCreateNestedOneWithoutCameraTestInput = {
    create?: XOR<DeviceTestCreateWithoutCameraTestInput, DeviceTestUncheckedCreateWithoutCameraTestInput>
    connectOrCreate?: DeviceTestCreateOrConnectWithoutCameraTestInput
    connect?: DeviceTestWhereUniqueInput
  }

  export type DeviceTestUpdateOneRequiredWithoutCameraTestNestedInput = {
    create?: XOR<DeviceTestCreateWithoutCameraTestInput, DeviceTestUncheckedCreateWithoutCameraTestInput>
    connectOrCreate?: DeviceTestCreateOrConnectWithoutCameraTestInput
    upsert?: DeviceTestUpsertWithoutCameraTestInput
    connect?: DeviceTestWhereUniqueInput
    update?: XOR<XOR<DeviceTestUpdateToOneWithWhereWithoutCameraTestInput, DeviceTestUpdateWithoutCameraTestInput>, DeviceTestUncheckedUpdateWithoutCameraTestInput>
  }

  export type DeviceTestCreateNestedOneWithoutFingerprintTestInput = {
    create?: XOR<DeviceTestCreateWithoutFingerprintTestInput, DeviceTestUncheckedCreateWithoutFingerprintTestInput>
    connectOrCreate?: DeviceTestCreateOrConnectWithoutFingerprintTestInput
    connect?: DeviceTestWhereUniqueInput
  }

  export type DeviceTestUpdateOneRequiredWithoutFingerprintTestNestedInput = {
    create?: XOR<DeviceTestCreateWithoutFingerprintTestInput, DeviceTestUncheckedCreateWithoutFingerprintTestInput>
    connectOrCreate?: DeviceTestCreateOrConnectWithoutFingerprintTestInput
    upsert?: DeviceTestUpsertWithoutFingerprintTestInput
    connect?: DeviceTestWhereUniqueInput
    update?: XOR<XOR<DeviceTestUpdateToOneWithWhereWithoutFingerprintTestInput, DeviceTestUpdateWithoutFingerprintTestInput>, DeviceTestUncheckedUpdateWithoutFingerprintTestInput>
  }

  export type DeviceTestCreateNestedOneWithoutUsbTestInput = {
    create?: XOR<DeviceTestCreateWithoutUsbTestInput, DeviceTestUncheckedCreateWithoutUsbTestInput>
    connectOrCreate?: DeviceTestCreateOrConnectWithoutUsbTestInput
    connect?: DeviceTestWhereUniqueInput
  }

  export type DeviceTestUpdateOneRequiredWithoutUsbTestNestedInput = {
    create?: XOR<DeviceTestCreateWithoutUsbTestInput, DeviceTestUncheckedCreateWithoutUsbTestInput>
    connectOrCreate?: DeviceTestCreateOrConnectWithoutUsbTestInput
    upsert?: DeviceTestUpsertWithoutUsbTestInput
    connect?: DeviceTestWhereUniqueInput
    update?: XOR<XOR<DeviceTestUpdateToOneWithWhereWithoutUsbTestInput, DeviceTestUpdateWithoutUsbTestInput>, DeviceTestUncheckedUpdateWithoutUsbTestInput>
  }

  export type DeviceTestCreateNestedOneWithoutAudioJackTestInput = {
    create?: XOR<DeviceTestCreateWithoutAudioJackTestInput, DeviceTestUncheckedCreateWithoutAudioJackTestInput>
    connectOrCreate?: DeviceTestCreateOrConnectWithoutAudioJackTestInput
    connect?: DeviceTestWhereUniqueInput
  }

  export type DeviceTestUpdateOneRequiredWithoutAudioJackTestNestedInput = {
    create?: XOR<DeviceTestCreateWithoutAudioJackTestInput, DeviceTestUncheckedCreateWithoutAudioJackTestInput>
    connectOrCreate?: DeviceTestCreateOrConnectWithoutAudioJackTestInput
    upsert?: DeviceTestUpsertWithoutAudioJackTestInput
    connect?: DeviceTestWhereUniqueInput
    update?: XOR<XOR<DeviceTestUpdateToOneWithWhereWithoutAudioJackTestInput, DeviceTestUpdateWithoutAudioJackTestInput>, DeviceTestUncheckedUpdateWithoutAudioJackTestInput>
  }

  export type StoreCreateNestedOneWithoutAddressInput = {
    create?: XOR<StoreCreateWithoutAddressInput, StoreUncheckedCreateWithoutAddressInput>
    connectOrCreate?: StoreCreateOrConnectWithoutAddressInput
    connect?: StoreWhereUniqueInput
  }

  export type StoreUpdateOneRequiredWithoutAddressNestedInput = {
    create?: XOR<StoreCreateWithoutAddressInput, StoreUncheckedCreateWithoutAddressInput>
    connectOrCreate?: StoreCreateOrConnectWithoutAddressInput
    upsert?: StoreUpsertWithoutAddressInput
    connect?: StoreWhereUniqueInput
    update?: XOR<XOR<StoreUpdateToOneWithWhereWithoutAddressInput, StoreUpdateWithoutAddressInput>, StoreUncheckedUpdateWithoutAddressInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CustomModelCreateNestedManyWithoutBrandInput = {
    create?: XOR<CustomModelCreateWithoutBrandInput, CustomModelUncheckedCreateWithoutBrandInput> | CustomModelCreateWithoutBrandInput[] | CustomModelUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: CustomModelCreateOrConnectWithoutBrandInput | CustomModelCreateOrConnectWithoutBrandInput[]
    createMany?: CustomModelCreateManyBrandInputEnvelope
    connect?: CustomModelWhereUniqueInput | CustomModelWhereUniqueInput[]
  }

  export type CustomModelUncheckedCreateNestedManyWithoutBrandInput = {
    create?: XOR<CustomModelCreateWithoutBrandInput, CustomModelUncheckedCreateWithoutBrandInput> | CustomModelCreateWithoutBrandInput[] | CustomModelUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: CustomModelCreateOrConnectWithoutBrandInput | CustomModelCreateOrConnectWithoutBrandInput[]
    createMany?: CustomModelCreateManyBrandInputEnvelope
    connect?: CustomModelWhereUniqueInput | CustomModelWhereUniqueInput[]
  }

  export type CustomModelUpdateManyWithoutBrandNestedInput = {
    create?: XOR<CustomModelCreateWithoutBrandInput, CustomModelUncheckedCreateWithoutBrandInput> | CustomModelCreateWithoutBrandInput[] | CustomModelUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: CustomModelCreateOrConnectWithoutBrandInput | CustomModelCreateOrConnectWithoutBrandInput[]
    upsert?: CustomModelUpsertWithWhereUniqueWithoutBrandInput | CustomModelUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: CustomModelCreateManyBrandInputEnvelope
    set?: CustomModelWhereUniqueInput | CustomModelWhereUniqueInput[]
    disconnect?: CustomModelWhereUniqueInput | CustomModelWhereUniqueInput[]
    delete?: CustomModelWhereUniqueInput | CustomModelWhereUniqueInput[]
    connect?: CustomModelWhereUniqueInput | CustomModelWhereUniqueInput[]
    update?: CustomModelUpdateWithWhereUniqueWithoutBrandInput | CustomModelUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: CustomModelUpdateManyWithWhereWithoutBrandInput | CustomModelUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: CustomModelScalarWhereInput | CustomModelScalarWhereInput[]
  }

  export type CustomModelUncheckedUpdateManyWithoutBrandNestedInput = {
    create?: XOR<CustomModelCreateWithoutBrandInput, CustomModelUncheckedCreateWithoutBrandInput> | CustomModelCreateWithoutBrandInput[] | CustomModelUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: CustomModelCreateOrConnectWithoutBrandInput | CustomModelCreateOrConnectWithoutBrandInput[]
    upsert?: CustomModelUpsertWithWhereUniqueWithoutBrandInput | CustomModelUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: CustomModelCreateManyBrandInputEnvelope
    set?: CustomModelWhereUniqueInput | CustomModelWhereUniqueInput[]
    disconnect?: CustomModelWhereUniqueInput | CustomModelWhereUniqueInput[]
    delete?: CustomModelWhereUniqueInput | CustomModelWhereUniqueInput[]
    connect?: CustomModelWhereUniqueInput | CustomModelWhereUniqueInput[]
    update?: CustomModelUpdateWithWhereUniqueWithoutBrandInput | CustomModelUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: CustomModelUpdateManyWithWhereWithoutBrandInput | CustomModelUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: CustomModelScalarWhereInput | CustomModelScalarWhereInput[]
  }

  export type CustomModelBrandCreateNestedOneWithoutModelsInput = {
    create?: XOR<CustomModelBrandCreateWithoutModelsInput, CustomModelBrandUncheckedCreateWithoutModelsInput>
    connectOrCreate?: CustomModelBrandCreateOrConnectWithoutModelsInput
    connect?: CustomModelBrandWhereUniqueInput
  }

  export type CustomModelBrandUpdateOneRequiredWithoutModelsNestedInput = {
    create?: XOR<CustomModelBrandCreateWithoutModelsInput, CustomModelBrandUncheckedCreateWithoutModelsInput>
    connectOrCreate?: CustomModelBrandCreateOrConnectWithoutModelsInput
    upsert?: CustomModelBrandUpsertWithoutModelsInput
    connect?: CustomModelBrandWhereUniqueInput
    update?: XOR<XOR<CustomModelBrandUpdateToOneWithWhereWithoutModelsInput, CustomModelBrandUpdateWithoutModelsInput>, CustomModelBrandUncheckedUpdateWithoutModelsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumRoleNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel> | null
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRoleNullableFilter<$PrismaModel> | $Enums.Role | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumUserStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusFilter<$PrismaModel> | $Enums.UserStatus
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumRoleNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel> | null
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRoleNullableWithAggregatesFilter<$PrismaModel> | $Enums.Role | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumRoleNullableFilter<$PrismaModel>
    _max?: NestedEnumRoleNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumUserStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusWithAggregatesFilter<$PrismaModel> | $Enums.UserStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserStatusFilter<$PrismaModel>
    _max?: NestedEnumUserStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    expiresAt: Date | string
    createdAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    device?: string | null
    browser?: string | null
    os?: string | null
    location?: string | null
    latitude?: number | null
    longitude?: number | null
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    expiresAt: Date | string
    createdAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    device?: string | null
    browser?: string | null
    os?: string | null
    location?: string | null
    latitude?: number | null
    longitude?: number | null
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ManagerCreateWithoutUserInput = {
    firstName: string
    lastName: string
    employeeId: string
    aadharId: string
    bankDetails?: BankDetailsCreateNestedOneWithoutManagerInput
  }

  export type ManagerUncheckedCreateWithoutUserInput = {
    firstName: string
    lastName: string
    employeeId: string
    aadharId: string
    bankDetails?: BankDetailsUncheckedCreateNestedOneWithoutManagerInput
  }

  export type ManagerCreateOrConnectWithoutUserInput = {
    where: ManagerWhereUniqueInput
    create: XOR<ManagerCreateWithoutUserInput, ManagerUncheckedCreateWithoutUserInput>
  }

  export type TechnicianCreateWithoutUserInput = {
    firstName: string
    lastName: string
    employeeId: string
    aadharId: string
    bankDetails?: BankDetailsCreateNestedOneWithoutTechnicianInput
  }

  export type TechnicianUncheckedCreateWithoutUserInput = {
    firstName: string
    lastName: string
    employeeId: string
    aadharId: string
    bankDetails?: BankDetailsUncheckedCreateNestedOneWithoutTechnicianInput
  }

  export type TechnicianCreateOrConnectWithoutUserInput = {
    where: TechnicianWhereUniqueInput
    create: XOR<TechnicianCreateWithoutUserInput, TechnicianUncheckedCreateWithoutUserInput>
  }

  export type FieldExecutiveCreateWithoutUserInput = {
    firstName: string
    lastName: string
    employeeId: string
    aadharId: string
    bankDetails?: BankDetailsCreateNestedOneWithoutFieldExecutiveInput
  }

  export type FieldExecutiveUncheckedCreateWithoutUserInput = {
    firstName: string
    lastName: string
    employeeId: string
    aadharId: string
    bankDetails?: BankDetailsUncheckedCreateNestedOneWithoutFieldExecutiveInput
  }

  export type FieldExecutiveCreateOrConnectWithoutUserInput = {
    where: FieldExecutiveWhereUniqueInput
    create: XOR<FieldExecutiveCreateWithoutUserInput, FieldExecutiveUncheckedCreateWithoutUserInput>
  }

  export type SalesExecutiveCreateWithoutUserInput = {
    firstName: string
    lastName: string
    employeeId: string
    aadharId: string
    bankDetails?: BankDetailsCreateNestedOneWithoutSalesExecutiveInput
  }

  export type SalesExecutiveUncheckedCreateWithoutUserInput = {
    firstName: string
    lastName: string
    employeeId: string
    aadharId: string
    bankDetails?: BankDetailsUncheckedCreateNestedOneWithoutSalesExecutiveInput
  }

  export type SalesExecutiveCreateOrConnectWithoutUserInput = {
    where: SalesExecutiveWhereUniqueInput
    create: XOR<SalesExecutiveCreateWithoutUserInput, SalesExecutiveUncheckedCreateWithoutUserInput>
  }

  export type StoreCreateWithoutUserInput = {
    storeId: string
    storeName: string
    ownerName: string
    ownerPhone: string
    ownerEmail: string
    createdAt?: Date | string
    updatedAt?: Date | string
    address?: AddressCreateNestedOneWithoutStoreInput
    bankDetails?: BankDetailsCreateNestedOneWithoutStoreInput
  }

  export type StoreUncheckedCreateWithoutUserInput = {
    storeId: string
    storeName: string
    ownerName: string
    ownerPhone: string
    ownerEmail: string
    createdAt?: Date | string
    updatedAt?: Date | string
    address?: AddressUncheckedCreateNestedOneWithoutStoreInput
    bankDetails?: BankDetailsUncheckedCreateNestedOneWithoutStoreInput
  }

  export type StoreCreateOrConnectWithoutUserInput = {
    where: StoreWhereUniqueInput
    create: XOR<StoreCreateWithoutUserInput, StoreUncheckedCreateWithoutUserInput>
  }

  export type AdminCreateWithoutUserInput = {
    employeeId: string
    firstName?: string | null
    lastName?: string | null
  }

  export type AdminUncheckedCreateWithoutUserInput = {
    employeeId: string
    firstName?: string | null
    lastName?: string | null
  }

  export type AdminCreateOrConnectWithoutUserInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    device?: StringNullableFilter<"Session"> | string | null
    browser?: StringNullableFilter<"Session"> | string | null
    os?: StringNullableFilter<"Session"> | string | null
    location?: StringNullableFilter<"Session"> | string | null
    latitude?: FloatNullableFilter<"Session"> | number | null
    longitude?: FloatNullableFilter<"Session"> | number | null
  }

  export type ManagerUpsertWithoutUserInput = {
    update: XOR<ManagerUpdateWithoutUserInput, ManagerUncheckedUpdateWithoutUserInput>
    create: XOR<ManagerCreateWithoutUserInput, ManagerUncheckedCreateWithoutUserInput>
    where?: ManagerWhereInput
  }

  export type ManagerUpdateToOneWithWhereWithoutUserInput = {
    where?: ManagerWhereInput
    data: XOR<ManagerUpdateWithoutUserInput, ManagerUncheckedUpdateWithoutUserInput>
  }

  export type ManagerUpdateWithoutUserInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    aadharId?: StringFieldUpdateOperationsInput | string
    bankDetails?: BankDetailsUpdateOneWithoutManagerNestedInput
  }

  export type ManagerUncheckedUpdateWithoutUserInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    aadharId?: StringFieldUpdateOperationsInput | string
    bankDetails?: BankDetailsUncheckedUpdateOneWithoutManagerNestedInput
  }

  export type TechnicianUpsertWithoutUserInput = {
    update: XOR<TechnicianUpdateWithoutUserInput, TechnicianUncheckedUpdateWithoutUserInput>
    create: XOR<TechnicianCreateWithoutUserInput, TechnicianUncheckedCreateWithoutUserInput>
    where?: TechnicianWhereInput
  }

  export type TechnicianUpdateToOneWithWhereWithoutUserInput = {
    where?: TechnicianWhereInput
    data: XOR<TechnicianUpdateWithoutUserInput, TechnicianUncheckedUpdateWithoutUserInput>
  }

  export type TechnicianUpdateWithoutUserInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    aadharId?: StringFieldUpdateOperationsInput | string
    bankDetails?: BankDetailsUpdateOneWithoutTechnicianNestedInput
  }

  export type TechnicianUncheckedUpdateWithoutUserInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    aadharId?: StringFieldUpdateOperationsInput | string
    bankDetails?: BankDetailsUncheckedUpdateOneWithoutTechnicianNestedInput
  }

  export type FieldExecutiveUpsertWithoutUserInput = {
    update: XOR<FieldExecutiveUpdateWithoutUserInput, FieldExecutiveUncheckedUpdateWithoutUserInput>
    create: XOR<FieldExecutiveCreateWithoutUserInput, FieldExecutiveUncheckedCreateWithoutUserInput>
    where?: FieldExecutiveWhereInput
  }

  export type FieldExecutiveUpdateToOneWithWhereWithoutUserInput = {
    where?: FieldExecutiveWhereInput
    data: XOR<FieldExecutiveUpdateWithoutUserInput, FieldExecutiveUncheckedUpdateWithoutUserInput>
  }

  export type FieldExecutiveUpdateWithoutUserInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    aadharId?: StringFieldUpdateOperationsInput | string
    bankDetails?: BankDetailsUpdateOneWithoutFieldExecutiveNestedInput
  }

  export type FieldExecutiveUncheckedUpdateWithoutUserInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    aadharId?: StringFieldUpdateOperationsInput | string
    bankDetails?: BankDetailsUncheckedUpdateOneWithoutFieldExecutiveNestedInput
  }

  export type SalesExecutiveUpsertWithoutUserInput = {
    update: XOR<SalesExecutiveUpdateWithoutUserInput, SalesExecutiveUncheckedUpdateWithoutUserInput>
    create: XOR<SalesExecutiveCreateWithoutUserInput, SalesExecutiveUncheckedCreateWithoutUserInput>
    where?: SalesExecutiveWhereInput
  }

  export type SalesExecutiveUpdateToOneWithWhereWithoutUserInput = {
    where?: SalesExecutiveWhereInput
    data: XOR<SalesExecutiveUpdateWithoutUserInput, SalesExecutiveUncheckedUpdateWithoutUserInput>
  }

  export type SalesExecutiveUpdateWithoutUserInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    aadharId?: StringFieldUpdateOperationsInput | string
    bankDetails?: BankDetailsUpdateOneWithoutSalesExecutiveNestedInput
  }

  export type SalesExecutiveUncheckedUpdateWithoutUserInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    aadharId?: StringFieldUpdateOperationsInput | string
    bankDetails?: BankDetailsUncheckedUpdateOneWithoutSalesExecutiveNestedInput
  }

  export type StoreUpsertWithoutUserInput = {
    update: XOR<StoreUpdateWithoutUserInput, StoreUncheckedUpdateWithoutUserInput>
    create: XOR<StoreCreateWithoutUserInput, StoreUncheckedCreateWithoutUserInput>
    where?: StoreWhereInput
  }

  export type StoreUpdateToOneWithWhereWithoutUserInput = {
    where?: StoreWhereInput
    data: XOR<StoreUpdateWithoutUserInput, StoreUncheckedUpdateWithoutUserInput>
  }

  export type StoreUpdateWithoutUserInput = {
    storeId?: StringFieldUpdateOperationsInput | string
    storeName?: StringFieldUpdateOperationsInput | string
    ownerName?: StringFieldUpdateOperationsInput | string
    ownerPhone?: StringFieldUpdateOperationsInput | string
    ownerEmail?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: AddressUpdateOneWithoutStoreNestedInput
    bankDetails?: BankDetailsUpdateOneWithoutStoreNestedInput
  }

  export type StoreUncheckedUpdateWithoutUserInput = {
    storeId?: StringFieldUpdateOperationsInput | string
    storeName?: StringFieldUpdateOperationsInput | string
    ownerName?: StringFieldUpdateOperationsInput | string
    ownerPhone?: StringFieldUpdateOperationsInput | string
    ownerEmail?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: AddressUncheckedUpdateOneWithoutStoreNestedInput
    bankDetails?: BankDetailsUncheckedUpdateOneWithoutStoreNestedInput
  }

  export type AdminUpsertWithoutUserInput = {
    update: XOR<AdminUpdateWithoutUserInput, AdminUncheckedUpdateWithoutUserInput>
    create: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutUserInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutUserInput, AdminUncheckedUpdateWithoutUserInput>
  }

  export type AdminUpdateWithoutUserInput = {
    employeeId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdminUncheckedUpdateWithoutUserInput = {
    employeeId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCreateWithoutAdminInput = {
    id?: string
    phone: string
    phoneVerified?: boolean | null
    salary?: Decimal | DecimalJsLike | number | string | null
    payoutDate?: number | null
    password: string
    email?: string | null
    dateOfJoining?: Date | string | null
    dateOfTermination?: Date | string | null
    profileImage?: string | null
    aadharFrontImage?: string | null
    aadharBackImage?: string | null
    qualificationImage?: string | null
    VehicleFrontImage?: string | null
    VehicleBackImage?: string | null
    role?: $Enums.Role | null
    storeId?: string | null
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaVerified?: boolean
    createdBy?: string | null
    isAdmin?: boolean
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    manager?: ManagerCreateNestedOneWithoutUserInput
    technician?: TechnicianCreateNestedOneWithoutUserInput
    fieldExecutive?: FieldExecutiveCreateNestedOneWithoutUserInput
    salesExecutive?: SalesExecutiveCreateNestedOneWithoutUserInput
    store?: StoreCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAdminInput = {
    id?: string
    phone: string
    phoneVerified?: boolean | null
    salary?: Decimal | DecimalJsLike | number | string | null
    payoutDate?: number | null
    password: string
    email?: string | null
    dateOfJoining?: Date | string | null
    dateOfTermination?: Date | string | null
    profileImage?: string | null
    aadharFrontImage?: string | null
    aadharBackImage?: string | null
    qualificationImage?: string | null
    VehicleFrontImage?: string | null
    VehicleBackImage?: string | null
    role?: $Enums.Role | null
    storeId?: string | null
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaVerified?: boolean
    createdBy?: string | null
    isAdmin?: boolean
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    manager?: ManagerUncheckedCreateNestedOneWithoutUserInput
    technician?: TechnicianUncheckedCreateNestedOneWithoutUserInput
    fieldExecutive?: FieldExecutiveUncheckedCreateNestedOneWithoutUserInput
    salesExecutive?: SalesExecutiveUncheckedCreateNestedOneWithoutUserInput
    store?: StoreUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAdminInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
  }

  export type UserUpsertWithoutAdminInput = {
    update: XOR<UserUpdateWithoutAdminInput, UserUncheckedUpdateWithoutAdminInput>
    create: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAdminInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAdminInput, UserUncheckedUpdateWithoutAdminInput>
  }

  export type UserUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    phoneVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payoutDate?: NullableIntFieldUpdateOperationsInput | number | null
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateOfTermination?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    aadharFrontImage?: NullableStringFieldUpdateOperationsInput | string | null
    aadharBackImage?: NullableStringFieldUpdateOperationsInput | string | null
    qualificationImage?: NullableStringFieldUpdateOperationsInput | string | null
    VehicleFrontImage?: NullableStringFieldUpdateOperationsInput | string | null
    VehicleBackImage?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaVerified?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    manager?: ManagerUpdateOneWithoutUserNestedInput
    technician?: TechnicianUpdateOneWithoutUserNestedInput
    fieldExecutive?: FieldExecutiveUpdateOneWithoutUserNestedInput
    salesExecutive?: SalesExecutiveUpdateOneWithoutUserNestedInput
    store?: StoreUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    phoneVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payoutDate?: NullableIntFieldUpdateOperationsInput | number | null
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateOfTermination?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    aadharFrontImage?: NullableStringFieldUpdateOperationsInput | string | null
    aadharBackImage?: NullableStringFieldUpdateOperationsInput | string | null
    qualificationImage?: NullableStringFieldUpdateOperationsInput | string | null
    VehicleFrontImage?: NullableStringFieldUpdateOperationsInput | string | null
    VehicleBackImage?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaVerified?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    manager?: ManagerUncheckedUpdateOneWithoutUserNestedInput
    technician?: TechnicianUncheckedUpdateOneWithoutUserNestedInput
    fieldExecutive?: FieldExecutiveUncheckedUpdateOneWithoutUserNestedInput
    salesExecutive?: SalesExecutiveUncheckedUpdateOneWithoutUserNestedInput
    store?: StoreUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutManagerInput = {
    id?: string
    phone: string
    phoneVerified?: boolean | null
    salary?: Decimal | DecimalJsLike | number | string | null
    payoutDate?: number | null
    password: string
    email?: string | null
    dateOfJoining?: Date | string | null
    dateOfTermination?: Date | string | null
    profileImage?: string | null
    aadharFrontImage?: string | null
    aadharBackImage?: string | null
    qualificationImage?: string | null
    VehicleFrontImage?: string | null
    VehicleBackImage?: string | null
    role?: $Enums.Role | null
    storeId?: string | null
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaVerified?: boolean
    createdBy?: string | null
    isAdmin?: boolean
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    technician?: TechnicianCreateNestedOneWithoutUserInput
    fieldExecutive?: FieldExecutiveCreateNestedOneWithoutUserInput
    salesExecutive?: SalesExecutiveCreateNestedOneWithoutUserInput
    store?: StoreCreateNestedOneWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutManagerInput = {
    id?: string
    phone: string
    phoneVerified?: boolean | null
    salary?: Decimal | DecimalJsLike | number | string | null
    payoutDate?: number | null
    password: string
    email?: string | null
    dateOfJoining?: Date | string | null
    dateOfTermination?: Date | string | null
    profileImage?: string | null
    aadharFrontImage?: string | null
    aadharBackImage?: string | null
    qualificationImage?: string | null
    VehicleFrontImage?: string | null
    VehicleBackImage?: string | null
    role?: $Enums.Role | null
    storeId?: string | null
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaVerified?: boolean
    createdBy?: string | null
    isAdmin?: boolean
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    technician?: TechnicianUncheckedCreateNestedOneWithoutUserInput
    fieldExecutive?: FieldExecutiveUncheckedCreateNestedOneWithoutUserInput
    salesExecutive?: SalesExecutiveUncheckedCreateNestedOneWithoutUserInput
    store?: StoreUncheckedCreateNestedOneWithoutUserInput
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutManagerInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutManagerInput, UserUncheckedCreateWithoutManagerInput>
  }

  export type BankDetailsCreateWithoutManagerInput = {
    id?: string
    accountNumber?: string | null
    ifsc?: string | null
    bankName?: string | null
    beneficiaryName?: string | null
    upiId?: string | null
    technician?: TechnicianCreateNestedOneWithoutBankDetailsInput
    fieldExecutive?: FieldExecutiveCreateNestedOneWithoutBankDetailsInput
    salesExecutive?: SalesExecutiveCreateNestedOneWithoutBankDetailsInput
    store?: StoreCreateNestedOneWithoutBankDetailsInput
  }

  export type BankDetailsUncheckedCreateWithoutManagerInput = {
    id?: string
    accountNumber?: string | null
    ifsc?: string | null
    bankName?: string | null
    beneficiaryName?: string | null
    upiId?: string | null
    technicianId?: string | null
    fieldExecId?: string | null
    salesExecId?: string | null
    storeId?: string | null
  }

  export type BankDetailsCreateOrConnectWithoutManagerInput = {
    where: BankDetailsWhereUniqueInput
    create: XOR<BankDetailsCreateWithoutManagerInput, BankDetailsUncheckedCreateWithoutManagerInput>
  }

  export type UserUpsertWithoutManagerInput = {
    update: XOR<UserUpdateWithoutManagerInput, UserUncheckedUpdateWithoutManagerInput>
    create: XOR<UserCreateWithoutManagerInput, UserUncheckedCreateWithoutManagerInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutManagerInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutManagerInput, UserUncheckedUpdateWithoutManagerInput>
  }

  export type UserUpdateWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    phoneVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payoutDate?: NullableIntFieldUpdateOperationsInput | number | null
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateOfTermination?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    aadharFrontImage?: NullableStringFieldUpdateOperationsInput | string | null
    aadharBackImage?: NullableStringFieldUpdateOperationsInput | string | null
    qualificationImage?: NullableStringFieldUpdateOperationsInput | string | null
    VehicleFrontImage?: NullableStringFieldUpdateOperationsInput | string | null
    VehicleBackImage?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaVerified?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    technician?: TechnicianUpdateOneWithoutUserNestedInput
    fieldExecutive?: FieldExecutiveUpdateOneWithoutUserNestedInput
    salesExecutive?: SalesExecutiveUpdateOneWithoutUserNestedInput
    store?: StoreUpdateOneWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    phoneVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payoutDate?: NullableIntFieldUpdateOperationsInput | number | null
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateOfTermination?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    aadharFrontImage?: NullableStringFieldUpdateOperationsInput | string | null
    aadharBackImage?: NullableStringFieldUpdateOperationsInput | string | null
    qualificationImage?: NullableStringFieldUpdateOperationsInput | string | null
    VehicleFrontImage?: NullableStringFieldUpdateOperationsInput | string | null
    VehicleBackImage?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaVerified?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    technician?: TechnicianUncheckedUpdateOneWithoutUserNestedInput
    fieldExecutive?: FieldExecutiveUncheckedUpdateOneWithoutUserNestedInput
    salesExecutive?: SalesExecutiveUncheckedUpdateOneWithoutUserNestedInput
    store?: StoreUncheckedUpdateOneWithoutUserNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
  }

  export type BankDetailsUpsertWithoutManagerInput = {
    update: XOR<BankDetailsUpdateWithoutManagerInput, BankDetailsUncheckedUpdateWithoutManagerInput>
    create: XOR<BankDetailsCreateWithoutManagerInput, BankDetailsUncheckedCreateWithoutManagerInput>
    where?: BankDetailsWhereInput
  }

  export type BankDetailsUpdateToOneWithWhereWithoutManagerInput = {
    where?: BankDetailsWhereInput
    data: XOR<BankDetailsUpdateWithoutManagerInput, BankDetailsUncheckedUpdateWithoutManagerInput>
  }

  export type BankDetailsUpdateWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ifsc?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    beneficiaryName?: NullableStringFieldUpdateOperationsInput | string | null
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    technician?: TechnicianUpdateOneWithoutBankDetailsNestedInput
    fieldExecutive?: FieldExecutiveUpdateOneWithoutBankDetailsNestedInput
    salesExecutive?: SalesExecutiveUpdateOneWithoutBankDetailsNestedInput
    store?: StoreUpdateOneWithoutBankDetailsNestedInput
  }

  export type BankDetailsUncheckedUpdateWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ifsc?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    beneficiaryName?: NullableStringFieldUpdateOperationsInput | string | null
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    technicianId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldExecId?: NullableStringFieldUpdateOperationsInput | string | null
    salesExecId?: NullableStringFieldUpdateOperationsInput | string | null
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCreateWithoutTechnicianInput = {
    id?: string
    phone: string
    phoneVerified?: boolean | null
    salary?: Decimal | DecimalJsLike | number | string | null
    payoutDate?: number | null
    password: string
    email?: string | null
    dateOfJoining?: Date | string | null
    dateOfTermination?: Date | string | null
    profileImage?: string | null
    aadharFrontImage?: string | null
    aadharBackImage?: string | null
    qualificationImage?: string | null
    VehicleFrontImage?: string | null
    VehicleBackImage?: string | null
    role?: $Enums.Role | null
    storeId?: string | null
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaVerified?: boolean
    createdBy?: string | null
    isAdmin?: boolean
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    manager?: ManagerCreateNestedOneWithoutUserInput
    fieldExecutive?: FieldExecutiveCreateNestedOneWithoutUserInput
    salesExecutive?: SalesExecutiveCreateNestedOneWithoutUserInput
    store?: StoreCreateNestedOneWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTechnicianInput = {
    id?: string
    phone: string
    phoneVerified?: boolean | null
    salary?: Decimal | DecimalJsLike | number | string | null
    payoutDate?: number | null
    password: string
    email?: string | null
    dateOfJoining?: Date | string | null
    dateOfTermination?: Date | string | null
    profileImage?: string | null
    aadharFrontImage?: string | null
    aadharBackImage?: string | null
    qualificationImage?: string | null
    VehicleFrontImage?: string | null
    VehicleBackImage?: string | null
    role?: $Enums.Role | null
    storeId?: string | null
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaVerified?: boolean
    createdBy?: string | null
    isAdmin?: boolean
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    manager?: ManagerUncheckedCreateNestedOneWithoutUserInput
    fieldExecutive?: FieldExecutiveUncheckedCreateNestedOneWithoutUserInput
    salesExecutive?: SalesExecutiveUncheckedCreateNestedOneWithoutUserInput
    store?: StoreUncheckedCreateNestedOneWithoutUserInput
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTechnicianInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTechnicianInput, UserUncheckedCreateWithoutTechnicianInput>
  }

  export type BankDetailsCreateWithoutTechnicianInput = {
    id?: string
    accountNumber?: string | null
    ifsc?: string | null
    bankName?: string | null
    beneficiaryName?: string | null
    upiId?: string | null
    manager?: ManagerCreateNestedOneWithoutBankDetailsInput
    fieldExecutive?: FieldExecutiveCreateNestedOneWithoutBankDetailsInput
    salesExecutive?: SalesExecutiveCreateNestedOneWithoutBankDetailsInput
    store?: StoreCreateNestedOneWithoutBankDetailsInput
  }

  export type BankDetailsUncheckedCreateWithoutTechnicianInput = {
    id?: string
    accountNumber?: string | null
    ifsc?: string | null
    bankName?: string | null
    beneficiaryName?: string | null
    upiId?: string | null
    managerId?: string | null
    fieldExecId?: string | null
    salesExecId?: string | null
    storeId?: string | null
  }

  export type BankDetailsCreateOrConnectWithoutTechnicianInput = {
    where: BankDetailsWhereUniqueInput
    create: XOR<BankDetailsCreateWithoutTechnicianInput, BankDetailsUncheckedCreateWithoutTechnicianInput>
  }

  export type UserUpsertWithoutTechnicianInput = {
    update: XOR<UserUpdateWithoutTechnicianInput, UserUncheckedUpdateWithoutTechnicianInput>
    create: XOR<UserCreateWithoutTechnicianInput, UserUncheckedCreateWithoutTechnicianInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTechnicianInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTechnicianInput, UserUncheckedUpdateWithoutTechnicianInput>
  }

  export type UserUpdateWithoutTechnicianInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    phoneVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payoutDate?: NullableIntFieldUpdateOperationsInput | number | null
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateOfTermination?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    aadharFrontImage?: NullableStringFieldUpdateOperationsInput | string | null
    aadharBackImage?: NullableStringFieldUpdateOperationsInput | string | null
    qualificationImage?: NullableStringFieldUpdateOperationsInput | string | null
    VehicleFrontImage?: NullableStringFieldUpdateOperationsInput | string | null
    VehicleBackImage?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaVerified?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    manager?: ManagerUpdateOneWithoutUserNestedInput
    fieldExecutive?: FieldExecutiveUpdateOneWithoutUserNestedInput
    salesExecutive?: SalesExecutiveUpdateOneWithoutUserNestedInput
    store?: StoreUpdateOneWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTechnicianInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    phoneVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payoutDate?: NullableIntFieldUpdateOperationsInput | number | null
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateOfTermination?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    aadharFrontImage?: NullableStringFieldUpdateOperationsInput | string | null
    aadharBackImage?: NullableStringFieldUpdateOperationsInput | string | null
    qualificationImage?: NullableStringFieldUpdateOperationsInput | string | null
    VehicleFrontImage?: NullableStringFieldUpdateOperationsInput | string | null
    VehicleBackImage?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaVerified?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    manager?: ManagerUncheckedUpdateOneWithoutUserNestedInput
    fieldExecutive?: FieldExecutiveUncheckedUpdateOneWithoutUserNestedInput
    salesExecutive?: SalesExecutiveUncheckedUpdateOneWithoutUserNestedInput
    store?: StoreUncheckedUpdateOneWithoutUserNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
  }

  export type BankDetailsUpsertWithoutTechnicianInput = {
    update: XOR<BankDetailsUpdateWithoutTechnicianInput, BankDetailsUncheckedUpdateWithoutTechnicianInput>
    create: XOR<BankDetailsCreateWithoutTechnicianInput, BankDetailsUncheckedCreateWithoutTechnicianInput>
    where?: BankDetailsWhereInput
  }

  export type BankDetailsUpdateToOneWithWhereWithoutTechnicianInput = {
    where?: BankDetailsWhereInput
    data: XOR<BankDetailsUpdateWithoutTechnicianInput, BankDetailsUncheckedUpdateWithoutTechnicianInput>
  }

  export type BankDetailsUpdateWithoutTechnicianInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ifsc?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    beneficiaryName?: NullableStringFieldUpdateOperationsInput | string | null
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    manager?: ManagerUpdateOneWithoutBankDetailsNestedInput
    fieldExecutive?: FieldExecutiveUpdateOneWithoutBankDetailsNestedInput
    salesExecutive?: SalesExecutiveUpdateOneWithoutBankDetailsNestedInput
    store?: StoreUpdateOneWithoutBankDetailsNestedInput
  }

  export type BankDetailsUncheckedUpdateWithoutTechnicianInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ifsc?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    beneficiaryName?: NullableStringFieldUpdateOperationsInput | string | null
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldExecId?: NullableStringFieldUpdateOperationsInput | string | null
    salesExecId?: NullableStringFieldUpdateOperationsInput | string | null
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCreateWithoutFieldExecutiveInput = {
    id?: string
    phone: string
    phoneVerified?: boolean | null
    salary?: Decimal | DecimalJsLike | number | string | null
    payoutDate?: number | null
    password: string
    email?: string | null
    dateOfJoining?: Date | string | null
    dateOfTermination?: Date | string | null
    profileImage?: string | null
    aadharFrontImage?: string | null
    aadharBackImage?: string | null
    qualificationImage?: string | null
    VehicleFrontImage?: string | null
    VehicleBackImage?: string | null
    role?: $Enums.Role | null
    storeId?: string | null
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaVerified?: boolean
    createdBy?: string | null
    isAdmin?: boolean
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    manager?: ManagerCreateNestedOneWithoutUserInput
    technician?: TechnicianCreateNestedOneWithoutUserInput
    salesExecutive?: SalesExecutiveCreateNestedOneWithoutUserInput
    store?: StoreCreateNestedOneWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFieldExecutiveInput = {
    id?: string
    phone: string
    phoneVerified?: boolean | null
    salary?: Decimal | DecimalJsLike | number | string | null
    payoutDate?: number | null
    password: string
    email?: string | null
    dateOfJoining?: Date | string | null
    dateOfTermination?: Date | string | null
    profileImage?: string | null
    aadharFrontImage?: string | null
    aadharBackImage?: string | null
    qualificationImage?: string | null
    VehicleFrontImage?: string | null
    VehicleBackImage?: string | null
    role?: $Enums.Role | null
    storeId?: string | null
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaVerified?: boolean
    createdBy?: string | null
    isAdmin?: boolean
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    manager?: ManagerUncheckedCreateNestedOneWithoutUserInput
    technician?: TechnicianUncheckedCreateNestedOneWithoutUserInput
    salesExecutive?: SalesExecutiveUncheckedCreateNestedOneWithoutUserInput
    store?: StoreUncheckedCreateNestedOneWithoutUserInput
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFieldExecutiveInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFieldExecutiveInput, UserUncheckedCreateWithoutFieldExecutiveInput>
  }

  export type BankDetailsCreateWithoutFieldExecutiveInput = {
    id?: string
    accountNumber?: string | null
    ifsc?: string | null
    bankName?: string | null
    beneficiaryName?: string | null
    upiId?: string | null
    manager?: ManagerCreateNestedOneWithoutBankDetailsInput
    technician?: TechnicianCreateNestedOneWithoutBankDetailsInput
    salesExecutive?: SalesExecutiveCreateNestedOneWithoutBankDetailsInput
    store?: StoreCreateNestedOneWithoutBankDetailsInput
  }

  export type BankDetailsUncheckedCreateWithoutFieldExecutiveInput = {
    id?: string
    accountNumber?: string | null
    ifsc?: string | null
    bankName?: string | null
    beneficiaryName?: string | null
    upiId?: string | null
    managerId?: string | null
    technicianId?: string | null
    salesExecId?: string | null
    storeId?: string | null
  }

  export type BankDetailsCreateOrConnectWithoutFieldExecutiveInput = {
    where: BankDetailsWhereUniqueInput
    create: XOR<BankDetailsCreateWithoutFieldExecutiveInput, BankDetailsUncheckedCreateWithoutFieldExecutiveInput>
  }

  export type UserUpsertWithoutFieldExecutiveInput = {
    update: XOR<UserUpdateWithoutFieldExecutiveInput, UserUncheckedUpdateWithoutFieldExecutiveInput>
    create: XOR<UserCreateWithoutFieldExecutiveInput, UserUncheckedCreateWithoutFieldExecutiveInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFieldExecutiveInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFieldExecutiveInput, UserUncheckedUpdateWithoutFieldExecutiveInput>
  }

  export type UserUpdateWithoutFieldExecutiveInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    phoneVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payoutDate?: NullableIntFieldUpdateOperationsInput | number | null
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateOfTermination?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    aadharFrontImage?: NullableStringFieldUpdateOperationsInput | string | null
    aadharBackImage?: NullableStringFieldUpdateOperationsInput | string | null
    qualificationImage?: NullableStringFieldUpdateOperationsInput | string | null
    VehicleFrontImage?: NullableStringFieldUpdateOperationsInput | string | null
    VehicleBackImage?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaVerified?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    manager?: ManagerUpdateOneWithoutUserNestedInput
    technician?: TechnicianUpdateOneWithoutUserNestedInput
    salesExecutive?: SalesExecutiveUpdateOneWithoutUserNestedInput
    store?: StoreUpdateOneWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFieldExecutiveInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    phoneVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payoutDate?: NullableIntFieldUpdateOperationsInput | number | null
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateOfTermination?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    aadharFrontImage?: NullableStringFieldUpdateOperationsInput | string | null
    aadharBackImage?: NullableStringFieldUpdateOperationsInput | string | null
    qualificationImage?: NullableStringFieldUpdateOperationsInput | string | null
    VehicleFrontImage?: NullableStringFieldUpdateOperationsInput | string | null
    VehicleBackImage?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaVerified?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    manager?: ManagerUncheckedUpdateOneWithoutUserNestedInput
    technician?: TechnicianUncheckedUpdateOneWithoutUserNestedInput
    salesExecutive?: SalesExecutiveUncheckedUpdateOneWithoutUserNestedInput
    store?: StoreUncheckedUpdateOneWithoutUserNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
  }

  export type BankDetailsUpsertWithoutFieldExecutiveInput = {
    update: XOR<BankDetailsUpdateWithoutFieldExecutiveInput, BankDetailsUncheckedUpdateWithoutFieldExecutiveInput>
    create: XOR<BankDetailsCreateWithoutFieldExecutiveInput, BankDetailsUncheckedCreateWithoutFieldExecutiveInput>
    where?: BankDetailsWhereInput
  }

  export type BankDetailsUpdateToOneWithWhereWithoutFieldExecutiveInput = {
    where?: BankDetailsWhereInput
    data: XOR<BankDetailsUpdateWithoutFieldExecutiveInput, BankDetailsUncheckedUpdateWithoutFieldExecutiveInput>
  }

  export type BankDetailsUpdateWithoutFieldExecutiveInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ifsc?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    beneficiaryName?: NullableStringFieldUpdateOperationsInput | string | null
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    manager?: ManagerUpdateOneWithoutBankDetailsNestedInput
    technician?: TechnicianUpdateOneWithoutBankDetailsNestedInput
    salesExecutive?: SalesExecutiveUpdateOneWithoutBankDetailsNestedInput
    store?: StoreUpdateOneWithoutBankDetailsNestedInput
  }

  export type BankDetailsUncheckedUpdateWithoutFieldExecutiveInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ifsc?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    beneficiaryName?: NullableStringFieldUpdateOperationsInput | string | null
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    technicianId?: NullableStringFieldUpdateOperationsInput | string | null
    salesExecId?: NullableStringFieldUpdateOperationsInput | string | null
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCreateWithoutSalesExecutiveInput = {
    id?: string
    phone: string
    phoneVerified?: boolean | null
    salary?: Decimal | DecimalJsLike | number | string | null
    payoutDate?: number | null
    password: string
    email?: string | null
    dateOfJoining?: Date | string | null
    dateOfTermination?: Date | string | null
    profileImage?: string | null
    aadharFrontImage?: string | null
    aadharBackImage?: string | null
    qualificationImage?: string | null
    VehicleFrontImage?: string | null
    VehicleBackImage?: string | null
    role?: $Enums.Role | null
    storeId?: string | null
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaVerified?: boolean
    createdBy?: string | null
    isAdmin?: boolean
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    manager?: ManagerCreateNestedOneWithoutUserInput
    technician?: TechnicianCreateNestedOneWithoutUserInput
    fieldExecutive?: FieldExecutiveCreateNestedOneWithoutUserInput
    store?: StoreCreateNestedOneWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSalesExecutiveInput = {
    id?: string
    phone: string
    phoneVerified?: boolean | null
    salary?: Decimal | DecimalJsLike | number | string | null
    payoutDate?: number | null
    password: string
    email?: string | null
    dateOfJoining?: Date | string | null
    dateOfTermination?: Date | string | null
    profileImage?: string | null
    aadharFrontImage?: string | null
    aadharBackImage?: string | null
    qualificationImage?: string | null
    VehicleFrontImage?: string | null
    VehicleBackImage?: string | null
    role?: $Enums.Role | null
    storeId?: string | null
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaVerified?: boolean
    createdBy?: string | null
    isAdmin?: boolean
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    manager?: ManagerUncheckedCreateNestedOneWithoutUserInput
    technician?: TechnicianUncheckedCreateNestedOneWithoutUserInput
    fieldExecutive?: FieldExecutiveUncheckedCreateNestedOneWithoutUserInput
    store?: StoreUncheckedCreateNestedOneWithoutUserInput
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSalesExecutiveInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSalesExecutiveInput, UserUncheckedCreateWithoutSalesExecutiveInput>
  }

  export type BankDetailsCreateWithoutSalesExecutiveInput = {
    id?: string
    accountNumber?: string | null
    ifsc?: string | null
    bankName?: string | null
    beneficiaryName?: string | null
    upiId?: string | null
    manager?: ManagerCreateNestedOneWithoutBankDetailsInput
    technician?: TechnicianCreateNestedOneWithoutBankDetailsInput
    fieldExecutive?: FieldExecutiveCreateNestedOneWithoutBankDetailsInput
    store?: StoreCreateNestedOneWithoutBankDetailsInput
  }

  export type BankDetailsUncheckedCreateWithoutSalesExecutiveInput = {
    id?: string
    accountNumber?: string | null
    ifsc?: string | null
    bankName?: string | null
    beneficiaryName?: string | null
    upiId?: string | null
    managerId?: string | null
    technicianId?: string | null
    fieldExecId?: string | null
    storeId?: string | null
  }

  export type BankDetailsCreateOrConnectWithoutSalesExecutiveInput = {
    where: BankDetailsWhereUniqueInput
    create: XOR<BankDetailsCreateWithoutSalesExecutiveInput, BankDetailsUncheckedCreateWithoutSalesExecutiveInput>
  }

  export type UserUpsertWithoutSalesExecutiveInput = {
    update: XOR<UserUpdateWithoutSalesExecutiveInput, UserUncheckedUpdateWithoutSalesExecutiveInput>
    create: XOR<UserCreateWithoutSalesExecutiveInput, UserUncheckedCreateWithoutSalesExecutiveInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSalesExecutiveInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSalesExecutiveInput, UserUncheckedUpdateWithoutSalesExecutiveInput>
  }

  export type UserUpdateWithoutSalesExecutiveInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    phoneVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payoutDate?: NullableIntFieldUpdateOperationsInput | number | null
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateOfTermination?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    aadharFrontImage?: NullableStringFieldUpdateOperationsInput | string | null
    aadharBackImage?: NullableStringFieldUpdateOperationsInput | string | null
    qualificationImage?: NullableStringFieldUpdateOperationsInput | string | null
    VehicleFrontImage?: NullableStringFieldUpdateOperationsInput | string | null
    VehicleBackImage?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaVerified?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    manager?: ManagerUpdateOneWithoutUserNestedInput
    technician?: TechnicianUpdateOneWithoutUserNestedInput
    fieldExecutive?: FieldExecutiveUpdateOneWithoutUserNestedInput
    store?: StoreUpdateOneWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSalesExecutiveInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    phoneVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payoutDate?: NullableIntFieldUpdateOperationsInput | number | null
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateOfTermination?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    aadharFrontImage?: NullableStringFieldUpdateOperationsInput | string | null
    aadharBackImage?: NullableStringFieldUpdateOperationsInput | string | null
    qualificationImage?: NullableStringFieldUpdateOperationsInput | string | null
    VehicleFrontImage?: NullableStringFieldUpdateOperationsInput | string | null
    VehicleBackImage?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaVerified?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    manager?: ManagerUncheckedUpdateOneWithoutUserNestedInput
    technician?: TechnicianUncheckedUpdateOneWithoutUserNestedInput
    fieldExecutive?: FieldExecutiveUncheckedUpdateOneWithoutUserNestedInput
    store?: StoreUncheckedUpdateOneWithoutUserNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
  }

  export type BankDetailsUpsertWithoutSalesExecutiveInput = {
    update: XOR<BankDetailsUpdateWithoutSalesExecutiveInput, BankDetailsUncheckedUpdateWithoutSalesExecutiveInput>
    create: XOR<BankDetailsCreateWithoutSalesExecutiveInput, BankDetailsUncheckedCreateWithoutSalesExecutiveInput>
    where?: BankDetailsWhereInput
  }

  export type BankDetailsUpdateToOneWithWhereWithoutSalesExecutiveInput = {
    where?: BankDetailsWhereInput
    data: XOR<BankDetailsUpdateWithoutSalesExecutiveInput, BankDetailsUncheckedUpdateWithoutSalesExecutiveInput>
  }

  export type BankDetailsUpdateWithoutSalesExecutiveInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ifsc?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    beneficiaryName?: NullableStringFieldUpdateOperationsInput | string | null
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    manager?: ManagerUpdateOneWithoutBankDetailsNestedInput
    technician?: TechnicianUpdateOneWithoutBankDetailsNestedInput
    fieldExecutive?: FieldExecutiveUpdateOneWithoutBankDetailsNestedInput
    store?: StoreUpdateOneWithoutBankDetailsNestedInput
  }

  export type BankDetailsUncheckedUpdateWithoutSalesExecutiveInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ifsc?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    beneficiaryName?: NullableStringFieldUpdateOperationsInput | string | null
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    technicianId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldExecId?: NullableStringFieldUpdateOperationsInput | string | null
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCreateWithoutStoreInput = {
    id?: string
    phone: string
    phoneVerified?: boolean | null
    salary?: Decimal | DecimalJsLike | number | string | null
    payoutDate?: number | null
    password: string
    email?: string | null
    dateOfJoining?: Date | string | null
    dateOfTermination?: Date | string | null
    profileImage?: string | null
    aadharFrontImage?: string | null
    aadharBackImage?: string | null
    qualificationImage?: string | null
    VehicleFrontImage?: string | null
    VehicleBackImage?: string | null
    role?: $Enums.Role | null
    storeId?: string | null
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaVerified?: boolean
    createdBy?: string | null
    isAdmin?: boolean
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    manager?: ManagerCreateNestedOneWithoutUserInput
    technician?: TechnicianCreateNestedOneWithoutUserInput
    fieldExecutive?: FieldExecutiveCreateNestedOneWithoutUserInput
    salesExecutive?: SalesExecutiveCreateNestedOneWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutStoreInput = {
    id?: string
    phone: string
    phoneVerified?: boolean | null
    salary?: Decimal | DecimalJsLike | number | string | null
    payoutDate?: number | null
    password: string
    email?: string | null
    dateOfJoining?: Date | string | null
    dateOfTermination?: Date | string | null
    profileImage?: string | null
    aadharFrontImage?: string | null
    aadharBackImage?: string | null
    qualificationImage?: string | null
    VehicleFrontImage?: string | null
    VehicleBackImage?: string | null
    role?: $Enums.Role | null
    storeId?: string | null
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaVerified?: boolean
    createdBy?: string | null
    isAdmin?: boolean
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    manager?: ManagerUncheckedCreateNestedOneWithoutUserInput
    technician?: TechnicianUncheckedCreateNestedOneWithoutUserInput
    fieldExecutive?: FieldExecutiveUncheckedCreateNestedOneWithoutUserInput
    salesExecutive?: SalesExecutiveUncheckedCreateNestedOneWithoutUserInput
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutStoreInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStoreInput, UserUncheckedCreateWithoutStoreInput>
  }

  export type AddressCreateWithoutStoreInput = {
    id?: string
    streetAddress: string
    city: string
    state: string
    country: string
    pinCode: string
  }

  export type AddressUncheckedCreateWithoutStoreInput = {
    id?: string
    streetAddress: string
    city: string
    state: string
    country: string
    pinCode: string
  }

  export type AddressCreateOrConnectWithoutStoreInput = {
    where: AddressWhereUniqueInput
    create: XOR<AddressCreateWithoutStoreInput, AddressUncheckedCreateWithoutStoreInput>
  }

  export type BankDetailsCreateWithoutStoreInput = {
    id?: string
    accountNumber?: string | null
    ifsc?: string | null
    bankName?: string | null
    beneficiaryName?: string | null
    upiId?: string | null
    manager?: ManagerCreateNestedOneWithoutBankDetailsInput
    technician?: TechnicianCreateNestedOneWithoutBankDetailsInput
    fieldExecutive?: FieldExecutiveCreateNestedOneWithoutBankDetailsInput
    salesExecutive?: SalesExecutiveCreateNestedOneWithoutBankDetailsInput
  }

  export type BankDetailsUncheckedCreateWithoutStoreInput = {
    id?: string
    accountNumber?: string | null
    ifsc?: string | null
    bankName?: string | null
    beneficiaryName?: string | null
    upiId?: string | null
    managerId?: string | null
    technicianId?: string | null
    fieldExecId?: string | null
    salesExecId?: string | null
  }

  export type BankDetailsCreateOrConnectWithoutStoreInput = {
    where: BankDetailsWhereUniqueInput
    create: XOR<BankDetailsCreateWithoutStoreInput, BankDetailsUncheckedCreateWithoutStoreInput>
  }

  export type UserUpsertWithoutStoreInput = {
    update: XOR<UserUpdateWithoutStoreInput, UserUncheckedUpdateWithoutStoreInput>
    create: XOR<UserCreateWithoutStoreInput, UserUncheckedCreateWithoutStoreInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStoreInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStoreInput, UserUncheckedUpdateWithoutStoreInput>
  }

  export type UserUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    phoneVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payoutDate?: NullableIntFieldUpdateOperationsInput | number | null
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateOfTermination?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    aadharFrontImage?: NullableStringFieldUpdateOperationsInput | string | null
    aadharBackImage?: NullableStringFieldUpdateOperationsInput | string | null
    qualificationImage?: NullableStringFieldUpdateOperationsInput | string | null
    VehicleFrontImage?: NullableStringFieldUpdateOperationsInput | string | null
    VehicleBackImage?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaVerified?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    manager?: ManagerUpdateOneWithoutUserNestedInput
    technician?: TechnicianUpdateOneWithoutUserNestedInput
    fieldExecutive?: FieldExecutiveUpdateOneWithoutUserNestedInput
    salesExecutive?: SalesExecutiveUpdateOneWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    phoneVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payoutDate?: NullableIntFieldUpdateOperationsInput | number | null
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateOfTermination?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    aadharFrontImage?: NullableStringFieldUpdateOperationsInput | string | null
    aadharBackImage?: NullableStringFieldUpdateOperationsInput | string | null
    qualificationImage?: NullableStringFieldUpdateOperationsInput | string | null
    VehicleFrontImage?: NullableStringFieldUpdateOperationsInput | string | null
    VehicleBackImage?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaVerified?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    manager?: ManagerUncheckedUpdateOneWithoutUserNestedInput
    technician?: TechnicianUncheckedUpdateOneWithoutUserNestedInput
    fieldExecutive?: FieldExecutiveUncheckedUpdateOneWithoutUserNestedInput
    salesExecutive?: SalesExecutiveUncheckedUpdateOneWithoutUserNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
  }

  export type AddressUpsertWithoutStoreInput = {
    update: XOR<AddressUpdateWithoutStoreInput, AddressUncheckedUpdateWithoutStoreInput>
    create: XOR<AddressCreateWithoutStoreInput, AddressUncheckedCreateWithoutStoreInput>
    where?: AddressWhereInput
  }

  export type AddressUpdateToOneWithWhereWithoutStoreInput = {
    where?: AddressWhereInput
    data: XOR<AddressUpdateWithoutStoreInput, AddressUncheckedUpdateWithoutStoreInput>
  }

  export type AddressUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    streetAddress?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    pinCode?: StringFieldUpdateOperationsInput | string
  }

  export type AddressUncheckedUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    streetAddress?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    pinCode?: StringFieldUpdateOperationsInput | string
  }

  export type BankDetailsUpsertWithoutStoreInput = {
    update: XOR<BankDetailsUpdateWithoutStoreInput, BankDetailsUncheckedUpdateWithoutStoreInput>
    create: XOR<BankDetailsCreateWithoutStoreInput, BankDetailsUncheckedCreateWithoutStoreInput>
    where?: BankDetailsWhereInput
  }

  export type BankDetailsUpdateToOneWithWhereWithoutStoreInput = {
    where?: BankDetailsWhereInput
    data: XOR<BankDetailsUpdateWithoutStoreInput, BankDetailsUncheckedUpdateWithoutStoreInput>
  }

  export type BankDetailsUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ifsc?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    beneficiaryName?: NullableStringFieldUpdateOperationsInput | string | null
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    manager?: ManagerUpdateOneWithoutBankDetailsNestedInput
    technician?: TechnicianUpdateOneWithoutBankDetailsNestedInput
    fieldExecutive?: FieldExecutiveUpdateOneWithoutBankDetailsNestedInput
    salesExecutive?: SalesExecutiveUpdateOneWithoutBankDetailsNestedInput
  }

  export type BankDetailsUncheckedUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ifsc?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    beneficiaryName?: NullableStringFieldUpdateOperationsInput | string | null
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    technicianId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldExecId?: NullableStringFieldUpdateOperationsInput | string | null
    salesExecId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ManagerCreateWithoutBankDetailsInput = {
    firstName: string
    lastName: string
    employeeId: string
    aadharId: string
    user: UserCreateNestedOneWithoutManagerInput
  }

  export type ManagerUncheckedCreateWithoutBankDetailsInput = {
    userId: string
    firstName: string
    lastName: string
    employeeId: string
    aadharId: string
  }

  export type ManagerCreateOrConnectWithoutBankDetailsInput = {
    where: ManagerWhereUniqueInput
    create: XOR<ManagerCreateWithoutBankDetailsInput, ManagerUncheckedCreateWithoutBankDetailsInput>
  }

  export type TechnicianCreateWithoutBankDetailsInput = {
    firstName: string
    lastName: string
    employeeId: string
    aadharId: string
    user: UserCreateNestedOneWithoutTechnicianInput
  }

  export type TechnicianUncheckedCreateWithoutBankDetailsInput = {
    userId: string
    firstName: string
    lastName: string
    employeeId: string
    aadharId: string
  }

  export type TechnicianCreateOrConnectWithoutBankDetailsInput = {
    where: TechnicianWhereUniqueInput
    create: XOR<TechnicianCreateWithoutBankDetailsInput, TechnicianUncheckedCreateWithoutBankDetailsInput>
  }

  export type FieldExecutiveCreateWithoutBankDetailsInput = {
    firstName: string
    lastName: string
    employeeId: string
    aadharId: string
    user: UserCreateNestedOneWithoutFieldExecutiveInput
  }

  export type FieldExecutiveUncheckedCreateWithoutBankDetailsInput = {
    userId: string
    firstName: string
    lastName: string
    employeeId: string
    aadharId: string
  }

  export type FieldExecutiveCreateOrConnectWithoutBankDetailsInput = {
    where: FieldExecutiveWhereUniqueInput
    create: XOR<FieldExecutiveCreateWithoutBankDetailsInput, FieldExecutiveUncheckedCreateWithoutBankDetailsInput>
  }

  export type SalesExecutiveCreateWithoutBankDetailsInput = {
    firstName: string
    lastName: string
    employeeId: string
    aadharId: string
    user: UserCreateNestedOneWithoutSalesExecutiveInput
  }

  export type SalesExecutiveUncheckedCreateWithoutBankDetailsInput = {
    userId: string
    firstName: string
    lastName: string
    employeeId: string
    aadharId: string
  }

  export type SalesExecutiveCreateOrConnectWithoutBankDetailsInput = {
    where: SalesExecutiveWhereUniqueInput
    create: XOR<SalesExecutiveCreateWithoutBankDetailsInput, SalesExecutiveUncheckedCreateWithoutBankDetailsInput>
  }

  export type StoreCreateWithoutBankDetailsInput = {
    storeId: string
    storeName: string
    ownerName: string
    ownerPhone: string
    ownerEmail: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStoreInput
    address?: AddressCreateNestedOneWithoutStoreInput
  }

  export type StoreUncheckedCreateWithoutBankDetailsInput = {
    userId: string
    storeId: string
    storeName: string
    ownerName: string
    ownerPhone: string
    ownerEmail: string
    createdAt?: Date | string
    updatedAt?: Date | string
    address?: AddressUncheckedCreateNestedOneWithoutStoreInput
  }

  export type StoreCreateOrConnectWithoutBankDetailsInput = {
    where: StoreWhereUniqueInput
    create: XOR<StoreCreateWithoutBankDetailsInput, StoreUncheckedCreateWithoutBankDetailsInput>
  }

  export type ManagerUpsertWithoutBankDetailsInput = {
    update: XOR<ManagerUpdateWithoutBankDetailsInput, ManagerUncheckedUpdateWithoutBankDetailsInput>
    create: XOR<ManagerCreateWithoutBankDetailsInput, ManagerUncheckedCreateWithoutBankDetailsInput>
    where?: ManagerWhereInput
  }

  export type ManagerUpdateToOneWithWhereWithoutBankDetailsInput = {
    where?: ManagerWhereInput
    data: XOR<ManagerUpdateWithoutBankDetailsInput, ManagerUncheckedUpdateWithoutBankDetailsInput>
  }

  export type ManagerUpdateWithoutBankDetailsInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    aadharId?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutManagerNestedInput
  }

  export type ManagerUncheckedUpdateWithoutBankDetailsInput = {
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    aadharId?: StringFieldUpdateOperationsInput | string
  }

  export type TechnicianUpsertWithoutBankDetailsInput = {
    update: XOR<TechnicianUpdateWithoutBankDetailsInput, TechnicianUncheckedUpdateWithoutBankDetailsInput>
    create: XOR<TechnicianCreateWithoutBankDetailsInput, TechnicianUncheckedCreateWithoutBankDetailsInput>
    where?: TechnicianWhereInput
  }

  export type TechnicianUpdateToOneWithWhereWithoutBankDetailsInput = {
    where?: TechnicianWhereInput
    data: XOR<TechnicianUpdateWithoutBankDetailsInput, TechnicianUncheckedUpdateWithoutBankDetailsInput>
  }

  export type TechnicianUpdateWithoutBankDetailsInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    aadharId?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutTechnicianNestedInput
  }

  export type TechnicianUncheckedUpdateWithoutBankDetailsInput = {
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    aadharId?: StringFieldUpdateOperationsInput | string
  }

  export type FieldExecutiveUpsertWithoutBankDetailsInput = {
    update: XOR<FieldExecutiveUpdateWithoutBankDetailsInput, FieldExecutiveUncheckedUpdateWithoutBankDetailsInput>
    create: XOR<FieldExecutiveCreateWithoutBankDetailsInput, FieldExecutiveUncheckedCreateWithoutBankDetailsInput>
    where?: FieldExecutiveWhereInput
  }

  export type FieldExecutiveUpdateToOneWithWhereWithoutBankDetailsInput = {
    where?: FieldExecutiveWhereInput
    data: XOR<FieldExecutiveUpdateWithoutBankDetailsInput, FieldExecutiveUncheckedUpdateWithoutBankDetailsInput>
  }

  export type FieldExecutiveUpdateWithoutBankDetailsInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    aadharId?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutFieldExecutiveNestedInput
  }

  export type FieldExecutiveUncheckedUpdateWithoutBankDetailsInput = {
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    aadharId?: StringFieldUpdateOperationsInput | string
  }

  export type SalesExecutiveUpsertWithoutBankDetailsInput = {
    update: XOR<SalesExecutiveUpdateWithoutBankDetailsInput, SalesExecutiveUncheckedUpdateWithoutBankDetailsInput>
    create: XOR<SalesExecutiveCreateWithoutBankDetailsInput, SalesExecutiveUncheckedCreateWithoutBankDetailsInput>
    where?: SalesExecutiveWhereInput
  }

  export type SalesExecutiveUpdateToOneWithWhereWithoutBankDetailsInput = {
    where?: SalesExecutiveWhereInput
    data: XOR<SalesExecutiveUpdateWithoutBankDetailsInput, SalesExecutiveUncheckedUpdateWithoutBankDetailsInput>
  }

  export type SalesExecutiveUpdateWithoutBankDetailsInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    aadharId?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutSalesExecutiveNestedInput
  }

  export type SalesExecutiveUncheckedUpdateWithoutBankDetailsInput = {
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    aadharId?: StringFieldUpdateOperationsInput | string
  }

  export type StoreUpsertWithoutBankDetailsInput = {
    update: XOR<StoreUpdateWithoutBankDetailsInput, StoreUncheckedUpdateWithoutBankDetailsInput>
    create: XOR<StoreCreateWithoutBankDetailsInput, StoreUncheckedCreateWithoutBankDetailsInput>
    where?: StoreWhereInput
  }

  export type StoreUpdateToOneWithWhereWithoutBankDetailsInput = {
    where?: StoreWhereInput
    data: XOR<StoreUpdateWithoutBankDetailsInput, StoreUncheckedUpdateWithoutBankDetailsInput>
  }

  export type StoreUpdateWithoutBankDetailsInput = {
    storeId?: StringFieldUpdateOperationsInput | string
    storeName?: StringFieldUpdateOperationsInput | string
    ownerName?: StringFieldUpdateOperationsInput | string
    ownerPhone?: StringFieldUpdateOperationsInput | string
    ownerEmail?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStoreNestedInput
    address?: AddressUpdateOneWithoutStoreNestedInput
  }

  export type StoreUncheckedUpdateWithoutBankDetailsInput = {
    userId?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    storeName?: StringFieldUpdateOperationsInput | string
    ownerName?: StringFieldUpdateOperationsInput | string
    ownerPhone?: StringFieldUpdateOperationsInput | string
    ownerEmail?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: AddressUncheckedUpdateOneWithoutStoreNestedInput
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    phone: string
    phoneVerified?: boolean | null
    salary?: Decimal | DecimalJsLike | number | string | null
    payoutDate?: number | null
    password: string
    email?: string | null
    dateOfJoining?: Date | string | null
    dateOfTermination?: Date | string | null
    profileImage?: string | null
    aadharFrontImage?: string | null
    aadharBackImage?: string | null
    qualificationImage?: string | null
    VehicleFrontImage?: string | null
    VehicleBackImage?: string | null
    role?: $Enums.Role | null
    storeId?: string | null
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaVerified?: boolean
    createdBy?: string | null
    isAdmin?: boolean
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    manager?: ManagerCreateNestedOneWithoutUserInput
    technician?: TechnicianCreateNestedOneWithoutUserInput
    fieldExecutive?: FieldExecutiveCreateNestedOneWithoutUserInput
    salesExecutive?: SalesExecutiveCreateNestedOneWithoutUserInput
    store?: StoreCreateNestedOneWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    phone: string
    phoneVerified?: boolean | null
    salary?: Decimal | DecimalJsLike | number | string | null
    payoutDate?: number | null
    password: string
    email?: string | null
    dateOfJoining?: Date | string | null
    dateOfTermination?: Date | string | null
    profileImage?: string | null
    aadharFrontImage?: string | null
    aadharBackImage?: string | null
    qualificationImage?: string | null
    VehicleFrontImage?: string | null
    VehicleBackImage?: string | null
    role?: $Enums.Role | null
    storeId?: string | null
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaVerified?: boolean
    createdBy?: string | null
    isAdmin?: boolean
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    manager?: ManagerUncheckedCreateNestedOneWithoutUserInput
    technician?: TechnicianUncheckedCreateNestedOneWithoutUserInput
    fieldExecutive?: FieldExecutiveUncheckedCreateNestedOneWithoutUserInput
    salesExecutive?: SalesExecutiveUncheckedCreateNestedOneWithoutUserInput
    store?: StoreUncheckedCreateNestedOneWithoutUserInput
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    phoneVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payoutDate?: NullableIntFieldUpdateOperationsInput | number | null
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateOfTermination?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    aadharFrontImage?: NullableStringFieldUpdateOperationsInput | string | null
    aadharBackImage?: NullableStringFieldUpdateOperationsInput | string | null
    qualificationImage?: NullableStringFieldUpdateOperationsInput | string | null
    VehicleFrontImage?: NullableStringFieldUpdateOperationsInput | string | null
    VehicleBackImage?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaVerified?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    manager?: ManagerUpdateOneWithoutUserNestedInput
    technician?: TechnicianUpdateOneWithoutUserNestedInput
    fieldExecutive?: FieldExecutiveUpdateOneWithoutUserNestedInput
    salesExecutive?: SalesExecutiveUpdateOneWithoutUserNestedInput
    store?: StoreUpdateOneWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    phoneVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payoutDate?: NullableIntFieldUpdateOperationsInput | number | null
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateOfTermination?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    aadharFrontImage?: NullableStringFieldUpdateOperationsInput | string | null
    aadharBackImage?: NullableStringFieldUpdateOperationsInput | string | null
    qualificationImage?: NullableStringFieldUpdateOperationsInput | string | null
    VehicleFrontImage?: NullableStringFieldUpdateOperationsInput | string | null
    VehicleBackImage?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaVerified?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    manager?: ManagerUncheckedUpdateOneWithoutUserNestedInput
    technician?: TechnicianUncheckedUpdateOneWithoutUserNestedInput
    fieldExecutive?: FieldExecutiveUncheckedUpdateOneWithoutUserNestedInput
    salesExecutive?: SalesExecutiveUncheckedUpdateOneWithoutUserNestedInput
    store?: StoreUncheckedUpdateOneWithoutUserNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
  }

  export type ConnectivityTestResultCreateWithoutDeviceTestInput = {
    id?: string
    name: string
    status: boolean
    message?: string | null
    timestamp?: Date | string | null
  }

  export type ConnectivityTestResultUncheckedCreateWithoutDeviceTestInput = {
    id?: string
    name: string
    status: boolean
    message?: string | null
    timestamp?: Date | string | null
  }

  export type ConnectivityTestResultCreateOrConnectWithoutDeviceTestInput = {
    where: ConnectivityTestResultWhereUniqueInput
    create: XOR<ConnectivityTestResultCreateWithoutDeviceTestInput, ConnectivityTestResultUncheckedCreateWithoutDeviceTestInput>
  }

  export type ConnectivityTestResultCreateManyDeviceTestInputEnvelope = {
    data: ConnectivityTestResultCreateManyDeviceTestInput | ConnectivityTestResultCreateManyDeviceTestInput[]
    skipDuplicates?: boolean
  }

  export type SimTestResultCreateWithoutDeviceTestInput = {
    id?: string
    name: string
    status: boolean
    timestamp?: Date | string | null
  }

  export type SimTestResultUncheckedCreateWithoutDeviceTestInput = {
    id?: string
    name: string
    status: boolean
    timestamp?: Date | string | null
  }

  export type SimTestResultCreateOrConnectWithoutDeviceTestInput = {
    where: SimTestResultWhereUniqueInput
    create: XOR<SimTestResultCreateWithoutDeviceTestInput, SimTestResultUncheckedCreateWithoutDeviceTestInput>
  }

  export type SimTestResultCreateManyDeviceTestInputEnvelope = {
    data: SimTestResultCreateManyDeviceTestInput | SimTestResultCreateManyDeviceTestInput[]
    skipDuplicates?: boolean
  }

  export type DeviceTestResultCreateWithoutDeviceTestInput = {
    id?: string
    name: string
    status: boolean
    message?: string | null
    timestamp?: Date | string | null
  }

  export type DeviceTestResultUncheckedCreateWithoutDeviceTestInput = {
    id?: string
    name: string
    status: boolean
    message?: string | null
    timestamp?: Date | string | null
  }

  export type DeviceTestResultCreateOrConnectWithoutDeviceTestInput = {
    where: DeviceTestResultWhereUniqueInput
    create: XOR<DeviceTestResultCreateWithoutDeviceTestInput, DeviceTestResultUncheckedCreateWithoutDeviceTestInput>
  }

  export type DeviceTestResultCreateManyDeviceTestInputEnvelope = {
    data: DeviceTestResultCreateManyDeviceTestInput | DeviceTestResultCreateManyDeviceTestInput[]
    skipDuplicates?: boolean
  }

  export type ScreenTestCreateWithoutDeviceTestInput = {
    id?: string
    multiTouch: boolean
    dotCoverage: boolean
    completed: boolean
    timestamp?: Date | string | null
  }

  export type ScreenTestUncheckedCreateWithoutDeviceTestInput = {
    id?: string
    multiTouch: boolean
    dotCoverage: boolean
    completed: boolean
    timestamp?: Date | string | null
  }

  export type ScreenTestCreateOrConnectWithoutDeviceTestInput = {
    where: ScreenTestWhereUniqueInput
    create: XOR<ScreenTestCreateWithoutDeviceTestInput, ScreenTestUncheckedCreateWithoutDeviceTestInput>
  }

  export type AudioTestCreateWithoutDeviceTestInput = {
    id?: string
    speaker: boolean
    earReceiver: boolean
    microphone: boolean
    timestamp?: Date | string | null
  }

  export type AudioTestUncheckedCreateWithoutDeviceTestInput = {
    id?: string
    speaker: boolean
    earReceiver: boolean
    microphone: boolean
    timestamp?: Date | string | null
  }

  export type AudioTestCreateOrConnectWithoutDeviceTestInput = {
    where: AudioTestWhereUniqueInput
    create: XOR<AudioTestCreateWithoutDeviceTestInput, AudioTestUncheckedCreateWithoutDeviceTestInput>
  }

  export type ProximitySensorTestCreateWithoutDeviceTestInput = {
    id?: string
    status: boolean
    message?: string | null
    timestamp?: Date | string | null
  }

  export type ProximitySensorTestUncheckedCreateWithoutDeviceTestInput = {
    id?: string
    status: boolean
    message?: string | null
    timestamp?: Date | string | null
  }

  export type ProximitySensorTestCreateOrConnectWithoutDeviceTestInput = {
    where: ProximitySensorTestWhereUniqueInput
    create: XOR<ProximitySensorTestCreateWithoutDeviceTestInput, ProximitySensorTestUncheckedCreateWithoutDeviceTestInput>
  }

  export type CameraTestCreateWithoutDeviceTestInput = {
    id?: string
    frontCamera: boolean
    backCamera: boolean
    timestamp?: Date | string | null
  }

  export type CameraTestUncheckedCreateWithoutDeviceTestInput = {
    id?: string
    frontCamera: boolean
    backCamera: boolean
    timestamp?: Date | string | null
  }

  export type CameraTestCreateOrConnectWithoutDeviceTestInput = {
    where: CameraTestWhereUniqueInput
    create: XOR<CameraTestCreateWithoutDeviceTestInput, CameraTestUncheckedCreateWithoutDeviceTestInput>
  }

  export type FingerprintTestCreateWithoutDeviceTestInput = {
    id?: string
    status: boolean
    message?: string | null
    timestamp?: Date | string | null
  }

  export type FingerprintTestUncheckedCreateWithoutDeviceTestInput = {
    id?: string
    status: boolean
    message?: string | null
    timestamp?: Date | string | null
  }

  export type FingerprintTestCreateOrConnectWithoutDeviceTestInput = {
    where: FingerprintTestWhereUniqueInput
    create: XOR<FingerprintTestCreateWithoutDeviceTestInput, FingerprintTestUncheckedCreateWithoutDeviceTestInput>
  }

  export type UsbTestCreateWithoutDeviceTestInput = {
    id?: string
    status: boolean
    message?: string | null
    timestamp?: Date | string | null
  }

  export type UsbTestUncheckedCreateWithoutDeviceTestInput = {
    id?: string
    status: boolean
    message?: string | null
    timestamp?: Date | string | null
  }

  export type UsbTestCreateOrConnectWithoutDeviceTestInput = {
    where: UsbTestWhereUniqueInput
    create: XOR<UsbTestCreateWithoutDeviceTestInput, UsbTestUncheckedCreateWithoutDeviceTestInput>
  }

  export type AudioJackTestCreateWithoutDeviceTestInput = {
    id?: string
    status: boolean
    message?: string | null
    timestamp?: Date | string | null
  }

  export type AudioJackTestUncheckedCreateWithoutDeviceTestInput = {
    id?: string
    status: boolean
    message?: string | null
    timestamp?: Date | string | null
  }

  export type AudioJackTestCreateOrConnectWithoutDeviceTestInput = {
    where: AudioJackTestWhereUniqueInput
    create: XOR<AudioJackTestCreateWithoutDeviceTestInput, AudioJackTestUncheckedCreateWithoutDeviceTestInput>
  }

  export type ConnectivityTestResultUpsertWithWhereUniqueWithoutDeviceTestInput = {
    where: ConnectivityTestResultWhereUniqueInput
    update: XOR<ConnectivityTestResultUpdateWithoutDeviceTestInput, ConnectivityTestResultUncheckedUpdateWithoutDeviceTestInput>
    create: XOR<ConnectivityTestResultCreateWithoutDeviceTestInput, ConnectivityTestResultUncheckedCreateWithoutDeviceTestInput>
  }

  export type ConnectivityTestResultUpdateWithWhereUniqueWithoutDeviceTestInput = {
    where: ConnectivityTestResultWhereUniqueInput
    data: XOR<ConnectivityTestResultUpdateWithoutDeviceTestInput, ConnectivityTestResultUncheckedUpdateWithoutDeviceTestInput>
  }

  export type ConnectivityTestResultUpdateManyWithWhereWithoutDeviceTestInput = {
    where: ConnectivityTestResultScalarWhereInput
    data: XOR<ConnectivityTestResultUpdateManyMutationInput, ConnectivityTestResultUncheckedUpdateManyWithoutDeviceTestInput>
  }

  export type ConnectivityTestResultScalarWhereInput = {
    AND?: ConnectivityTestResultScalarWhereInput | ConnectivityTestResultScalarWhereInput[]
    OR?: ConnectivityTestResultScalarWhereInput[]
    NOT?: ConnectivityTestResultScalarWhereInput | ConnectivityTestResultScalarWhereInput[]
    id?: StringFilter<"ConnectivityTestResult"> | string
    name?: StringFilter<"ConnectivityTestResult"> | string
    status?: BoolFilter<"ConnectivityTestResult"> | boolean
    message?: StringNullableFilter<"ConnectivityTestResult"> | string | null
    timestamp?: DateTimeNullableFilter<"ConnectivityTestResult"> | Date | string | null
    deviceTestId?: StringFilter<"ConnectivityTestResult"> | string
  }

  export type SimTestResultUpsertWithWhereUniqueWithoutDeviceTestInput = {
    where: SimTestResultWhereUniqueInput
    update: XOR<SimTestResultUpdateWithoutDeviceTestInput, SimTestResultUncheckedUpdateWithoutDeviceTestInput>
    create: XOR<SimTestResultCreateWithoutDeviceTestInput, SimTestResultUncheckedCreateWithoutDeviceTestInput>
  }

  export type SimTestResultUpdateWithWhereUniqueWithoutDeviceTestInput = {
    where: SimTestResultWhereUniqueInput
    data: XOR<SimTestResultUpdateWithoutDeviceTestInput, SimTestResultUncheckedUpdateWithoutDeviceTestInput>
  }

  export type SimTestResultUpdateManyWithWhereWithoutDeviceTestInput = {
    where: SimTestResultScalarWhereInput
    data: XOR<SimTestResultUpdateManyMutationInput, SimTestResultUncheckedUpdateManyWithoutDeviceTestInput>
  }

  export type SimTestResultScalarWhereInput = {
    AND?: SimTestResultScalarWhereInput | SimTestResultScalarWhereInput[]
    OR?: SimTestResultScalarWhereInput[]
    NOT?: SimTestResultScalarWhereInput | SimTestResultScalarWhereInput[]
    id?: StringFilter<"SimTestResult"> | string
    name?: StringFilter<"SimTestResult"> | string
    status?: BoolFilter<"SimTestResult"> | boolean
    timestamp?: DateTimeNullableFilter<"SimTestResult"> | Date | string | null
    deviceTestId?: StringFilter<"SimTestResult"> | string
  }

  export type DeviceTestResultUpsertWithWhereUniqueWithoutDeviceTestInput = {
    where: DeviceTestResultWhereUniqueInput
    update: XOR<DeviceTestResultUpdateWithoutDeviceTestInput, DeviceTestResultUncheckedUpdateWithoutDeviceTestInput>
    create: XOR<DeviceTestResultCreateWithoutDeviceTestInput, DeviceTestResultUncheckedCreateWithoutDeviceTestInput>
  }

  export type DeviceTestResultUpdateWithWhereUniqueWithoutDeviceTestInput = {
    where: DeviceTestResultWhereUniqueInput
    data: XOR<DeviceTestResultUpdateWithoutDeviceTestInput, DeviceTestResultUncheckedUpdateWithoutDeviceTestInput>
  }

  export type DeviceTestResultUpdateManyWithWhereWithoutDeviceTestInput = {
    where: DeviceTestResultScalarWhereInput
    data: XOR<DeviceTestResultUpdateManyMutationInput, DeviceTestResultUncheckedUpdateManyWithoutDeviceTestInput>
  }

  export type DeviceTestResultScalarWhereInput = {
    AND?: DeviceTestResultScalarWhereInput | DeviceTestResultScalarWhereInput[]
    OR?: DeviceTestResultScalarWhereInput[]
    NOT?: DeviceTestResultScalarWhereInput | DeviceTestResultScalarWhereInput[]
    id?: StringFilter<"DeviceTestResult"> | string
    name?: StringFilter<"DeviceTestResult"> | string
    status?: BoolFilter<"DeviceTestResult"> | boolean
    message?: StringNullableFilter<"DeviceTestResult"> | string | null
    timestamp?: DateTimeNullableFilter<"DeviceTestResult"> | Date | string | null
    deviceTestId?: StringFilter<"DeviceTestResult"> | string
  }

  export type ScreenTestUpsertWithoutDeviceTestInput = {
    update: XOR<ScreenTestUpdateWithoutDeviceTestInput, ScreenTestUncheckedUpdateWithoutDeviceTestInput>
    create: XOR<ScreenTestCreateWithoutDeviceTestInput, ScreenTestUncheckedCreateWithoutDeviceTestInput>
    where?: ScreenTestWhereInput
  }

  export type ScreenTestUpdateToOneWithWhereWithoutDeviceTestInput = {
    where?: ScreenTestWhereInput
    data: XOR<ScreenTestUpdateWithoutDeviceTestInput, ScreenTestUncheckedUpdateWithoutDeviceTestInput>
  }

  export type ScreenTestUpdateWithoutDeviceTestInput = {
    id?: StringFieldUpdateOperationsInput | string
    multiTouch?: BoolFieldUpdateOperationsInput | boolean
    dotCoverage?: BoolFieldUpdateOperationsInput | boolean
    completed?: BoolFieldUpdateOperationsInput | boolean
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ScreenTestUncheckedUpdateWithoutDeviceTestInput = {
    id?: StringFieldUpdateOperationsInput | string
    multiTouch?: BoolFieldUpdateOperationsInput | boolean
    dotCoverage?: BoolFieldUpdateOperationsInput | boolean
    completed?: BoolFieldUpdateOperationsInput | boolean
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AudioTestUpsertWithoutDeviceTestInput = {
    update: XOR<AudioTestUpdateWithoutDeviceTestInput, AudioTestUncheckedUpdateWithoutDeviceTestInput>
    create: XOR<AudioTestCreateWithoutDeviceTestInput, AudioTestUncheckedCreateWithoutDeviceTestInput>
    where?: AudioTestWhereInput
  }

  export type AudioTestUpdateToOneWithWhereWithoutDeviceTestInput = {
    where?: AudioTestWhereInput
    data: XOR<AudioTestUpdateWithoutDeviceTestInput, AudioTestUncheckedUpdateWithoutDeviceTestInput>
  }

  export type AudioTestUpdateWithoutDeviceTestInput = {
    id?: StringFieldUpdateOperationsInput | string
    speaker?: BoolFieldUpdateOperationsInput | boolean
    earReceiver?: BoolFieldUpdateOperationsInput | boolean
    microphone?: BoolFieldUpdateOperationsInput | boolean
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AudioTestUncheckedUpdateWithoutDeviceTestInput = {
    id?: StringFieldUpdateOperationsInput | string
    speaker?: BoolFieldUpdateOperationsInput | boolean
    earReceiver?: BoolFieldUpdateOperationsInput | boolean
    microphone?: BoolFieldUpdateOperationsInput | boolean
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProximitySensorTestUpsertWithoutDeviceTestInput = {
    update: XOR<ProximitySensorTestUpdateWithoutDeviceTestInput, ProximitySensorTestUncheckedUpdateWithoutDeviceTestInput>
    create: XOR<ProximitySensorTestCreateWithoutDeviceTestInput, ProximitySensorTestUncheckedCreateWithoutDeviceTestInput>
    where?: ProximitySensorTestWhereInput
  }

  export type ProximitySensorTestUpdateToOneWithWhereWithoutDeviceTestInput = {
    where?: ProximitySensorTestWhereInput
    data: XOR<ProximitySensorTestUpdateWithoutDeviceTestInput, ProximitySensorTestUncheckedUpdateWithoutDeviceTestInput>
  }

  export type ProximitySensorTestUpdateWithoutDeviceTestInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    message?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProximitySensorTestUncheckedUpdateWithoutDeviceTestInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    message?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CameraTestUpsertWithoutDeviceTestInput = {
    update: XOR<CameraTestUpdateWithoutDeviceTestInput, CameraTestUncheckedUpdateWithoutDeviceTestInput>
    create: XOR<CameraTestCreateWithoutDeviceTestInput, CameraTestUncheckedCreateWithoutDeviceTestInput>
    where?: CameraTestWhereInput
  }

  export type CameraTestUpdateToOneWithWhereWithoutDeviceTestInput = {
    where?: CameraTestWhereInput
    data: XOR<CameraTestUpdateWithoutDeviceTestInput, CameraTestUncheckedUpdateWithoutDeviceTestInput>
  }

  export type CameraTestUpdateWithoutDeviceTestInput = {
    id?: StringFieldUpdateOperationsInput | string
    frontCamera?: BoolFieldUpdateOperationsInput | boolean
    backCamera?: BoolFieldUpdateOperationsInput | boolean
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CameraTestUncheckedUpdateWithoutDeviceTestInput = {
    id?: StringFieldUpdateOperationsInput | string
    frontCamera?: BoolFieldUpdateOperationsInput | boolean
    backCamera?: BoolFieldUpdateOperationsInput | boolean
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FingerprintTestUpsertWithoutDeviceTestInput = {
    update: XOR<FingerprintTestUpdateWithoutDeviceTestInput, FingerprintTestUncheckedUpdateWithoutDeviceTestInput>
    create: XOR<FingerprintTestCreateWithoutDeviceTestInput, FingerprintTestUncheckedCreateWithoutDeviceTestInput>
    where?: FingerprintTestWhereInput
  }

  export type FingerprintTestUpdateToOneWithWhereWithoutDeviceTestInput = {
    where?: FingerprintTestWhereInput
    data: XOR<FingerprintTestUpdateWithoutDeviceTestInput, FingerprintTestUncheckedUpdateWithoutDeviceTestInput>
  }

  export type FingerprintTestUpdateWithoutDeviceTestInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    message?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FingerprintTestUncheckedUpdateWithoutDeviceTestInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    message?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UsbTestUpsertWithoutDeviceTestInput = {
    update: XOR<UsbTestUpdateWithoutDeviceTestInput, UsbTestUncheckedUpdateWithoutDeviceTestInput>
    create: XOR<UsbTestCreateWithoutDeviceTestInput, UsbTestUncheckedCreateWithoutDeviceTestInput>
    where?: UsbTestWhereInput
  }

  export type UsbTestUpdateToOneWithWhereWithoutDeviceTestInput = {
    where?: UsbTestWhereInput
    data: XOR<UsbTestUpdateWithoutDeviceTestInput, UsbTestUncheckedUpdateWithoutDeviceTestInput>
  }

  export type UsbTestUpdateWithoutDeviceTestInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    message?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UsbTestUncheckedUpdateWithoutDeviceTestInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    message?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AudioJackTestUpsertWithoutDeviceTestInput = {
    update: XOR<AudioJackTestUpdateWithoutDeviceTestInput, AudioJackTestUncheckedUpdateWithoutDeviceTestInput>
    create: XOR<AudioJackTestCreateWithoutDeviceTestInput, AudioJackTestUncheckedCreateWithoutDeviceTestInput>
    where?: AudioJackTestWhereInput
  }

  export type AudioJackTestUpdateToOneWithWhereWithoutDeviceTestInput = {
    where?: AudioJackTestWhereInput
    data: XOR<AudioJackTestUpdateWithoutDeviceTestInput, AudioJackTestUncheckedUpdateWithoutDeviceTestInput>
  }

  export type AudioJackTestUpdateWithoutDeviceTestInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    message?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AudioJackTestUncheckedUpdateWithoutDeviceTestInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    message?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DeviceTestCreateWithoutConnectivityTestResultsInput = {
    id?: string
    testId: string
    employeeId?: string | null
    imageUrl?: string | null
    expiresAt: Date | string
    device: JsonNullValueInput | InputJsonValue
    imei1?: string | null
    imei2?: string | null
    createdAt?: Date | string
    simTestResults?: SimTestResultCreateNestedManyWithoutDeviceTestInput
    deviceTestResults?: DeviceTestResultCreateNestedManyWithoutDeviceTestInput
    screenTest?: ScreenTestCreateNestedOneWithoutDeviceTestInput
    audioTest?: AudioTestCreateNestedOneWithoutDeviceTestInput
    proximitySensorTest?: ProximitySensorTestCreateNestedOneWithoutDeviceTestInput
    cameraTest?: CameraTestCreateNestedOneWithoutDeviceTestInput
    fingerprintTest?: FingerprintTestCreateNestedOneWithoutDeviceTestInput
    usbTest?: UsbTestCreateNestedOneWithoutDeviceTestInput
    audioJackTest?: AudioJackTestCreateNestedOneWithoutDeviceTestInput
  }

  export type DeviceTestUncheckedCreateWithoutConnectivityTestResultsInput = {
    id?: string
    testId: string
    employeeId?: string | null
    imageUrl?: string | null
    expiresAt: Date | string
    device: JsonNullValueInput | InputJsonValue
    imei1?: string | null
    imei2?: string | null
    createdAt?: Date | string
    simTestResults?: SimTestResultUncheckedCreateNestedManyWithoutDeviceTestInput
    deviceTestResults?: DeviceTestResultUncheckedCreateNestedManyWithoutDeviceTestInput
    screenTest?: ScreenTestUncheckedCreateNestedOneWithoutDeviceTestInput
    audioTest?: AudioTestUncheckedCreateNestedOneWithoutDeviceTestInput
    proximitySensorTest?: ProximitySensorTestUncheckedCreateNestedOneWithoutDeviceTestInput
    cameraTest?: CameraTestUncheckedCreateNestedOneWithoutDeviceTestInput
    fingerprintTest?: FingerprintTestUncheckedCreateNestedOneWithoutDeviceTestInput
    usbTest?: UsbTestUncheckedCreateNestedOneWithoutDeviceTestInput
    audioJackTest?: AudioJackTestUncheckedCreateNestedOneWithoutDeviceTestInput
  }

  export type DeviceTestCreateOrConnectWithoutConnectivityTestResultsInput = {
    where: DeviceTestWhereUniqueInput
    create: XOR<DeviceTestCreateWithoutConnectivityTestResultsInput, DeviceTestUncheckedCreateWithoutConnectivityTestResultsInput>
  }

  export type DeviceTestUpsertWithoutConnectivityTestResultsInput = {
    update: XOR<DeviceTestUpdateWithoutConnectivityTestResultsInput, DeviceTestUncheckedUpdateWithoutConnectivityTestResultsInput>
    create: XOR<DeviceTestCreateWithoutConnectivityTestResultsInput, DeviceTestUncheckedCreateWithoutConnectivityTestResultsInput>
    where?: DeviceTestWhereInput
  }

  export type DeviceTestUpdateToOneWithWhereWithoutConnectivityTestResultsInput = {
    where?: DeviceTestWhereInput
    data: XOR<DeviceTestUpdateWithoutConnectivityTestResultsInput, DeviceTestUncheckedUpdateWithoutConnectivityTestResultsInput>
  }

  export type DeviceTestUpdateWithoutConnectivityTestResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    testId?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    device?: JsonNullValueInput | InputJsonValue
    imei1?: NullableStringFieldUpdateOperationsInput | string | null
    imei2?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    simTestResults?: SimTestResultUpdateManyWithoutDeviceTestNestedInput
    deviceTestResults?: DeviceTestResultUpdateManyWithoutDeviceTestNestedInput
    screenTest?: ScreenTestUpdateOneWithoutDeviceTestNestedInput
    audioTest?: AudioTestUpdateOneWithoutDeviceTestNestedInput
    proximitySensorTest?: ProximitySensorTestUpdateOneWithoutDeviceTestNestedInput
    cameraTest?: CameraTestUpdateOneWithoutDeviceTestNestedInput
    fingerprintTest?: FingerprintTestUpdateOneWithoutDeviceTestNestedInput
    usbTest?: UsbTestUpdateOneWithoutDeviceTestNestedInput
    audioJackTest?: AudioJackTestUpdateOneWithoutDeviceTestNestedInput
  }

  export type DeviceTestUncheckedUpdateWithoutConnectivityTestResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    testId?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    device?: JsonNullValueInput | InputJsonValue
    imei1?: NullableStringFieldUpdateOperationsInput | string | null
    imei2?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    simTestResults?: SimTestResultUncheckedUpdateManyWithoutDeviceTestNestedInput
    deviceTestResults?: DeviceTestResultUncheckedUpdateManyWithoutDeviceTestNestedInput
    screenTest?: ScreenTestUncheckedUpdateOneWithoutDeviceTestNestedInput
    audioTest?: AudioTestUncheckedUpdateOneWithoutDeviceTestNestedInput
    proximitySensorTest?: ProximitySensorTestUncheckedUpdateOneWithoutDeviceTestNestedInput
    cameraTest?: CameraTestUncheckedUpdateOneWithoutDeviceTestNestedInput
    fingerprintTest?: FingerprintTestUncheckedUpdateOneWithoutDeviceTestNestedInput
    usbTest?: UsbTestUncheckedUpdateOneWithoutDeviceTestNestedInput
    audioJackTest?: AudioJackTestUncheckedUpdateOneWithoutDeviceTestNestedInput
  }

  export type DeviceTestCreateWithoutDeviceTestResultsInput = {
    id?: string
    testId: string
    employeeId?: string | null
    imageUrl?: string | null
    expiresAt: Date | string
    device: JsonNullValueInput | InputJsonValue
    imei1?: string | null
    imei2?: string | null
    createdAt?: Date | string
    connectivityTestResults?: ConnectivityTestResultCreateNestedManyWithoutDeviceTestInput
    simTestResults?: SimTestResultCreateNestedManyWithoutDeviceTestInput
    screenTest?: ScreenTestCreateNestedOneWithoutDeviceTestInput
    audioTest?: AudioTestCreateNestedOneWithoutDeviceTestInput
    proximitySensorTest?: ProximitySensorTestCreateNestedOneWithoutDeviceTestInput
    cameraTest?: CameraTestCreateNestedOneWithoutDeviceTestInput
    fingerprintTest?: FingerprintTestCreateNestedOneWithoutDeviceTestInput
    usbTest?: UsbTestCreateNestedOneWithoutDeviceTestInput
    audioJackTest?: AudioJackTestCreateNestedOneWithoutDeviceTestInput
  }

  export type DeviceTestUncheckedCreateWithoutDeviceTestResultsInput = {
    id?: string
    testId: string
    employeeId?: string | null
    imageUrl?: string | null
    expiresAt: Date | string
    device: JsonNullValueInput | InputJsonValue
    imei1?: string | null
    imei2?: string | null
    createdAt?: Date | string
    connectivityTestResults?: ConnectivityTestResultUncheckedCreateNestedManyWithoutDeviceTestInput
    simTestResults?: SimTestResultUncheckedCreateNestedManyWithoutDeviceTestInput
    screenTest?: ScreenTestUncheckedCreateNestedOneWithoutDeviceTestInput
    audioTest?: AudioTestUncheckedCreateNestedOneWithoutDeviceTestInput
    proximitySensorTest?: ProximitySensorTestUncheckedCreateNestedOneWithoutDeviceTestInput
    cameraTest?: CameraTestUncheckedCreateNestedOneWithoutDeviceTestInput
    fingerprintTest?: FingerprintTestUncheckedCreateNestedOneWithoutDeviceTestInput
    usbTest?: UsbTestUncheckedCreateNestedOneWithoutDeviceTestInput
    audioJackTest?: AudioJackTestUncheckedCreateNestedOneWithoutDeviceTestInput
  }

  export type DeviceTestCreateOrConnectWithoutDeviceTestResultsInput = {
    where: DeviceTestWhereUniqueInput
    create: XOR<DeviceTestCreateWithoutDeviceTestResultsInput, DeviceTestUncheckedCreateWithoutDeviceTestResultsInput>
  }

  export type DeviceTestUpsertWithoutDeviceTestResultsInput = {
    update: XOR<DeviceTestUpdateWithoutDeviceTestResultsInput, DeviceTestUncheckedUpdateWithoutDeviceTestResultsInput>
    create: XOR<DeviceTestCreateWithoutDeviceTestResultsInput, DeviceTestUncheckedCreateWithoutDeviceTestResultsInput>
    where?: DeviceTestWhereInput
  }

  export type DeviceTestUpdateToOneWithWhereWithoutDeviceTestResultsInput = {
    where?: DeviceTestWhereInput
    data: XOR<DeviceTestUpdateWithoutDeviceTestResultsInput, DeviceTestUncheckedUpdateWithoutDeviceTestResultsInput>
  }

  export type DeviceTestUpdateWithoutDeviceTestResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    testId?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    device?: JsonNullValueInput | InputJsonValue
    imei1?: NullableStringFieldUpdateOperationsInput | string | null
    imei2?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    connectivityTestResults?: ConnectivityTestResultUpdateManyWithoutDeviceTestNestedInput
    simTestResults?: SimTestResultUpdateManyWithoutDeviceTestNestedInput
    screenTest?: ScreenTestUpdateOneWithoutDeviceTestNestedInput
    audioTest?: AudioTestUpdateOneWithoutDeviceTestNestedInput
    proximitySensorTest?: ProximitySensorTestUpdateOneWithoutDeviceTestNestedInput
    cameraTest?: CameraTestUpdateOneWithoutDeviceTestNestedInput
    fingerprintTest?: FingerprintTestUpdateOneWithoutDeviceTestNestedInput
    usbTest?: UsbTestUpdateOneWithoutDeviceTestNestedInput
    audioJackTest?: AudioJackTestUpdateOneWithoutDeviceTestNestedInput
  }

  export type DeviceTestUncheckedUpdateWithoutDeviceTestResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    testId?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    device?: JsonNullValueInput | InputJsonValue
    imei1?: NullableStringFieldUpdateOperationsInput | string | null
    imei2?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    connectivityTestResults?: ConnectivityTestResultUncheckedUpdateManyWithoutDeviceTestNestedInput
    simTestResults?: SimTestResultUncheckedUpdateManyWithoutDeviceTestNestedInput
    screenTest?: ScreenTestUncheckedUpdateOneWithoutDeviceTestNestedInput
    audioTest?: AudioTestUncheckedUpdateOneWithoutDeviceTestNestedInput
    proximitySensorTest?: ProximitySensorTestUncheckedUpdateOneWithoutDeviceTestNestedInput
    cameraTest?: CameraTestUncheckedUpdateOneWithoutDeviceTestNestedInput
    fingerprintTest?: FingerprintTestUncheckedUpdateOneWithoutDeviceTestNestedInput
    usbTest?: UsbTestUncheckedUpdateOneWithoutDeviceTestNestedInput
    audioJackTest?: AudioJackTestUncheckedUpdateOneWithoutDeviceTestNestedInput
  }

  export type DeviceTestCreateWithoutSimTestResultsInput = {
    id?: string
    testId: string
    employeeId?: string | null
    imageUrl?: string | null
    expiresAt: Date | string
    device: JsonNullValueInput | InputJsonValue
    imei1?: string | null
    imei2?: string | null
    createdAt?: Date | string
    connectivityTestResults?: ConnectivityTestResultCreateNestedManyWithoutDeviceTestInput
    deviceTestResults?: DeviceTestResultCreateNestedManyWithoutDeviceTestInput
    screenTest?: ScreenTestCreateNestedOneWithoutDeviceTestInput
    audioTest?: AudioTestCreateNestedOneWithoutDeviceTestInput
    proximitySensorTest?: ProximitySensorTestCreateNestedOneWithoutDeviceTestInput
    cameraTest?: CameraTestCreateNestedOneWithoutDeviceTestInput
    fingerprintTest?: FingerprintTestCreateNestedOneWithoutDeviceTestInput
    usbTest?: UsbTestCreateNestedOneWithoutDeviceTestInput
    audioJackTest?: AudioJackTestCreateNestedOneWithoutDeviceTestInput
  }

  export type DeviceTestUncheckedCreateWithoutSimTestResultsInput = {
    id?: string
    testId: string
    employeeId?: string | null
    imageUrl?: string | null
    expiresAt: Date | string
    device: JsonNullValueInput | InputJsonValue
    imei1?: string | null
    imei2?: string | null
    createdAt?: Date | string
    connectivityTestResults?: ConnectivityTestResultUncheckedCreateNestedManyWithoutDeviceTestInput
    deviceTestResults?: DeviceTestResultUncheckedCreateNestedManyWithoutDeviceTestInput
    screenTest?: ScreenTestUncheckedCreateNestedOneWithoutDeviceTestInput
    audioTest?: AudioTestUncheckedCreateNestedOneWithoutDeviceTestInput
    proximitySensorTest?: ProximitySensorTestUncheckedCreateNestedOneWithoutDeviceTestInput
    cameraTest?: CameraTestUncheckedCreateNestedOneWithoutDeviceTestInput
    fingerprintTest?: FingerprintTestUncheckedCreateNestedOneWithoutDeviceTestInput
    usbTest?: UsbTestUncheckedCreateNestedOneWithoutDeviceTestInput
    audioJackTest?: AudioJackTestUncheckedCreateNestedOneWithoutDeviceTestInput
  }

  export type DeviceTestCreateOrConnectWithoutSimTestResultsInput = {
    where: DeviceTestWhereUniqueInput
    create: XOR<DeviceTestCreateWithoutSimTestResultsInput, DeviceTestUncheckedCreateWithoutSimTestResultsInput>
  }

  export type DeviceTestUpsertWithoutSimTestResultsInput = {
    update: XOR<DeviceTestUpdateWithoutSimTestResultsInput, DeviceTestUncheckedUpdateWithoutSimTestResultsInput>
    create: XOR<DeviceTestCreateWithoutSimTestResultsInput, DeviceTestUncheckedCreateWithoutSimTestResultsInput>
    where?: DeviceTestWhereInput
  }

  export type DeviceTestUpdateToOneWithWhereWithoutSimTestResultsInput = {
    where?: DeviceTestWhereInput
    data: XOR<DeviceTestUpdateWithoutSimTestResultsInput, DeviceTestUncheckedUpdateWithoutSimTestResultsInput>
  }

  export type DeviceTestUpdateWithoutSimTestResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    testId?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    device?: JsonNullValueInput | InputJsonValue
    imei1?: NullableStringFieldUpdateOperationsInput | string | null
    imei2?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    connectivityTestResults?: ConnectivityTestResultUpdateManyWithoutDeviceTestNestedInput
    deviceTestResults?: DeviceTestResultUpdateManyWithoutDeviceTestNestedInput
    screenTest?: ScreenTestUpdateOneWithoutDeviceTestNestedInput
    audioTest?: AudioTestUpdateOneWithoutDeviceTestNestedInput
    proximitySensorTest?: ProximitySensorTestUpdateOneWithoutDeviceTestNestedInput
    cameraTest?: CameraTestUpdateOneWithoutDeviceTestNestedInput
    fingerprintTest?: FingerprintTestUpdateOneWithoutDeviceTestNestedInput
    usbTest?: UsbTestUpdateOneWithoutDeviceTestNestedInput
    audioJackTest?: AudioJackTestUpdateOneWithoutDeviceTestNestedInput
  }

  export type DeviceTestUncheckedUpdateWithoutSimTestResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    testId?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    device?: JsonNullValueInput | InputJsonValue
    imei1?: NullableStringFieldUpdateOperationsInput | string | null
    imei2?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    connectivityTestResults?: ConnectivityTestResultUncheckedUpdateManyWithoutDeviceTestNestedInput
    deviceTestResults?: DeviceTestResultUncheckedUpdateManyWithoutDeviceTestNestedInput
    screenTest?: ScreenTestUncheckedUpdateOneWithoutDeviceTestNestedInput
    audioTest?: AudioTestUncheckedUpdateOneWithoutDeviceTestNestedInput
    proximitySensorTest?: ProximitySensorTestUncheckedUpdateOneWithoutDeviceTestNestedInput
    cameraTest?: CameraTestUncheckedUpdateOneWithoutDeviceTestNestedInput
    fingerprintTest?: FingerprintTestUncheckedUpdateOneWithoutDeviceTestNestedInput
    usbTest?: UsbTestUncheckedUpdateOneWithoutDeviceTestNestedInput
    audioJackTest?: AudioJackTestUncheckedUpdateOneWithoutDeviceTestNestedInput
  }

  export type DeviceTestCreateWithoutScreenTestInput = {
    id?: string
    testId: string
    employeeId?: string | null
    imageUrl?: string | null
    expiresAt: Date | string
    device: JsonNullValueInput | InputJsonValue
    imei1?: string | null
    imei2?: string | null
    createdAt?: Date | string
    connectivityTestResults?: ConnectivityTestResultCreateNestedManyWithoutDeviceTestInput
    simTestResults?: SimTestResultCreateNestedManyWithoutDeviceTestInput
    deviceTestResults?: DeviceTestResultCreateNestedManyWithoutDeviceTestInput
    audioTest?: AudioTestCreateNestedOneWithoutDeviceTestInput
    proximitySensorTest?: ProximitySensorTestCreateNestedOneWithoutDeviceTestInput
    cameraTest?: CameraTestCreateNestedOneWithoutDeviceTestInput
    fingerprintTest?: FingerprintTestCreateNestedOneWithoutDeviceTestInput
    usbTest?: UsbTestCreateNestedOneWithoutDeviceTestInput
    audioJackTest?: AudioJackTestCreateNestedOneWithoutDeviceTestInput
  }

  export type DeviceTestUncheckedCreateWithoutScreenTestInput = {
    id?: string
    testId: string
    employeeId?: string | null
    imageUrl?: string | null
    expiresAt: Date | string
    device: JsonNullValueInput | InputJsonValue
    imei1?: string | null
    imei2?: string | null
    createdAt?: Date | string
    connectivityTestResults?: ConnectivityTestResultUncheckedCreateNestedManyWithoutDeviceTestInput
    simTestResults?: SimTestResultUncheckedCreateNestedManyWithoutDeviceTestInput
    deviceTestResults?: DeviceTestResultUncheckedCreateNestedManyWithoutDeviceTestInput
    audioTest?: AudioTestUncheckedCreateNestedOneWithoutDeviceTestInput
    proximitySensorTest?: ProximitySensorTestUncheckedCreateNestedOneWithoutDeviceTestInput
    cameraTest?: CameraTestUncheckedCreateNestedOneWithoutDeviceTestInput
    fingerprintTest?: FingerprintTestUncheckedCreateNestedOneWithoutDeviceTestInput
    usbTest?: UsbTestUncheckedCreateNestedOneWithoutDeviceTestInput
    audioJackTest?: AudioJackTestUncheckedCreateNestedOneWithoutDeviceTestInput
  }

  export type DeviceTestCreateOrConnectWithoutScreenTestInput = {
    where: DeviceTestWhereUniqueInput
    create: XOR<DeviceTestCreateWithoutScreenTestInput, DeviceTestUncheckedCreateWithoutScreenTestInput>
  }

  export type DeviceTestUpsertWithoutScreenTestInput = {
    update: XOR<DeviceTestUpdateWithoutScreenTestInput, DeviceTestUncheckedUpdateWithoutScreenTestInput>
    create: XOR<DeviceTestCreateWithoutScreenTestInput, DeviceTestUncheckedCreateWithoutScreenTestInput>
    where?: DeviceTestWhereInput
  }

  export type DeviceTestUpdateToOneWithWhereWithoutScreenTestInput = {
    where?: DeviceTestWhereInput
    data: XOR<DeviceTestUpdateWithoutScreenTestInput, DeviceTestUncheckedUpdateWithoutScreenTestInput>
  }

  export type DeviceTestUpdateWithoutScreenTestInput = {
    id?: StringFieldUpdateOperationsInput | string
    testId?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    device?: JsonNullValueInput | InputJsonValue
    imei1?: NullableStringFieldUpdateOperationsInput | string | null
    imei2?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    connectivityTestResults?: ConnectivityTestResultUpdateManyWithoutDeviceTestNestedInput
    simTestResults?: SimTestResultUpdateManyWithoutDeviceTestNestedInput
    deviceTestResults?: DeviceTestResultUpdateManyWithoutDeviceTestNestedInput
    audioTest?: AudioTestUpdateOneWithoutDeviceTestNestedInput
    proximitySensorTest?: ProximitySensorTestUpdateOneWithoutDeviceTestNestedInput
    cameraTest?: CameraTestUpdateOneWithoutDeviceTestNestedInput
    fingerprintTest?: FingerprintTestUpdateOneWithoutDeviceTestNestedInput
    usbTest?: UsbTestUpdateOneWithoutDeviceTestNestedInput
    audioJackTest?: AudioJackTestUpdateOneWithoutDeviceTestNestedInput
  }

  export type DeviceTestUncheckedUpdateWithoutScreenTestInput = {
    id?: StringFieldUpdateOperationsInput | string
    testId?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    device?: JsonNullValueInput | InputJsonValue
    imei1?: NullableStringFieldUpdateOperationsInput | string | null
    imei2?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    connectivityTestResults?: ConnectivityTestResultUncheckedUpdateManyWithoutDeviceTestNestedInput
    simTestResults?: SimTestResultUncheckedUpdateManyWithoutDeviceTestNestedInput
    deviceTestResults?: DeviceTestResultUncheckedUpdateManyWithoutDeviceTestNestedInput
    audioTest?: AudioTestUncheckedUpdateOneWithoutDeviceTestNestedInput
    proximitySensorTest?: ProximitySensorTestUncheckedUpdateOneWithoutDeviceTestNestedInput
    cameraTest?: CameraTestUncheckedUpdateOneWithoutDeviceTestNestedInput
    fingerprintTest?: FingerprintTestUncheckedUpdateOneWithoutDeviceTestNestedInput
    usbTest?: UsbTestUncheckedUpdateOneWithoutDeviceTestNestedInput
    audioJackTest?: AudioJackTestUncheckedUpdateOneWithoutDeviceTestNestedInput
  }

  export type DeviceTestCreateWithoutAudioTestInput = {
    id?: string
    testId: string
    employeeId?: string | null
    imageUrl?: string | null
    expiresAt: Date | string
    device: JsonNullValueInput | InputJsonValue
    imei1?: string | null
    imei2?: string | null
    createdAt?: Date | string
    connectivityTestResults?: ConnectivityTestResultCreateNestedManyWithoutDeviceTestInput
    simTestResults?: SimTestResultCreateNestedManyWithoutDeviceTestInput
    deviceTestResults?: DeviceTestResultCreateNestedManyWithoutDeviceTestInput
    screenTest?: ScreenTestCreateNestedOneWithoutDeviceTestInput
    proximitySensorTest?: ProximitySensorTestCreateNestedOneWithoutDeviceTestInput
    cameraTest?: CameraTestCreateNestedOneWithoutDeviceTestInput
    fingerprintTest?: FingerprintTestCreateNestedOneWithoutDeviceTestInput
    usbTest?: UsbTestCreateNestedOneWithoutDeviceTestInput
    audioJackTest?: AudioJackTestCreateNestedOneWithoutDeviceTestInput
  }

  export type DeviceTestUncheckedCreateWithoutAudioTestInput = {
    id?: string
    testId: string
    employeeId?: string | null
    imageUrl?: string | null
    expiresAt: Date | string
    device: JsonNullValueInput | InputJsonValue
    imei1?: string | null
    imei2?: string | null
    createdAt?: Date | string
    connectivityTestResults?: ConnectivityTestResultUncheckedCreateNestedManyWithoutDeviceTestInput
    simTestResults?: SimTestResultUncheckedCreateNestedManyWithoutDeviceTestInput
    deviceTestResults?: DeviceTestResultUncheckedCreateNestedManyWithoutDeviceTestInput
    screenTest?: ScreenTestUncheckedCreateNestedOneWithoutDeviceTestInput
    proximitySensorTest?: ProximitySensorTestUncheckedCreateNestedOneWithoutDeviceTestInput
    cameraTest?: CameraTestUncheckedCreateNestedOneWithoutDeviceTestInput
    fingerprintTest?: FingerprintTestUncheckedCreateNestedOneWithoutDeviceTestInput
    usbTest?: UsbTestUncheckedCreateNestedOneWithoutDeviceTestInput
    audioJackTest?: AudioJackTestUncheckedCreateNestedOneWithoutDeviceTestInput
  }

  export type DeviceTestCreateOrConnectWithoutAudioTestInput = {
    where: DeviceTestWhereUniqueInput
    create: XOR<DeviceTestCreateWithoutAudioTestInput, DeviceTestUncheckedCreateWithoutAudioTestInput>
  }

  export type DeviceTestUpsertWithoutAudioTestInput = {
    update: XOR<DeviceTestUpdateWithoutAudioTestInput, DeviceTestUncheckedUpdateWithoutAudioTestInput>
    create: XOR<DeviceTestCreateWithoutAudioTestInput, DeviceTestUncheckedCreateWithoutAudioTestInput>
    where?: DeviceTestWhereInput
  }

  export type DeviceTestUpdateToOneWithWhereWithoutAudioTestInput = {
    where?: DeviceTestWhereInput
    data: XOR<DeviceTestUpdateWithoutAudioTestInput, DeviceTestUncheckedUpdateWithoutAudioTestInput>
  }

  export type DeviceTestUpdateWithoutAudioTestInput = {
    id?: StringFieldUpdateOperationsInput | string
    testId?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    device?: JsonNullValueInput | InputJsonValue
    imei1?: NullableStringFieldUpdateOperationsInput | string | null
    imei2?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    connectivityTestResults?: ConnectivityTestResultUpdateManyWithoutDeviceTestNestedInput
    simTestResults?: SimTestResultUpdateManyWithoutDeviceTestNestedInput
    deviceTestResults?: DeviceTestResultUpdateManyWithoutDeviceTestNestedInput
    screenTest?: ScreenTestUpdateOneWithoutDeviceTestNestedInput
    proximitySensorTest?: ProximitySensorTestUpdateOneWithoutDeviceTestNestedInput
    cameraTest?: CameraTestUpdateOneWithoutDeviceTestNestedInput
    fingerprintTest?: FingerprintTestUpdateOneWithoutDeviceTestNestedInput
    usbTest?: UsbTestUpdateOneWithoutDeviceTestNestedInput
    audioJackTest?: AudioJackTestUpdateOneWithoutDeviceTestNestedInput
  }

  export type DeviceTestUncheckedUpdateWithoutAudioTestInput = {
    id?: StringFieldUpdateOperationsInput | string
    testId?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    device?: JsonNullValueInput | InputJsonValue
    imei1?: NullableStringFieldUpdateOperationsInput | string | null
    imei2?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    connectivityTestResults?: ConnectivityTestResultUncheckedUpdateManyWithoutDeviceTestNestedInput
    simTestResults?: SimTestResultUncheckedUpdateManyWithoutDeviceTestNestedInput
    deviceTestResults?: DeviceTestResultUncheckedUpdateManyWithoutDeviceTestNestedInput
    screenTest?: ScreenTestUncheckedUpdateOneWithoutDeviceTestNestedInput
    proximitySensorTest?: ProximitySensorTestUncheckedUpdateOneWithoutDeviceTestNestedInput
    cameraTest?: CameraTestUncheckedUpdateOneWithoutDeviceTestNestedInput
    fingerprintTest?: FingerprintTestUncheckedUpdateOneWithoutDeviceTestNestedInput
    usbTest?: UsbTestUncheckedUpdateOneWithoutDeviceTestNestedInput
    audioJackTest?: AudioJackTestUncheckedUpdateOneWithoutDeviceTestNestedInput
  }

  export type DeviceTestCreateWithoutProximitySensorTestInput = {
    id?: string
    testId: string
    employeeId?: string | null
    imageUrl?: string | null
    expiresAt: Date | string
    device: JsonNullValueInput | InputJsonValue
    imei1?: string | null
    imei2?: string | null
    createdAt?: Date | string
    connectivityTestResults?: ConnectivityTestResultCreateNestedManyWithoutDeviceTestInput
    simTestResults?: SimTestResultCreateNestedManyWithoutDeviceTestInput
    deviceTestResults?: DeviceTestResultCreateNestedManyWithoutDeviceTestInput
    screenTest?: ScreenTestCreateNestedOneWithoutDeviceTestInput
    audioTest?: AudioTestCreateNestedOneWithoutDeviceTestInput
    cameraTest?: CameraTestCreateNestedOneWithoutDeviceTestInput
    fingerprintTest?: FingerprintTestCreateNestedOneWithoutDeviceTestInput
    usbTest?: UsbTestCreateNestedOneWithoutDeviceTestInput
    audioJackTest?: AudioJackTestCreateNestedOneWithoutDeviceTestInput
  }

  export type DeviceTestUncheckedCreateWithoutProximitySensorTestInput = {
    id?: string
    testId: string
    employeeId?: string | null
    imageUrl?: string | null
    expiresAt: Date | string
    device: JsonNullValueInput | InputJsonValue
    imei1?: string | null
    imei2?: string | null
    createdAt?: Date | string
    connectivityTestResults?: ConnectivityTestResultUncheckedCreateNestedManyWithoutDeviceTestInput
    simTestResults?: SimTestResultUncheckedCreateNestedManyWithoutDeviceTestInput
    deviceTestResults?: DeviceTestResultUncheckedCreateNestedManyWithoutDeviceTestInput
    screenTest?: ScreenTestUncheckedCreateNestedOneWithoutDeviceTestInput
    audioTest?: AudioTestUncheckedCreateNestedOneWithoutDeviceTestInput
    cameraTest?: CameraTestUncheckedCreateNestedOneWithoutDeviceTestInput
    fingerprintTest?: FingerprintTestUncheckedCreateNestedOneWithoutDeviceTestInput
    usbTest?: UsbTestUncheckedCreateNestedOneWithoutDeviceTestInput
    audioJackTest?: AudioJackTestUncheckedCreateNestedOneWithoutDeviceTestInput
  }

  export type DeviceTestCreateOrConnectWithoutProximitySensorTestInput = {
    where: DeviceTestWhereUniqueInput
    create: XOR<DeviceTestCreateWithoutProximitySensorTestInput, DeviceTestUncheckedCreateWithoutProximitySensorTestInput>
  }

  export type DeviceTestUpsertWithoutProximitySensorTestInput = {
    update: XOR<DeviceTestUpdateWithoutProximitySensorTestInput, DeviceTestUncheckedUpdateWithoutProximitySensorTestInput>
    create: XOR<DeviceTestCreateWithoutProximitySensorTestInput, DeviceTestUncheckedCreateWithoutProximitySensorTestInput>
    where?: DeviceTestWhereInput
  }

  export type DeviceTestUpdateToOneWithWhereWithoutProximitySensorTestInput = {
    where?: DeviceTestWhereInput
    data: XOR<DeviceTestUpdateWithoutProximitySensorTestInput, DeviceTestUncheckedUpdateWithoutProximitySensorTestInput>
  }

  export type DeviceTestUpdateWithoutProximitySensorTestInput = {
    id?: StringFieldUpdateOperationsInput | string
    testId?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    device?: JsonNullValueInput | InputJsonValue
    imei1?: NullableStringFieldUpdateOperationsInput | string | null
    imei2?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    connectivityTestResults?: ConnectivityTestResultUpdateManyWithoutDeviceTestNestedInput
    simTestResults?: SimTestResultUpdateManyWithoutDeviceTestNestedInput
    deviceTestResults?: DeviceTestResultUpdateManyWithoutDeviceTestNestedInput
    screenTest?: ScreenTestUpdateOneWithoutDeviceTestNestedInput
    audioTest?: AudioTestUpdateOneWithoutDeviceTestNestedInput
    cameraTest?: CameraTestUpdateOneWithoutDeviceTestNestedInput
    fingerprintTest?: FingerprintTestUpdateOneWithoutDeviceTestNestedInput
    usbTest?: UsbTestUpdateOneWithoutDeviceTestNestedInput
    audioJackTest?: AudioJackTestUpdateOneWithoutDeviceTestNestedInput
  }

  export type DeviceTestUncheckedUpdateWithoutProximitySensorTestInput = {
    id?: StringFieldUpdateOperationsInput | string
    testId?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    device?: JsonNullValueInput | InputJsonValue
    imei1?: NullableStringFieldUpdateOperationsInput | string | null
    imei2?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    connectivityTestResults?: ConnectivityTestResultUncheckedUpdateManyWithoutDeviceTestNestedInput
    simTestResults?: SimTestResultUncheckedUpdateManyWithoutDeviceTestNestedInput
    deviceTestResults?: DeviceTestResultUncheckedUpdateManyWithoutDeviceTestNestedInput
    screenTest?: ScreenTestUncheckedUpdateOneWithoutDeviceTestNestedInput
    audioTest?: AudioTestUncheckedUpdateOneWithoutDeviceTestNestedInput
    cameraTest?: CameraTestUncheckedUpdateOneWithoutDeviceTestNestedInput
    fingerprintTest?: FingerprintTestUncheckedUpdateOneWithoutDeviceTestNestedInput
    usbTest?: UsbTestUncheckedUpdateOneWithoutDeviceTestNestedInput
    audioJackTest?: AudioJackTestUncheckedUpdateOneWithoutDeviceTestNestedInput
  }

  export type DeviceTestCreateWithoutCameraTestInput = {
    id?: string
    testId: string
    employeeId?: string | null
    imageUrl?: string | null
    expiresAt: Date | string
    device: JsonNullValueInput | InputJsonValue
    imei1?: string | null
    imei2?: string | null
    createdAt?: Date | string
    connectivityTestResults?: ConnectivityTestResultCreateNestedManyWithoutDeviceTestInput
    simTestResults?: SimTestResultCreateNestedManyWithoutDeviceTestInput
    deviceTestResults?: DeviceTestResultCreateNestedManyWithoutDeviceTestInput
    screenTest?: ScreenTestCreateNestedOneWithoutDeviceTestInput
    audioTest?: AudioTestCreateNestedOneWithoutDeviceTestInput
    proximitySensorTest?: ProximitySensorTestCreateNestedOneWithoutDeviceTestInput
    fingerprintTest?: FingerprintTestCreateNestedOneWithoutDeviceTestInput
    usbTest?: UsbTestCreateNestedOneWithoutDeviceTestInput
    audioJackTest?: AudioJackTestCreateNestedOneWithoutDeviceTestInput
  }

  export type DeviceTestUncheckedCreateWithoutCameraTestInput = {
    id?: string
    testId: string
    employeeId?: string | null
    imageUrl?: string | null
    expiresAt: Date | string
    device: JsonNullValueInput | InputJsonValue
    imei1?: string | null
    imei2?: string | null
    createdAt?: Date | string
    connectivityTestResults?: ConnectivityTestResultUncheckedCreateNestedManyWithoutDeviceTestInput
    simTestResults?: SimTestResultUncheckedCreateNestedManyWithoutDeviceTestInput
    deviceTestResults?: DeviceTestResultUncheckedCreateNestedManyWithoutDeviceTestInput
    screenTest?: ScreenTestUncheckedCreateNestedOneWithoutDeviceTestInput
    audioTest?: AudioTestUncheckedCreateNestedOneWithoutDeviceTestInput
    proximitySensorTest?: ProximitySensorTestUncheckedCreateNestedOneWithoutDeviceTestInput
    fingerprintTest?: FingerprintTestUncheckedCreateNestedOneWithoutDeviceTestInput
    usbTest?: UsbTestUncheckedCreateNestedOneWithoutDeviceTestInput
    audioJackTest?: AudioJackTestUncheckedCreateNestedOneWithoutDeviceTestInput
  }

  export type DeviceTestCreateOrConnectWithoutCameraTestInput = {
    where: DeviceTestWhereUniqueInput
    create: XOR<DeviceTestCreateWithoutCameraTestInput, DeviceTestUncheckedCreateWithoutCameraTestInput>
  }

  export type DeviceTestUpsertWithoutCameraTestInput = {
    update: XOR<DeviceTestUpdateWithoutCameraTestInput, DeviceTestUncheckedUpdateWithoutCameraTestInput>
    create: XOR<DeviceTestCreateWithoutCameraTestInput, DeviceTestUncheckedCreateWithoutCameraTestInput>
    where?: DeviceTestWhereInput
  }

  export type DeviceTestUpdateToOneWithWhereWithoutCameraTestInput = {
    where?: DeviceTestWhereInput
    data: XOR<DeviceTestUpdateWithoutCameraTestInput, DeviceTestUncheckedUpdateWithoutCameraTestInput>
  }

  export type DeviceTestUpdateWithoutCameraTestInput = {
    id?: StringFieldUpdateOperationsInput | string
    testId?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    device?: JsonNullValueInput | InputJsonValue
    imei1?: NullableStringFieldUpdateOperationsInput | string | null
    imei2?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    connectivityTestResults?: ConnectivityTestResultUpdateManyWithoutDeviceTestNestedInput
    simTestResults?: SimTestResultUpdateManyWithoutDeviceTestNestedInput
    deviceTestResults?: DeviceTestResultUpdateManyWithoutDeviceTestNestedInput
    screenTest?: ScreenTestUpdateOneWithoutDeviceTestNestedInput
    audioTest?: AudioTestUpdateOneWithoutDeviceTestNestedInput
    proximitySensorTest?: ProximitySensorTestUpdateOneWithoutDeviceTestNestedInput
    fingerprintTest?: FingerprintTestUpdateOneWithoutDeviceTestNestedInput
    usbTest?: UsbTestUpdateOneWithoutDeviceTestNestedInput
    audioJackTest?: AudioJackTestUpdateOneWithoutDeviceTestNestedInput
  }

  export type DeviceTestUncheckedUpdateWithoutCameraTestInput = {
    id?: StringFieldUpdateOperationsInput | string
    testId?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    device?: JsonNullValueInput | InputJsonValue
    imei1?: NullableStringFieldUpdateOperationsInput | string | null
    imei2?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    connectivityTestResults?: ConnectivityTestResultUncheckedUpdateManyWithoutDeviceTestNestedInput
    simTestResults?: SimTestResultUncheckedUpdateManyWithoutDeviceTestNestedInput
    deviceTestResults?: DeviceTestResultUncheckedUpdateManyWithoutDeviceTestNestedInput
    screenTest?: ScreenTestUncheckedUpdateOneWithoutDeviceTestNestedInput
    audioTest?: AudioTestUncheckedUpdateOneWithoutDeviceTestNestedInput
    proximitySensorTest?: ProximitySensorTestUncheckedUpdateOneWithoutDeviceTestNestedInput
    fingerprintTest?: FingerprintTestUncheckedUpdateOneWithoutDeviceTestNestedInput
    usbTest?: UsbTestUncheckedUpdateOneWithoutDeviceTestNestedInput
    audioJackTest?: AudioJackTestUncheckedUpdateOneWithoutDeviceTestNestedInput
  }

  export type DeviceTestCreateWithoutFingerprintTestInput = {
    id?: string
    testId: string
    employeeId?: string | null
    imageUrl?: string | null
    expiresAt: Date | string
    device: JsonNullValueInput | InputJsonValue
    imei1?: string | null
    imei2?: string | null
    createdAt?: Date | string
    connectivityTestResults?: ConnectivityTestResultCreateNestedManyWithoutDeviceTestInput
    simTestResults?: SimTestResultCreateNestedManyWithoutDeviceTestInput
    deviceTestResults?: DeviceTestResultCreateNestedManyWithoutDeviceTestInput
    screenTest?: ScreenTestCreateNestedOneWithoutDeviceTestInput
    audioTest?: AudioTestCreateNestedOneWithoutDeviceTestInput
    proximitySensorTest?: ProximitySensorTestCreateNestedOneWithoutDeviceTestInput
    cameraTest?: CameraTestCreateNestedOneWithoutDeviceTestInput
    usbTest?: UsbTestCreateNestedOneWithoutDeviceTestInput
    audioJackTest?: AudioJackTestCreateNestedOneWithoutDeviceTestInput
  }

  export type DeviceTestUncheckedCreateWithoutFingerprintTestInput = {
    id?: string
    testId: string
    employeeId?: string | null
    imageUrl?: string | null
    expiresAt: Date | string
    device: JsonNullValueInput | InputJsonValue
    imei1?: string | null
    imei2?: string | null
    createdAt?: Date | string
    connectivityTestResults?: ConnectivityTestResultUncheckedCreateNestedManyWithoutDeviceTestInput
    simTestResults?: SimTestResultUncheckedCreateNestedManyWithoutDeviceTestInput
    deviceTestResults?: DeviceTestResultUncheckedCreateNestedManyWithoutDeviceTestInput
    screenTest?: ScreenTestUncheckedCreateNestedOneWithoutDeviceTestInput
    audioTest?: AudioTestUncheckedCreateNestedOneWithoutDeviceTestInput
    proximitySensorTest?: ProximitySensorTestUncheckedCreateNestedOneWithoutDeviceTestInput
    cameraTest?: CameraTestUncheckedCreateNestedOneWithoutDeviceTestInput
    usbTest?: UsbTestUncheckedCreateNestedOneWithoutDeviceTestInput
    audioJackTest?: AudioJackTestUncheckedCreateNestedOneWithoutDeviceTestInput
  }

  export type DeviceTestCreateOrConnectWithoutFingerprintTestInput = {
    where: DeviceTestWhereUniqueInput
    create: XOR<DeviceTestCreateWithoutFingerprintTestInput, DeviceTestUncheckedCreateWithoutFingerprintTestInput>
  }

  export type DeviceTestUpsertWithoutFingerprintTestInput = {
    update: XOR<DeviceTestUpdateWithoutFingerprintTestInput, DeviceTestUncheckedUpdateWithoutFingerprintTestInput>
    create: XOR<DeviceTestCreateWithoutFingerprintTestInput, DeviceTestUncheckedCreateWithoutFingerprintTestInput>
    where?: DeviceTestWhereInput
  }

  export type DeviceTestUpdateToOneWithWhereWithoutFingerprintTestInput = {
    where?: DeviceTestWhereInput
    data: XOR<DeviceTestUpdateWithoutFingerprintTestInput, DeviceTestUncheckedUpdateWithoutFingerprintTestInput>
  }

  export type DeviceTestUpdateWithoutFingerprintTestInput = {
    id?: StringFieldUpdateOperationsInput | string
    testId?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    device?: JsonNullValueInput | InputJsonValue
    imei1?: NullableStringFieldUpdateOperationsInput | string | null
    imei2?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    connectivityTestResults?: ConnectivityTestResultUpdateManyWithoutDeviceTestNestedInput
    simTestResults?: SimTestResultUpdateManyWithoutDeviceTestNestedInput
    deviceTestResults?: DeviceTestResultUpdateManyWithoutDeviceTestNestedInput
    screenTest?: ScreenTestUpdateOneWithoutDeviceTestNestedInput
    audioTest?: AudioTestUpdateOneWithoutDeviceTestNestedInput
    proximitySensorTest?: ProximitySensorTestUpdateOneWithoutDeviceTestNestedInput
    cameraTest?: CameraTestUpdateOneWithoutDeviceTestNestedInput
    usbTest?: UsbTestUpdateOneWithoutDeviceTestNestedInput
    audioJackTest?: AudioJackTestUpdateOneWithoutDeviceTestNestedInput
  }

  export type DeviceTestUncheckedUpdateWithoutFingerprintTestInput = {
    id?: StringFieldUpdateOperationsInput | string
    testId?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    device?: JsonNullValueInput | InputJsonValue
    imei1?: NullableStringFieldUpdateOperationsInput | string | null
    imei2?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    connectivityTestResults?: ConnectivityTestResultUncheckedUpdateManyWithoutDeviceTestNestedInput
    simTestResults?: SimTestResultUncheckedUpdateManyWithoutDeviceTestNestedInput
    deviceTestResults?: DeviceTestResultUncheckedUpdateManyWithoutDeviceTestNestedInput
    screenTest?: ScreenTestUncheckedUpdateOneWithoutDeviceTestNestedInput
    audioTest?: AudioTestUncheckedUpdateOneWithoutDeviceTestNestedInput
    proximitySensorTest?: ProximitySensorTestUncheckedUpdateOneWithoutDeviceTestNestedInput
    cameraTest?: CameraTestUncheckedUpdateOneWithoutDeviceTestNestedInput
    usbTest?: UsbTestUncheckedUpdateOneWithoutDeviceTestNestedInput
    audioJackTest?: AudioJackTestUncheckedUpdateOneWithoutDeviceTestNestedInput
  }

  export type DeviceTestCreateWithoutUsbTestInput = {
    id?: string
    testId: string
    employeeId?: string | null
    imageUrl?: string | null
    expiresAt: Date | string
    device: JsonNullValueInput | InputJsonValue
    imei1?: string | null
    imei2?: string | null
    createdAt?: Date | string
    connectivityTestResults?: ConnectivityTestResultCreateNestedManyWithoutDeviceTestInput
    simTestResults?: SimTestResultCreateNestedManyWithoutDeviceTestInput
    deviceTestResults?: DeviceTestResultCreateNestedManyWithoutDeviceTestInput
    screenTest?: ScreenTestCreateNestedOneWithoutDeviceTestInput
    audioTest?: AudioTestCreateNestedOneWithoutDeviceTestInput
    proximitySensorTest?: ProximitySensorTestCreateNestedOneWithoutDeviceTestInput
    cameraTest?: CameraTestCreateNestedOneWithoutDeviceTestInput
    fingerprintTest?: FingerprintTestCreateNestedOneWithoutDeviceTestInput
    audioJackTest?: AudioJackTestCreateNestedOneWithoutDeviceTestInput
  }

  export type DeviceTestUncheckedCreateWithoutUsbTestInput = {
    id?: string
    testId: string
    employeeId?: string | null
    imageUrl?: string | null
    expiresAt: Date | string
    device: JsonNullValueInput | InputJsonValue
    imei1?: string | null
    imei2?: string | null
    createdAt?: Date | string
    connectivityTestResults?: ConnectivityTestResultUncheckedCreateNestedManyWithoutDeviceTestInput
    simTestResults?: SimTestResultUncheckedCreateNestedManyWithoutDeviceTestInput
    deviceTestResults?: DeviceTestResultUncheckedCreateNestedManyWithoutDeviceTestInput
    screenTest?: ScreenTestUncheckedCreateNestedOneWithoutDeviceTestInput
    audioTest?: AudioTestUncheckedCreateNestedOneWithoutDeviceTestInput
    proximitySensorTest?: ProximitySensorTestUncheckedCreateNestedOneWithoutDeviceTestInput
    cameraTest?: CameraTestUncheckedCreateNestedOneWithoutDeviceTestInput
    fingerprintTest?: FingerprintTestUncheckedCreateNestedOneWithoutDeviceTestInput
    audioJackTest?: AudioJackTestUncheckedCreateNestedOneWithoutDeviceTestInput
  }

  export type DeviceTestCreateOrConnectWithoutUsbTestInput = {
    where: DeviceTestWhereUniqueInput
    create: XOR<DeviceTestCreateWithoutUsbTestInput, DeviceTestUncheckedCreateWithoutUsbTestInput>
  }

  export type DeviceTestUpsertWithoutUsbTestInput = {
    update: XOR<DeviceTestUpdateWithoutUsbTestInput, DeviceTestUncheckedUpdateWithoutUsbTestInput>
    create: XOR<DeviceTestCreateWithoutUsbTestInput, DeviceTestUncheckedCreateWithoutUsbTestInput>
    where?: DeviceTestWhereInput
  }

  export type DeviceTestUpdateToOneWithWhereWithoutUsbTestInput = {
    where?: DeviceTestWhereInput
    data: XOR<DeviceTestUpdateWithoutUsbTestInput, DeviceTestUncheckedUpdateWithoutUsbTestInput>
  }

  export type DeviceTestUpdateWithoutUsbTestInput = {
    id?: StringFieldUpdateOperationsInput | string
    testId?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    device?: JsonNullValueInput | InputJsonValue
    imei1?: NullableStringFieldUpdateOperationsInput | string | null
    imei2?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    connectivityTestResults?: ConnectivityTestResultUpdateManyWithoutDeviceTestNestedInput
    simTestResults?: SimTestResultUpdateManyWithoutDeviceTestNestedInput
    deviceTestResults?: DeviceTestResultUpdateManyWithoutDeviceTestNestedInput
    screenTest?: ScreenTestUpdateOneWithoutDeviceTestNestedInput
    audioTest?: AudioTestUpdateOneWithoutDeviceTestNestedInput
    proximitySensorTest?: ProximitySensorTestUpdateOneWithoutDeviceTestNestedInput
    cameraTest?: CameraTestUpdateOneWithoutDeviceTestNestedInput
    fingerprintTest?: FingerprintTestUpdateOneWithoutDeviceTestNestedInput
    audioJackTest?: AudioJackTestUpdateOneWithoutDeviceTestNestedInput
  }

  export type DeviceTestUncheckedUpdateWithoutUsbTestInput = {
    id?: StringFieldUpdateOperationsInput | string
    testId?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    device?: JsonNullValueInput | InputJsonValue
    imei1?: NullableStringFieldUpdateOperationsInput | string | null
    imei2?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    connectivityTestResults?: ConnectivityTestResultUncheckedUpdateManyWithoutDeviceTestNestedInput
    simTestResults?: SimTestResultUncheckedUpdateManyWithoutDeviceTestNestedInput
    deviceTestResults?: DeviceTestResultUncheckedUpdateManyWithoutDeviceTestNestedInput
    screenTest?: ScreenTestUncheckedUpdateOneWithoutDeviceTestNestedInput
    audioTest?: AudioTestUncheckedUpdateOneWithoutDeviceTestNestedInput
    proximitySensorTest?: ProximitySensorTestUncheckedUpdateOneWithoutDeviceTestNestedInput
    cameraTest?: CameraTestUncheckedUpdateOneWithoutDeviceTestNestedInput
    fingerprintTest?: FingerprintTestUncheckedUpdateOneWithoutDeviceTestNestedInput
    audioJackTest?: AudioJackTestUncheckedUpdateOneWithoutDeviceTestNestedInput
  }

  export type DeviceTestCreateWithoutAudioJackTestInput = {
    id?: string
    testId: string
    employeeId?: string | null
    imageUrl?: string | null
    expiresAt: Date | string
    device: JsonNullValueInput | InputJsonValue
    imei1?: string | null
    imei2?: string | null
    createdAt?: Date | string
    connectivityTestResults?: ConnectivityTestResultCreateNestedManyWithoutDeviceTestInput
    simTestResults?: SimTestResultCreateNestedManyWithoutDeviceTestInput
    deviceTestResults?: DeviceTestResultCreateNestedManyWithoutDeviceTestInput
    screenTest?: ScreenTestCreateNestedOneWithoutDeviceTestInput
    audioTest?: AudioTestCreateNestedOneWithoutDeviceTestInput
    proximitySensorTest?: ProximitySensorTestCreateNestedOneWithoutDeviceTestInput
    cameraTest?: CameraTestCreateNestedOneWithoutDeviceTestInput
    fingerprintTest?: FingerprintTestCreateNestedOneWithoutDeviceTestInput
    usbTest?: UsbTestCreateNestedOneWithoutDeviceTestInput
  }

  export type DeviceTestUncheckedCreateWithoutAudioJackTestInput = {
    id?: string
    testId: string
    employeeId?: string | null
    imageUrl?: string | null
    expiresAt: Date | string
    device: JsonNullValueInput | InputJsonValue
    imei1?: string | null
    imei2?: string | null
    createdAt?: Date | string
    connectivityTestResults?: ConnectivityTestResultUncheckedCreateNestedManyWithoutDeviceTestInput
    simTestResults?: SimTestResultUncheckedCreateNestedManyWithoutDeviceTestInput
    deviceTestResults?: DeviceTestResultUncheckedCreateNestedManyWithoutDeviceTestInput
    screenTest?: ScreenTestUncheckedCreateNestedOneWithoutDeviceTestInput
    audioTest?: AudioTestUncheckedCreateNestedOneWithoutDeviceTestInput
    proximitySensorTest?: ProximitySensorTestUncheckedCreateNestedOneWithoutDeviceTestInput
    cameraTest?: CameraTestUncheckedCreateNestedOneWithoutDeviceTestInput
    fingerprintTest?: FingerprintTestUncheckedCreateNestedOneWithoutDeviceTestInput
    usbTest?: UsbTestUncheckedCreateNestedOneWithoutDeviceTestInput
  }

  export type DeviceTestCreateOrConnectWithoutAudioJackTestInput = {
    where: DeviceTestWhereUniqueInput
    create: XOR<DeviceTestCreateWithoutAudioJackTestInput, DeviceTestUncheckedCreateWithoutAudioJackTestInput>
  }

  export type DeviceTestUpsertWithoutAudioJackTestInput = {
    update: XOR<DeviceTestUpdateWithoutAudioJackTestInput, DeviceTestUncheckedUpdateWithoutAudioJackTestInput>
    create: XOR<DeviceTestCreateWithoutAudioJackTestInput, DeviceTestUncheckedCreateWithoutAudioJackTestInput>
    where?: DeviceTestWhereInput
  }

  export type DeviceTestUpdateToOneWithWhereWithoutAudioJackTestInput = {
    where?: DeviceTestWhereInput
    data: XOR<DeviceTestUpdateWithoutAudioJackTestInput, DeviceTestUncheckedUpdateWithoutAudioJackTestInput>
  }

  export type DeviceTestUpdateWithoutAudioJackTestInput = {
    id?: StringFieldUpdateOperationsInput | string
    testId?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    device?: JsonNullValueInput | InputJsonValue
    imei1?: NullableStringFieldUpdateOperationsInput | string | null
    imei2?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    connectivityTestResults?: ConnectivityTestResultUpdateManyWithoutDeviceTestNestedInput
    simTestResults?: SimTestResultUpdateManyWithoutDeviceTestNestedInput
    deviceTestResults?: DeviceTestResultUpdateManyWithoutDeviceTestNestedInput
    screenTest?: ScreenTestUpdateOneWithoutDeviceTestNestedInput
    audioTest?: AudioTestUpdateOneWithoutDeviceTestNestedInput
    proximitySensorTest?: ProximitySensorTestUpdateOneWithoutDeviceTestNestedInput
    cameraTest?: CameraTestUpdateOneWithoutDeviceTestNestedInput
    fingerprintTest?: FingerprintTestUpdateOneWithoutDeviceTestNestedInput
    usbTest?: UsbTestUpdateOneWithoutDeviceTestNestedInput
  }

  export type DeviceTestUncheckedUpdateWithoutAudioJackTestInput = {
    id?: StringFieldUpdateOperationsInput | string
    testId?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    device?: JsonNullValueInput | InputJsonValue
    imei1?: NullableStringFieldUpdateOperationsInput | string | null
    imei2?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    connectivityTestResults?: ConnectivityTestResultUncheckedUpdateManyWithoutDeviceTestNestedInput
    simTestResults?: SimTestResultUncheckedUpdateManyWithoutDeviceTestNestedInput
    deviceTestResults?: DeviceTestResultUncheckedUpdateManyWithoutDeviceTestNestedInput
    screenTest?: ScreenTestUncheckedUpdateOneWithoutDeviceTestNestedInput
    audioTest?: AudioTestUncheckedUpdateOneWithoutDeviceTestNestedInput
    proximitySensorTest?: ProximitySensorTestUncheckedUpdateOneWithoutDeviceTestNestedInput
    cameraTest?: CameraTestUncheckedUpdateOneWithoutDeviceTestNestedInput
    fingerprintTest?: FingerprintTestUncheckedUpdateOneWithoutDeviceTestNestedInput
    usbTest?: UsbTestUncheckedUpdateOneWithoutDeviceTestNestedInput
  }

  export type StoreCreateWithoutAddressInput = {
    storeId: string
    storeName: string
    ownerName: string
    ownerPhone: string
    ownerEmail: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStoreInput
    bankDetails?: BankDetailsCreateNestedOneWithoutStoreInput
  }

  export type StoreUncheckedCreateWithoutAddressInput = {
    userId: string
    storeId: string
    storeName: string
    ownerName: string
    ownerPhone: string
    ownerEmail: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bankDetails?: BankDetailsUncheckedCreateNestedOneWithoutStoreInput
  }

  export type StoreCreateOrConnectWithoutAddressInput = {
    where: StoreWhereUniqueInput
    create: XOR<StoreCreateWithoutAddressInput, StoreUncheckedCreateWithoutAddressInput>
  }

  export type StoreUpsertWithoutAddressInput = {
    update: XOR<StoreUpdateWithoutAddressInput, StoreUncheckedUpdateWithoutAddressInput>
    create: XOR<StoreCreateWithoutAddressInput, StoreUncheckedCreateWithoutAddressInput>
    where?: StoreWhereInput
  }

  export type StoreUpdateToOneWithWhereWithoutAddressInput = {
    where?: StoreWhereInput
    data: XOR<StoreUpdateWithoutAddressInput, StoreUncheckedUpdateWithoutAddressInput>
  }

  export type StoreUpdateWithoutAddressInput = {
    storeId?: StringFieldUpdateOperationsInput | string
    storeName?: StringFieldUpdateOperationsInput | string
    ownerName?: StringFieldUpdateOperationsInput | string
    ownerPhone?: StringFieldUpdateOperationsInput | string
    ownerEmail?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStoreNestedInput
    bankDetails?: BankDetailsUpdateOneWithoutStoreNestedInput
  }

  export type StoreUncheckedUpdateWithoutAddressInput = {
    userId?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    storeName?: StringFieldUpdateOperationsInput | string
    ownerName?: StringFieldUpdateOperationsInput | string
    ownerPhone?: StringFieldUpdateOperationsInput | string
    ownerEmail?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bankDetails?: BankDetailsUncheckedUpdateOneWithoutStoreNestedInput
  }

  export type CustomModelCreateWithoutBrandInput = {
    id?: string
    name: string
    code: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomModelUncheckedCreateWithoutBrandInput = {
    id?: string
    name: string
    code: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomModelCreateOrConnectWithoutBrandInput = {
    where: CustomModelWhereUniqueInput
    create: XOR<CustomModelCreateWithoutBrandInput, CustomModelUncheckedCreateWithoutBrandInput>
  }

  export type CustomModelCreateManyBrandInputEnvelope = {
    data: CustomModelCreateManyBrandInput | CustomModelCreateManyBrandInput[]
    skipDuplicates?: boolean
  }

  export type CustomModelUpsertWithWhereUniqueWithoutBrandInput = {
    where: CustomModelWhereUniqueInput
    update: XOR<CustomModelUpdateWithoutBrandInput, CustomModelUncheckedUpdateWithoutBrandInput>
    create: XOR<CustomModelCreateWithoutBrandInput, CustomModelUncheckedCreateWithoutBrandInput>
  }

  export type CustomModelUpdateWithWhereUniqueWithoutBrandInput = {
    where: CustomModelWhereUniqueInput
    data: XOR<CustomModelUpdateWithoutBrandInput, CustomModelUncheckedUpdateWithoutBrandInput>
  }

  export type CustomModelUpdateManyWithWhereWithoutBrandInput = {
    where: CustomModelScalarWhereInput
    data: XOR<CustomModelUpdateManyMutationInput, CustomModelUncheckedUpdateManyWithoutBrandInput>
  }

  export type CustomModelScalarWhereInput = {
    AND?: CustomModelScalarWhereInput | CustomModelScalarWhereInput[]
    OR?: CustomModelScalarWhereInput[]
    NOT?: CustomModelScalarWhereInput | CustomModelScalarWhereInput[]
    id?: StringFilter<"CustomModel"> | string
    name?: StringFilter<"CustomModel"> | string
    code?: StringFilter<"CustomModel"> | string
    brandId?: StringFilter<"CustomModel"> | string
    isActive?: BoolFilter<"CustomModel"> | boolean
    createdAt?: DateTimeFilter<"CustomModel"> | Date | string
    updatedAt?: DateTimeFilter<"CustomModel"> | Date | string
  }

  export type CustomModelBrandCreateWithoutModelsInput = {
    id?: string
    name: string
    logo?: string | null
    apiEndpoint?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomModelBrandUncheckedCreateWithoutModelsInput = {
    id?: string
    name: string
    logo?: string | null
    apiEndpoint?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomModelBrandCreateOrConnectWithoutModelsInput = {
    where: CustomModelBrandWhereUniqueInput
    create: XOR<CustomModelBrandCreateWithoutModelsInput, CustomModelBrandUncheckedCreateWithoutModelsInput>
  }

  export type CustomModelBrandUpsertWithoutModelsInput = {
    update: XOR<CustomModelBrandUpdateWithoutModelsInput, CustomModelBrandUncheckedUpdateWithoutModelsInput>
    create: XOR<CustomModelBrandCreateWithoutModelsInput, CustomModelBrandUncheckedCreateWithoutModelsInput>
    where?: CustomModelBrandWhereInput
  }

  export type CustomModelBrandUpdateToOneWithWhereWithoutModelsInput = {
    where?: CustomModelBrandWhereInput
    data: XOR<CustomModelBrandUpdateWithoutModelsInput, CustomModelBrandUncheckedUpdateWithoutModelsInput>
  }

  export type CustomModelBrandUpdateWithoutModelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    apiEndpoint?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomModelBrandUncheckedUpdateWithoutModelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    apiEndpoint?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyUserInput = {
    id?: string
    expiresAt: Date | string
    createdAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    device?: string | null
    browser?: string | null
    os?: string | null
    location?: string | null
    latitude?: number | null
    longitude?: number | null
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    os?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    os?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    os?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ConnectivityTestResultCreateManyDeviceTestInput = {
    id?: string
    name: string
    status: boolean
    message?: string | null
    timestamp?: Date | string | null
  }

  export type SimTestResultCreateManyDeviceTestInput = {
    id?: string
    name: string
    status: boolean
    timestamp?: Date | string | null
  }

  export type DeviceTestResultCreateManyDeviceTestInput = {
    id?: string
    name: string
    status: boolean
    message?: string | null
    timestamp?: Date | string | null
  }

  export type ConnectivityTestResultUpdateWithoutDeviceTestInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    message?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ConnectivityTestResultUncheckedUpdateWithoutDeviceTestInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    message?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ConnectivityTestResultUncheckedUpdateManyWithoutDeviceTestInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    message?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SimTestResultUpdateWithoutDeviceTestInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SimTestResultUncheckedUpdateWithoutDeviceTestInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SimTestResultUncheckedUpdateManyWithoutDeviceTestInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DeviceTestResultUpdateWithoutDeviceTestInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    message?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DeviceTestResultUncheckedUpdateWithoutDeviceTestInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    message?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DeviceTestResultUncheckedUpdateManyWithoutDeviceTestInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    message?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CustomModelCreateManyBrandInput = {
    id?: string
    name: string
    code: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomModelUpdateWithoutBrandInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomModelUncheckedUpdateWithoutBrandInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomModelUncheckedUpdateManyWithoutBrandInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}